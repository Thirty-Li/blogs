import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as a,o as e}from"./app-CARu8aWL.js";const l={};function h(n,i){return e(),t("div",null,i[0]||(i[0]=[a(`<h1 id="kallocator" tabindex="-1"><a class="header-anchor" href="#kallocator"><span><code>KAllocator</code></span></a></h1><p>基于内存池的自定义堆内存管理器，主要用于优化小对象的内存分配与释放。 其核心思想是预分配一块连续内存，并使用空闲链表进行管理，从而减少动态内存分配的开销。</p><blockquote><ol><li>内存池 (<code>memory_pool</code>)： 预先分配固定大小的内存块，提高分配效率。</li></ol></blockquote><blockquote><ol start="2"><li>空闲链表 (<code>free_list</code>)： 维护已释放的块，供后续复用，避免频繁调用 malloc/free。</li></ol></blockquote><blockquote><ol start="3"><li>分配策略： 先检查 <code>free_list</code>，若无可用块，则顺序分配新块。</li></ol></blockquote><blockquote><ol start="4"><li>释放策略： 释放的内存不会归还给系统，而是加入 <code>free_list</code>，加快后续分配速度。</li></ol></blockquote><blockquote><ol start="5"><li>兼容 <code>STL</code>： 通过 <code>rebind</code> 机制，使 <code>KAllocator</code> 适用于标准库容器</li></ol></blockquote><h3 id="代码流程" tabindex="-1"><a class="header-anchor" href="#代码流程"><span>代码流程</span></a></h3><p>初始化：</p><blockquote><p><code>memory_pool</code> 作为固定大小的数组，存放最多 <code>capacity</code> 个 T 类型对象。</p></blockquote><blockquote><p><code>free_list</code> 为空，<code>current</code> 记录当前分配位置。</p></blockquote><p>分配内存 <code>allocate()</code></p><blockquote><p>检查 <code>free_list</code> 是否有可用块：</p></blockquote><blockquote><p>若存在，则从 <code>free_list</code> 取出一个块。</p></blockquote><blockquote><p>若 <code>free_list</code> 为空，则从 <code>memory_pool</code> 分配新块。</p></blockquote><blockquote><p>若 <code>memory_pool</code> 已满，则调用 <code>std::allocator&lt;T&gt;</code> 进行动态分配。</p></blockquote><figure><img src="https://github.com/Thirty-Li/typoraImg/blob/main/blogImage/eac61daa49b40192fbe8a66b4439bfae.png?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>释放内存（deallocate()）</p><ol><li><p>释放的内存不会归还给系统，而是加入 <code>free_list</code>，以便后续复用。</p></li><li><p>维护 <code>free_list</code> 结构，使其始终指向最新释放的块。</p></li><li><p>若 n 超过 <code>capacity</code>，则使用 <code>std::allocator&lt;T&gt;</code> 进行正常释放。</p></li></ol><figure><img src="https://github.com/Thirty-Li/typoraImg/blob/main/blogImage/3ad0ab1905486e3c3c6b1a7b8a950cf5.png?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="kiterator" tabindex="-1"><a class="header-anchor" href="#kiterator"><span><code>KIterator</code></span></a></h1><p>提供类似 <code>STL</code> 迭代器的功能。</p><blockquote><p>支持指针操作 (<code>operator*</code>, <code>operator-&gt;</code>) 使其像指针一样使用。</p></blockquote><blockquote><p>支持递增和运算 (<code>operator++</code>, <code>operator+</code>, <code>operator-</code>) 方便遍历容器。</p></blockquote><blockquote><p>支持比较运算 (<code>operator==</code>, <code>operator!=</code>) 便于控制循环。</p></blockquote><blockquote><p>兼容 STL 迭代器，可以用于标准库算法。</p></blockquote><h1 id="kvector" tabindex="-1"><a class="header-anchor" href="#kvector"><span><code>KVector </code></span></a></h1><p>类似于标准库 <code>std::vector</code> 的动态数组实现，具有高效的动态扩展能力，支持自定义分配器 <code>Allocator</code>，并提供基本的容器操作接口。</p><blockquote><p>动态内存管理：使用 <code>KAllocator</code> 进行内存管理，支持动态扩容和缩容。</p></blockquote><blockquote><p>元素管理：提供插入、删除、访问、清空等操作。</p></blockquote><blockquote><p>迭代器支持：提供 <code>begin()</code> 和 <code>end()</code> 以支持遍历。</p></blockquote><blockquote><p>移动语义支持：实现移动构造和移动赋值优化性能。</p></blockquote><p>成员变量</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m_data;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               // 数据存储指针</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m_capacity;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // 容器容量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m_size;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           // 当前元素个数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Allocator m_allocator;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 内存分配器</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构造函数</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">KVector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 默认构造函数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">KVector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> size);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 带初始值（大小）的构造函数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typename</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">KVector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(Args... args);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 带初始值（数值）的构造函数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">KVector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(std::initializer_list</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> initList);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 列表初始化构造函数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">KVector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> KVector</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> kvector);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 拷贝构造函数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">KVector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(KVector</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> other) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 移动构造函数</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KVector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KVector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> other</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 移动赋值运算符</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存管理</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reserve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> new_capacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 重新分配内存</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> resize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> newSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 调整大小</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> clear</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 清空数组</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>元素访问</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[](</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 获取元素</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> at</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 通过at函数获取</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>元素操作</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> push_back</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 插入元素</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> insert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 在指定位置插入元素</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> erase</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 删除指定位置的元素</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> pop_back</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 删除最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 获取容器大小</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getCapacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 获取容器容量</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>迭代器支持</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">iterator</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 获取迭代器的起始位置</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">iterator</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 获取迭代器的结束位置</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,44)]))}const r=s(l,[["render",h],["__file","Vector.html.vue"]]),o=JSON.parse('{"path":"/zh/computer/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C__/STL/Vector.html","title":"KAllocator","lang":"zh-CN","frontmatter":{"tittle":"自定义Vector","index":true,"date":"2025-03-28T00:00:00.000Z","star":true,"article":true,"category":["String","C++"],"tag":["STL"],"description":"KAllocator 基于内存池的自定义堆内存管理器，主要用于优化小对象的内存分配与释放。 其核心思想是预分配一块连续内存，并使用空闲链表进行管理，从而减少动态内存分配的开销。 内存池 (memory_pool)： 预先分配固定大小的内存块，提高分配效率。 空闲链表 (free_list)： 维护已释放的块，供后续复用，避免频繁调用 malloc/fr...","head":[["meta",{"property":"og:url","content":"https://thirty-li.github.io/blogs/blogs/zh/computer/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C__/STL/Vector.html"}],["meta",{"property":"og:site_name","content":"Thirty_Li"}],["meta",{"property":"og:title","content":"KAllocator"}],["meta",{"property":"og:description","content":"KAllocator 基于内存池的自定义堆内存管理器，主要用于优化小对象的内存分配与释放。 其核心思想是预分配一块连续内存，并使用空闲链表进行管理，从而减少动态内存分配的开销。 内存池 (memory_pool)： 预先分配固定大小的内存块，提高分配效率。 空闲链表 (free_list)： 维护已释放的块，供后续复用，避免频繁调用 malloc/fr..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/Thirty-Li/typoraImg/blob/main/blogImage/eac61daa49b40192fbe8a66b4439bfae.png?raw=true"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-28T09:20:32.000Z"}],["meta",{"property":"article:tag","content":"STL"}],["meta",{"property":"article:published_time","content":"2025-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-28T09:20:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"KAllocator\\",\\"image\\":[\\"https://github.com/Thirty-Li/typoraImg/blob/main/blogImage/eac61daa49b40192fbe8a66b4439bfae.png?raw=true\\",\\"https://github.com/Thirty-Li/typoraImg/blob/main/blogImage/3ad0ab1905486e3c3c6b1a7b8a950cf5.png?raw=true\\"],\\"datePublished\\":\\"2025-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-28T09:20:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Thirty_Li\\",\\"url\\":\\"https://thirty-li.github.io/blogs/\\"}]}"]]},"headers":[{"level":3,"title":"代码流程","slug":"代码流程","link":"#代码流程","children":[]}],"git":{"createdTime":1743150542000,"updatedTime":1743153632000,"contributors":[{"name":"Thirty_Li","email":"thirty_li@qq.com","commits":4}]},"readingTime":{"minutes":2.93,"words":880},"filePathRelative":"zh/computer/编程语言/C++/STL/Vector.md","localizedDate":"2025年3月28日","excerpt":"\\n<p>基于内存池的自定义堆内存管理器，主要用于优化小对象的内存分配与释放。\\n其核心思想是预分配一块连续内存，并使用空闲链表进行管理，从而减少动态内存分配的开销。</p>\\n<blockquote>\\n<ol>\\n<li>内存池 (<code>memory_pool</code>)： 预先分配固定大小的内存块，提高分配效率。</li>\\n</ol>\\n</blockquote>\\n<blockquote>\\n<ol start=\\"2\\">\\n<li>空闲链表 (<code>free_list</code>)： 维护已释放的块，供后续复用，避免频繁调用 malloc/free。</li>\\n</ol>\\n</blockquote>","autoDesc":true}');export{r as comp,o as data};
