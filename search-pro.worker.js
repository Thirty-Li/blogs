const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":540,\"nextId\":540,\"documentIds\":{\"0\":\"1\",\"1\":\"1#介绍\",\"2\":\"3\",\"3\":\"3#目录\",\"4\":\"3#编程语言\",\"5\":\"3#计算机网络\",\"6\":\"3#数据库\",\"7\":\"3#操作系统\",\"8\":\"3#设计模式\",\"9\":\"3#中间件\",\"10\":\"3#git\",\"11\":\"3#docker\",\"12\":\"4\",\"13\":\"5\",\"14\":\"6\",\"15\":\"7\",\"16\":\"7#教程章节\",\"17\":\"7@0\",\"18\":\"8\",\"19\":\"8@0\",\"20\":\"8@1\",\"21\":\"9\",\"22\":\"9#_1-项目初始化\",\"23\":\"9#_2-安装依赖\",\"24\":\"9@0\",\"25\":\"10\",\"26\":\"10#推送代码到-github\",\"27\":\"10#使用-github-pages-发布站点\",\"28\":\"10@0\",\"29\":\"11\",\"30\":\"11#node-js\",\"31\":\"11#_1-点击-download-page-。\",\"32\":\"11#_2-运行安装包-保持所有的默认设置-一路下一步即可。\",\"33\":\"11#_3-然后再在安装路径的根目录下新建两个文件夹-node-cache和node-global-如图所示\",\"34\":\"11#_4-环境配置\",\"35\":\"11#_5-修改缓存目录和全局目录\",\"36\":\"11@0\",\"37\":\"11@1\",\"38\":\"12\",\"39\":\"12#教程章节\",\"40\":\"12@0\",\"41\":\"13\",\"42\":\"13@0\",\"43\":\"14\",\"44\":\"14#📍简介\",\"45\":\"14#📍题目创建\",\"46\":\"14#📌️general-info\",\"47\":\"14#📌️statement\",\"48\":\"14#📌️files\",\"49\":\"14#📌️checker\",\"50\":\"14#📌️interactor\",\"51\":\"14#📌️validator\",\"52\":\"14#📌️tests\",\"53\":\"14#📌️stresses\",\"54\":\"14#📌️solution-files\",\"55\":\"14#📌️invocations\",\"56\":\"14#📌️issues\",\"57\":\"14#📌️packages\",\"58\":\"14@0\",\"59\":\"15\",\"60\":\"15@0\",\"61\":\"16\",\"62\":\"16#教程章节\",\"63\":\"16@0\",\"64\":\"17\",\"65\":\"17#⬇️python-安装\",\"66\":\"17#_1-✅️️下载安装包python官网-。\",\"67\":\"17#_2-✅️️运行安装包。\",\"68\":\"17#⬇️pycharm-安装\",\"69\":\"17#_1-✅️️安装包下载\",\"70\":\"17#_2-✅️️pycharm-安装教程\",\"71\":\"17#_3-✅️️pycharm-常用快捷键\",\"72\":\"17@0\",\"73\":\"17@1\",\"74\":\"18\",\"75\":\"18#_1-✅️️数据合并\",\"76\":\"18#_2-✅️️数据处理\",\"77\":\"18#📌完整代码\",\"78\":\"18@0\",\"79\":\"19\",\"80\":\"19#_1-boss直聘\",\"81\":\"19#✅️url获取\",\"82\":\"19#✅️招聘信息获取\",\"83\":\"19#✅️代码编写\",\"84\":\"19#📌️url获取模块\",\"85\":\"19#📌数据抓取\",\"86\":\"19#✅️源代码如下\",\"87\":\"19#_2-智联招聘\",\"88\":\"19#✅️url获取-1\",\"89\":\"19#✅️招聘信息获取-1\",\"90\":\"19#✅️代码编写-1\",\"91\":\"19#📌url获取模块\",\"92\":\"19#📌数据抓取-1\",\"93\":\"19#✅️源代码如下-1\",\"94\":\"19#_3-前程无忧\",\"95\":\"19#✅️url获取-2\",\"96\":\"19#✅️简单demo编写\",\"97\":\"19@0\",\"98\":\"19@1\",\"99\":\"20\",\"100\":\"20#_1-全国招聘工作工资分布可视化表-html\",\"101\":\"20#📌数据获取\",\"102\":\"20#📌map-chart-地图\",\"103\":\"20#📌line-chart-折线图\",\"104\":\"20#📌bar-chart-柱状图\",\"105\":\"20#📌grid-chart-并行多图\",\"106\":\"20#📌timeline-时间线\",\"107\":\"20#📌完整代码\",\"108\":\"20#📌成果展示\",\"109\":\"20#_2-全国招聘工作数量可视化表-html\",\"110\":\"20#📌数据获取-1\",\"111\":\"20#📌map-chart-地图-1\",\"112\":\"20#📌pie-chart-饼图\",\"113\":\"20#📌grid-chart-并行多图-1\",\"114\":\"20#📌timeline-时间线-1\",\"115\":\"20#📌完整代码-1\",\"116\":\"20#📌成果展示-1\",\"117\":\"20#_3-岗位词云统计-html\",\"118\":\"20#📌数据获取-2\",\"119\":\"20#📌wordcloud-词云图\",\"120\":\"20#📌timeline-时间线-2\",\"121\":\"20#📌完整代码-2\",\"122\":\"20#📌成果展示-2\",\"123\":\"20@0\",\"124\":\"20@1\",\"125\":\"21\",\"126\":\"21#linux-安装启动\",\"127\":\"21#docker-安装启动\",\"128\":\"21#windows-安装启动\",\"129\":\"21#windows-后台服务安装\",\"130\":\"21@0\",\"131\":\"21@1\",\"132\":\"22\",\"133\":\"22#什么是对象存储\",\"134\":\"22#特点\",\"135\":\"22@0\",\"136\":\"22@1\",\"137\":\"23\",\"138\":\"23#引入依赖\",\"139\":\"23#配置文件\",\"140\":\"23#minioclient-的常用-api\",\"141\":\"23#bucket-操作\",\"142\":\"23#object-操作\",\"143\":\"23@0\",\"144\":\"23@1\",\"145\":\"24\",\"146\":\"24#概论\",\"147\":\"24#_1-注释\",\"148\":\"24#_1-1-单行注释\",\"149\":\"24#_1-2-多行注释\",\"150\":\"24#_2-变量\",\"151\":\"24#_2-1-定义变量\",\"152\":\"24#_2-2-使用变量\",\"153\":\"24#_2-3-只读变量\",\"154\":\"24#_2-4-删除变量\",\"155\":\"24#_2-5-变量类型\",\"156\":\"24#_2-6-字符串\",\"157\":\"24#_3-默认变量\",\"158\":\"24#_3-1-文件参数变量\",\"159\":\"24#_3-2-其它参数相关变量\",\"160\":\"24#_4-数组\",\"161\":\"24#_4-1-定义\",\"162\":\"24#_4-2-读取数组中某个元素的值\",\"163\":\"24#_4-3-读取整个数组\",\"164\":\"24#_4-4-数组长度\",\"165\":\"24@0\",\"166\":\"24@1\",\"167\":\"25\",\"168\":\"25#_1-基础\",\"169\":\"25#_1-1-连接\",\"170\":\"25#_1-2-sql-简介\",\"171\":\"25#_1-2-1-sql-通用语法\",\"172\":\"25#_1-2-2-分类\",\"173\":\"25#_2-数据库设计-ddl\",\"174\":\"25#_2-1-数据库操作\",\"175\":\"25#_2-1-1-查询数据库\",\"176\":\"25#_2-1-2-创建数据库\",\"177\":\"25#_2-1-3-使用数据库\",\"178\":\"25#_2-1-4-删除数据库\",\"179\":\"25#_2-2-表操作\",\"180\":\"25#_2-2-1-创建\",\"181\":\"25#_2-2-1-1-语法\",\"182\":\"25#_2-2-1-2-约束\",\"183\":\"25#_2-2-1-3-数据类型\",\"184\":\"25#_2-2-2-查询\",\"185\":\"25#_2-2-3-修改\",\"186\":\"25#_2-2-4-删除\",\"187\":\"25#_3-数据库操作-dml\",\"188\":\"25#_3-1-增加-insert\",\"189\":\"25#_3-2-修改-update\",\"190\":\"25#_3-3-删除-delete\",\"191\":\"25#_4-数据库操作-dql\",\"192\":\"25#_4-1-语法\",\"193\":\"25#_4-2-基本查询\",\"194\":\"25#_4-3-条件查询\",\"195\":\"25#_4-4-聚合函数\",\"196\":\"25#_4-5-分组查询\",\"197\":\"25#_4-6-排序查询\",\"198\":\"25#_4-7-分页查询\",\"199\":\"25#_5-多表设计\",\"200\":\"25#_5-1-一对多-外键约束\",\"201\":\"25#_5-2-一对一\",\"202\":\"25#_5-3-多对多\",\"203\":\"25#_6-多表查询\",\"204\":\"25#_6-1-概述\",\"205\":\"25#_6-1-1-介绍\",\"206\":\"25#_6-1-2-分类\",\"207\":\"25#_6-3-内连接\",\"208\":\"25#_6-3-外连接\",\"209\":\"25#_6-4-子查询\",\"210\":\"25#_6-4-1-介绍\",\"211\":\"25#_6-4-2-标量子查询\",\"212\":\"25#_6-4-3-列子查询\",\"213\":\"25#_6-4-4-行子查询\",\"214\":\"25#_6-4-5-表子查询\",\"215\":\"25#_7-事务\",\"216\":\"25#_7-1-介绍\",\"217\":\"25#_7-2-操作\",\"218\":\"25#_7-3-四大特性\",\"219\":\"25#_8-索引\",\"220\":\"25#_8-1-介绍\",\"221\":\"25#_8-2-结构\",\"222\":\"25#_8-3-语法\",\"223\":\"25@0\",\"224\":\"25@1\",\"225\":\"26\",\"226\":\"26#哈希表的工作原理\",\"227\":\"26#优点\",\"228\":\"26#缺点\",\"229\":\"26@0\",\"230\":\"26@1\",\"231\":\"27\",\"232\":\"27#一、语法基础\",\"233\":\"27#_1-1-变量\",\"234\":\"27#_1-2-运算符\",\"235\":\"27#_1-3-表达式\",\"236\":\"27#_1-4-输入\",\"237\":\"27#_1-5-输出\",\"238\":\"27#二、判断语句\",\"239\":\"27#_2-1-if-语句\",\"240\":\"27#_2-2-条件表达式\",\"241\":\"27#_2-3-switch-语句\",\"242\":\"27#三、循环语句\",\"243\":\"27#_3-1-while-循环\",\"244\":\"27#_3-2-do-while-循环\",\"245\":\"27#_3-3-for-循环\",\"246\":\"27#_3-4-跳转语句\",\"247\":\"27#_3-4-1-break\",\"248\":\"27#_3-4-2-continue\",\"249\":\"27#_3-5-多层循环\",\"250\":\"27#四、数组\",\"251\":\"27#_4-1-一维数组\",\"252\":\"27#_4-1-1-数组的定义\",\"253\":\"27#_4-1-2-数组的初始化\",\"254\":\"27#_4-1-3-访问数组元素\",\"255\":\"27#_4-2-多维数组\",\"256\":\"27#_4-3-数组的范围遍历\",\"257\":\"27#_4-3-常用api\",\"258\":\"27#五、字符串\",\"259\":\"27#_5-1-字符与整数的联系——ascii码\",\"260\":\"27#_5-2-string-类\",\"261\":\"27#_5-3-输入与输出\",\"262\":\"27#_5-4-stringbuilder、stringbuffer\",\"263\":\"27#六、函数\",\"264\":\"27#_6-1-函数基础\",\"265\":\"27#_6-1-1-编写函数\",\"266\":\"27#_6-1-2-调用函数\",\"267\":\"27#_6-1-3-形参和实参\",\"268\":\"27#_6-1-4-函数的形参列表\",\"269\":\"27#_6-1-5-函数返回类型\",\"270\":\"27#_6-1-6-变量的作用域\",\"271\":\"27#_6-2-参数传递\",\"272\":\"27#_6-2-1-值传递\",\"273\":\"27#_6-2-2-引用传递\",\"274\":\"27#_6-3-返回类型和-return-语句\",\"275\":\"27#_6-3-1-无返回值函数\",\"276\":\"27#_6-3-2-有返回值的函数\",\"277\":\"27#_6-4-函数重载\",\"278\":\"27#_6-5-函数递归\",\"279\":\"27#七、类与接口\",\"280\":\"27#_7-1-类与对象\",\"281\":\"27#_7-1-1-源文件声明规则\",\"282\":\"27#_7-1-2-类的定义\",\"283\":\"27#_7-1-3-类的继承\",\"284\":\"27#_7-1-4-类的多态\",\"285\":\"27#_7-2-接口\",\"286\":\"27#_7-2-1-接口的定义\",\"287\":\"27#_7-2-2-接口的继承\",\"288\":\"27#_7-2-3-接口的实现\",\"289\":\"27#_7-2-4-接口的多态\",\"290\":\"27#八、常用容器\",\"291\":\"27#_8-1-list\",\"292\":\"27#_8-2-栈\",\"293\":\"27#_8-3-队列\",\"294\":\"27#_8-4-set\",\"295\":\"27#_8-5-map\",\"296\":\"27#九、异常处理\",\"297\":\"27#_9-1-error-与-exception-的区别\",\"298\":\"27#_9-2-exception类的继承关系\",\"299\":\"27#_9-3-运行时异常和非运行时异常的区别\",\"300\":\"27#_9-4-内置异常类\",\"301\":\"27#_9-5-内置异常方法\",\"302\":\"27#_9-6-捕获异常\",\"303\":\"27#_9-7-抛出异常\",\"304\":\"27#_9-8-try-with-resources\",\"305\":\"27#十、注解与反射\",\"306\":\"27#_10-1-注解\",\"307\":\"27#_10-1-1-常用注解\",\"308\":\"27#_10-1-2-元注解\",\"309\":\"27#_10-2-反射\",\"310\":\"27#_10-2-1-常用api\",\"311\":\"27#_10-2-2-优缺点\",\"312\":\"27#十一、多线程与锁\",\"313\":\"27#_11-1-多线程\",\"314\":\"27#_11-1-1-实现多线程\",\"315\":\"27#_11-1-2-常用api\",\"316\":\"27#_11-2-锁\",\"317\":\"27#_11-3-同步-synchronized\",\"318\":\"27#_11-3-1-wait-与-notify\",\"319\":\"27@0\",\"320\":\"27@1\",\"321\":\"28\",\"322\":\"28#数组\",\"323\":\"28#字符串\",\"324\":\"28#string\",\"325\":\"28#stringbuilder\",\"326\":\"28#集合\",\"327\":\"28#list-列表\",\"328\":\"28#set-集合\",\"329\":\"28#map-映射\",\"330\":\"28#栈\",\"331\":\"28#queue-队列\",\"332\":\"28#deque-双端队列\",\"333\":\"28#priorityqueue-优先队列\",\"334\":\"28#工具类\",\"335\":\"28#java-util-math\",\"336\":\"28#java-util-collections\",\"337\":\"28#javafx-util-pair-k-v\",\"338\":\"28#基本类型的最大值和最小值\",\"339\":\"28@0\",\"340\":\"28@1\",\"341\":\"29\",\"342\":\"29#单例模式的定义\",\"343\":\"29@0\",\"344\":\"29@1\",\"345\":\"30\",\"346\":\"30#_1-为什么要用到并发\",\"347\":\"30#_2-并发编程有哪些缺点\",\"348\":\"30#_2-1-频繁的上下文切换\",\"349\":\"30#_2-2-线程安全\",\"350\":\"30#_3-应该了解的概念\",\"351\":\"30#_3-1-同步vs异步\",\"352\":\"30#_3-2-并发与并行\",\"353\":\"30#_3-3-阻塞和非阻塞\",\"354\":\"30#_3-4-临界区\",\"355\":\"30@0\",\"356\":\"30@1\",\"357\":\"31\",\"358\":\"31#_1-基本介绍\",\"359\":\"31#_2-重入性的实现原理\",\"360\":\"31#_3-公平锁与公平锁\",\"361\":\"31@0\",\"362\":\"31@1\",\"363\":\"32\",\"364\":\"32#_1-读写锁介绍\",\"365\":\"32#_2-写锁详解\",\"366\":\"32#_2-1-写锁的获取\",\"367\":\"32#_2-2-写锁的释放\",\"368\":\"32#_3-读锁详解\",\"369\":\"32#_3-1-读锁的获取\",\"370\":\"32#_3-2-读锁的释放\",\"371\":\"32#_4-锁降级\",\"372\":\"32@0\",\"373\":\"32@1\",\"374\":\"33\",\"375\":\"33#_1-condition-简介\",\"376\":\"33#_2-condition-实现原理分析\",\"377\":\"33#_2-1-等待队列\",\"378\":\"33#_2-2-await-实现原理\",\"379\":\"33#_2-3-signal-signalall-实现原理\",\"380\":\"33#_3-await-与-signal-signalall-的结合思考\",\"381\":\"33#_4-一个例子\",\"382\":\"33@0\",\"383\":\"33@1\",\"384\":\"34\",\"385\":\"34#_1-locksupport-简介\",\"386\":\"34#_2-locksupport方法介绍\",\"387\":\"34#_3-一个例子\",\"388\":\"34@0\",\"389\":\"34@1\",\"390\":\"35\",\"391\":\"35#_1-concurrenthashmap-简介\",\"392\":\"35#_2-concurrenthashmap-关键属性及类\",\"393\":\"35#_2-1-关键属性\",\"394\":\"35#_2-2-关键内部类\",\"395\":\"35#_2-3-cas-关键操作\",\"396\":\"35#_3-重点方法讲解\",\"397\":\"35#_3-1-实例构造器方法\",\"398\":\"35#_3-2-inittable-方法\",\"399\":\"35#_3-3-put-方法\",\"400\":\"35#_3-4-get-方法\",\"401\":\"35#_3-5-transfer-方法\",\"402\":\"35#_3-6-与-size-相关的一些方法\",\"403\":\"35#_4-总结\",\"404\":\"35@0\",\"405\":\"35@1\",\"406\":\"36\",\"407\":\"36#_1-concurrentlinkedqueue-简介\",\"408\":\"36#_1-1-node\",\"409\":\"36#_1-2-操作-node-的几个-cas-操作\",\"410\":\"36@0\",\"411\":\"36@1\",\"412\":\"37\",\"413\":\"37#_1-新建线程\",\"414\":\"37#_2-可运行线程\",\"415\":\"37#_3-阻塞和等待线程\",\"416\":\"37#_4-终止线程\",\"417\":\"37#_5-线程状态转换\",\"418\":\"37#_6-线程的基本操作\",\"419\":\"37#_6-1-interrupted\",\"420\":\"37#_6-2-join\",\"421\":\"37#_6-3-sleep\",\"422\":\"37#_6-4-yield\",\"423\":\"37#_7-守护线程-daemon\",\"424\":\"37@0\",\"425\":\"37@1\",\"426\":\"38\",\"427\":\"38#_1-jmm-介绍\",\"428\":\"38#_2-线程通信\",\"429\":\"38#_3-jmm-抽象结构模型\",\"430\":\"38#_4-重排序\",\"431\":\"38#_5-happens-before-规则\",\"432\":\"38#_5-1-happens-before-定义\",\"433\":\"38#_5-2-具体规则\",\"434\":\"38#_6-总结\",\"435\":\"38#_6-1-jmm-的设计\",\"436\":\"38#_6-2-happens-before-与-jmm-的关系\",\"437\":\"38#_6-3-今后可能需要关注的问题\",\"438\":\"38@0\",\"439\":\"38@1\",\"440\":\"39\",\"441\":\"39#_1-synchronized-简介\",\"442\":\"39#_2-synchronized-实现原理\",\"443\":\"39#_2-1-对象锁-monitor-机制\",\"444\":\"39#_2-2-synchronized-的-happens-before-关系\",\"445\":\"39#_2-3-锁获取和锁释放的内存语义\",\"446\":\"39#_3-synchronized优化\",\"447\":\"39#_3-1-cas-操作\",\"448\":\"39#_3-1-1-什么是-cas\",\"449\":\"39#_3-1-2-cas-的操作过程\",\"450\":\"39#_3-1-3-cas-的应用场景\",\"451\":\"39#_3-1-4-cas-的问题\",\"452\":\"39#_3-2-java-对象头\",\"453\":\"39#_3-3-偏向锁\",\"454\":\"39#_3-3-1-偏向锁的获取\",\"455\":\"39#_3-3-2-偏向锁的撤销\",\"456\":\"39#_3-3-3-如何关闭偏向锁\",\"457\":\"39#_3-4-轻量级锁\",\"458\":\"39#_3-4-1-加锁\",\"459\":\"39#_3-4-2-解锁\",\"460\":\"39#_3-5-各种锁的比较\",\"461\":\"39#_4-一个例子\",\"462\":\"39@0\",\"463\":\"39@1\",\"464\":\"40\",\"465\":\"40#_1-volatile-简介\",\"466\":\"40#_2-volatile-实现原理\",\"467\":\"40#_3-volatile-的-happens-before-关系\",\"468\":\"40#_4-volatile-的内存语义\",\"469\":\"40#_5-volatile-的内存语义实现\",\"470\":\"40#_6-一个例子\",\"471\":\"40@0\",\"472\":\"40@1\",\"473\":\"41\",\"474\":\"41#_1-final-简介\",\"475\":\"41#_2-final-的具体使用场景\",\"476\":\"41#_2-1-变量\",\"477\":\"41#_2-1-1-final-成员变量\",\"478\":\"41#_2-1-2-final-局部变量\",\"479\":\"41#_2-1-2-final-基本数据类型-vs-final-引用数据类型\",\"480\":\"41#_2-2-方法\",\"481\":\"41#_2-2-1-重写\",\"482\":\"41#_2-2-2-重载\",\"483\":\"41#_2-3-类\",\"484\":\"41#_3-final-的例子\",\"485\":\"41#_4-多线程中你真的了解-final-吗\",\"486\":\"41#_4-1-final-域重排序规则\",\"487\":\"41#_4-1-1-final-域为基本类型\",\"488\":\"41#_4-1-2-final-域为引用类型\",\"489\":\"41#_5-final-的实现原理\",\"490\":\"41#_6-为什么-final-引用不能从构造函数中-溢出\",\"491\":\"41@0\",\"492\":\"41@1\",\"493\":\"42\",\"494\":\"42#_1-原子性\",\"495\":\"42#_2-有序性\",\"496\":\"42#_2-1-synchronized\",\"497\":\"42#_2-2-volatile\",\"498\":\"42#_3-可见性\",\"499\":\"42#_4-总结\",\"500\":\"42@0\",\"501\":\"42@1\",\"502\":\"43\",\"503\":\"43#_1-concurrent-包的结构层次\",\"504\":\"43#_2-lock-简介\",\"505\":\"43#_2-1-lock-接口-api\",\"506\":\"43#_2-2-初识-aqs\",\"507\":\"43#_2-3-aqs-的模板方法设计模式\",\"508\":\"43#_3-一个例子\",\"509\":\"43@0\",\"510\":\"43@1\",\"511\":\"44\",\"512\":\"44#_1-aqs-简介\",\"513\":\"44#_2-同步队列\",\"514\":\"44#_3-独占锁\",\"515\":\"44#_3-1-独占锁的获取-acquire\",\"516\":\"44#_3-1-1-获取同步状态失败-入队操作\",\"517\":\"44#_3-1-2-获取锁成功-出队操作\",\"518\":\"44#_3-2-独占锁的释放-release\",\"519\":\"44#_3-3-可中断式获取锁-acquireinterruptibly\",\"520\":\"44#_3-4-超时等待式获取锁-tryacquirenanos\",\"521\":\"44#_4-共享锁\",\"522\":\"44#_4-1-共享锁的获取-acquireshared\",\"523\":\"44#_4-2-共享锁的释放-releaseshared\",\"524\":\"44#_4-3-可中断-acquiresharedinterruptibly-超时等待-tryacquiresharednanos\",\"525\":\"44@0\",\"526\":\"44@1\",\"527\":\"45\",\"528\":\"46\",\"529\":\"47\",\"530\":\"48\",\"531\":\"49\",\"532\":\"50\",\"533\":\"51\",\"534\":\"52\",\"535\":\"53\",\"536\":\"54\",\"537\":\"55\",\"538\":\"56\",\"539\":\"57\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,12],\"2\":[1,9],\"3\":[1],\"4\":[1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1],\"9\":[1,44],\"10\":[1],\"11\":[1],\"12\":[1,3],\"13\":[1,4],\"14\":[1,3],\"15\":[1,6],\"16\":[1,4],\"17\":[null,null,2],\"18\":[1,4],\"19\":[null,null,4],\"20\":[null,null,2],\"21\":[1,6],\"22\":[2,53],\"23\":[2,109],\"24\":[null,null,3],\"25\":[1,4],\"26\":[2,50],\"27\":[4,19],\"28\":[null,null,2],\"29\":[1,4],\"30\":[2,12],\"31\":[1],\"32\":[5,3],\"33\":[5],\"34\":[2,32],\"35\":[2,15],\"36\":[null,null,3],\"37\":[null,null,1],\"38\":[1,3],\"39\":[1,3],\"40\":[null,null,2],\"41\":[1,10],\"42\":[null,null,1],\"43\":[1,3],\"44\":[1,43],\"45\":[1,16],\"46\":[2,5],\"47\":[1,38],\"48\":[1,28],\"49\":[1,39],\"50\":[1,13],\"51\":[1,12],\"52\":[1,20],\"53\":[1,19],\"54\":[2,5],\"55\":[1,28],\"56\":[1,4],\"57\":[1,23],\"58\":[null,null,1],\"59\":[1],\"60\":[null,null,1],\"61\":[1,4],\"62\":[1,4],\"63\":[null,null,3],\"64\":[1,4],\"65\":[2,8],\"66\":[1],\"67\":[3,37],\"68\":[2,28],\"69\":[2,7],\"70\":[3,25],\"71\":[3,35],\"72\":[null,null,4],\"73\":[null,null,1],\"74\":[1,5],\"75\":[2,83],\"76\":[2,491],\"77\":[1,560],\"78\":[null,null,4],\"79\":[1,4],\"80\":[2],\"81\":[1,28],\"82\":[1,28],\"83\":[1,2],\"84\":[1,52],\"85\":[1,104],\"86\":[1,162],\"87\":[2],\"88\":[1,17],\"89\":[1,9],\"90\":[1,2],\"91\":[1,44],\"92\":[1,97],\"93\":[1,166],\"94\":[2,7],\"95\":[1,41],\"96\":[1,79],\"97\":[null,null,2],\"98\":[null,null,4],\"99\":[1,13],\"100\":[3],\"101\":[1,74],\"102\":[4,95],\"103\":[4,52],\"104\":[4,63],\"105\":[4,26],\"106\":[3,68],\"107\":[1,236],\"108\":[1],\"109\":[3],\"110\":[1,1],\"111\":[4,84],\"112\":[4,57],\"113\":[4,17],\"114\":[3,65],\"115\":[1,190],\"116\":[1],\"117\":[3],\"118\":[1,38],\"119\":[3,27],\"120\":[3,25],\"121\":[1,107],\"122\":[1],\"123\":[null,null,4],\"124\":[null,null,6],\"125\":[2,16],\"126\":[2,85],\"127\":[2,20],\"128\":[2,42],\"129\":[2,78],\"130\":[null,null,1],\"131\":[null,null,1],\"132\":[2,40],\"133\":[2,56],\"134\":[1,143],\"135\":[null,null,1],\"136\":[null,null,1],\"137\":[3],\"138\":[1,12],\"139\":[1,85],\"140\":[3],\"141\":[2,76],\"142\":[2,95],\"143\":[null,null,1],\"144\":[null,null,1],\"145\":[2],\"146\":[1,60],\"147\":[2],\"148\":[2,7],\"149\":[3,13],\"150\":[2],\"151\":[3,13],\"152\":[2,14],\"153\":[3,12],\"154\":[3,7],\"155\":[3,22],\"156\":[3,28],\"157\":[2],\"158\":[3,37],\"159\":[3,27],\"160\":[2,6],\"161\":[3,17],\"162\":[3,15],\"163\":[3,12],\"164\":[2,12],\"165\":[null,null,1],\"166\":[null,null,1],\"167\":[2],\"168\":[2],\"169\":[2,32],\"170\":[4,5],\"171\":[4,19],\"172\":[3,27],\"173\":[3,13],\"174\":[3,15],\"175\":[3,11],\"176\":[3,19],\"177\":[4,9],\"178\":[4,28],\"179\":[2,6],\"180\":[3],\"181\":[3,18],\"182\":[3,55],\"183\":[4,156],\"184\":[2,14],\"185\":[3,39],\"186\":[3,13],\"187\":[3,15],\"188\":[5,22],\"189\":[5,37],\"190\":[4,23],\"191\":[3],\"192\":[3,31],\"193\":[3,22],\"194\":[3,52],\"195\":[2,40],\"196\":[3,39],\"197\":[3,27],\"198\":[3,65],\"199\":[2,11],\"200\":[4,52],\"201\":[3,45],\"202\":[3,17],\"203\":[2],\"204\":[3],\"205\":[3,34],\"206\":[4,14],\"207\":[3,29],\"208\":[3,31],\"209\":[3],\"210\":[4,36],\"211\":[4,8],\"212\":[4,11],\"213\":[3,8],\"214\":[4,4],\"215\":[2],\"216\":[3,24],\"217\":[3,32],\"218\":[3,41],\"219\":[2],\"220\":[3,24],\"221\":[3,161],\"222\":[3,19],\"223\":[null,null,1],\"224\":[null,null,1],\"225\":[1],\"226\":[1,50],\"227\":[1,18],\"228\":[1,27],\"229\":[null,null,1],\"230\":[null,null,1],\"231\":[2],\"232\":[2],\"233\":[2,57],\"234\":[3,37],\"235\":[3,38],\"236\":[3,52],\"237\":[3,67],\"238\":[2,4],\"239\":[4,102],\"240\":[2,51],\"241\":[4,52],\"242\":[2,8],\"243\":[4,69],\"244\":[5,27],\"245\":[3,82],\"246\":[3],\"247\":[4,46],\"248\":[4,34],\"249\":[3,43],\"250\":[2,7],\"251\":[3],\"252\":[3,25],\"253\":[4,25],\"254\":[4,58],\"255\":[3,52],\"256\":[3,37],\"257\":[3,19],\"258\":[2,2],\"259\":[4,48],\"260\":[4,101],\"261\":[3,37],\"262\":[4,33],\"263\":[2,3],\"264\":[3,6],\"265\":[3,26],\"266\":[4,34],\"267\":[4,20],\"268\":[4,16],\"269\":[4,34],\"270\":[3,32],\"271\":[3],\"272\":[4,24],\"273\":[3,53],\"274\":[5,5],\"275\":[4,48],\"276\":[4,38],\"277\":[3,33],\"278\":[3,34],\"279\":[2,3],\"280\":[3,14],\"281\":[3,14],\"282\":[4,43],\"283\":[4,25],\"284\":[4,28],\"285\":[3,8],\"286\":[4,11],\"287\":[3,9],\"288\":[4,27],\"289\":[4,35],\"290\":[2],\"291\":[3,24],\"292\":[3,18],\"293\":[3,27],\"294\":[3,29],\"295\":[3,42],\"296\":[2,2],\"297\":[6,18],\"298\":[3,2],\"299\":[3,27],\"300\":[3,86],\"301\":[3,29],\"302\":[3,42],\"303\":[3,43],\"304\":[5,54],\"305\":[2],\"306\":[3,28],\"307\":[3,20],\"308\":[4,16],\"309\":[3,5],\"310\":[4,69],\"311\":[3,5],\"312\":[2],\"313\":[3],\"314\":[3,55],\"315\":[4,14],\"316\":[3,50],\"317\":[5,51],\"318\":[6,59],\"319\":[null,null,1],\"320\":[null,null,1],\"321\":[1,4],\"322\":[1,28],\"323\":[1,25],\"324\":[1,156],\"325\":[1,21],\"326\":[1],\"327\":[2,70],\"328\":[2,43],\"329\":[2,113],\"330\":[1,60],\"331\":[2,42],\"332\":[2,33],\"333\":[2,69],\"334\":[1],\"335\":[3,35],\"336\":[3,44],\"337\":[4,32],\"338\":[1,28],\"339\":[null,null,1],\"340\":[null,null,1],\"341\":[3],\"342\":[1,9],\"343\":[null,null,1],\"344\":[null,null,1],\"345\":[1],\"346\":[2,86],\"347\":[2,5],\"348\":[3,47],\"349\":[2,120],\"350\":[2],\"351\":[3,23],\"352\":[3,14],\"353\":[2,9],\"354\":[3,6],\"355\":[null,null,1],\"356\":[null,null,1],\"357\":[2],\"358\":[2,26],\"359\":[2,105],\"360\":[2,95],\"361\":[null,null,1],\"362\":[null,null,1],\"363\":[2],\"364\":[2,62],\"365\":[2],\"366\":[3,156],\"367\":[2,47],\"368\":[2],\"369\":[3,153],\"370\":[3,72],\"371\":[2,47],\"372\":[null,null,1],\"373\":[null,null,1],\"374\":[7],\"375\":[3,81],\"376\":[3],\"377\":[3,143],\"378\":[3,221],\"379\":[5,147],\"380\":[6,47],\"381\":[2,67],\"382\":[null,null,1],\"383\":[null,null,1],\"384\":[2],\"385\":[3,45],\"386\":[2,122],\"387\":[2,46],\"388\":[null,null,1],\"389\":[null,null,1],\"390\":[2],\"391\":[3,108],\"392\":[3,4],\"393\":[3,113],\"394\":[2,110],\"395\":[4,48],\"396\":[2,3],\"397\":[3,132],\"398\":[4,99],\"399\":[3,371],\"400\":[4,76],\"401\":[4,244],\"402\":[5,208],\"403\":[2,86],\"404\":[null,null,1],\"405\":[null,null,1],\"406\":[2],\"407\":[3,36],\"408\":[2,49],\"409\":[6,48],\"410\":[null,null,1],\"411\":[null,null,1],\"412\":[1,20],\"413\":[2,119],\"414\":[2,32],\"415\":[2,14],\"416\":[2,9],\"417\":[2,70],\"418\":[2],\"419\":[3,87],\"420\":[3,113],\"421\":[3,44],\"422\":[3,65],\"423\":[3,106],\"424\":[null,null,1],\"425\":[null,null,1],\"426\":[4],\"427\":[3,23],\"428\":[2,48],\"429\":[3,47],\"430\":[2,107],\"431\":[4,12],\"432\":[5,95],\"433\":[3,71],\"434\":[2,13],\"435\":[4,75],\"436\":[7,13],\"437\":[3,19],\"438\":[null,null,1],\"439\":[null,null,1],\"440\":[2],\"441\":[3,83],\"442\":[3,21],\"443\":[5,87],\"444\":[6,64],\"445\":[3,60],\"446\":[2,41],\"447\":[4],\"448\":[5,22],\"449\":[5,55],\"450\":[4,19],\"451\":[5,61],\"452\":[4,41],\"453\":[2,7],\"454\":[3,24],\"455\":[3,28],\"456\":[2,21],\"457\":[3],\"458\":[4,19],\"459\":[4,27],\"460\":[3],\"461\":[2,68],\"462\":[null,null,1],\"463\":[null,null,1],\"464\":[2],\"465\":[3,30],\"466\":[3,60],\"467\":[6,87],\"468\":[3,49],\"469\":[3,52],\"470\":[2,51],\"471\":[null,null,1],\"472\":[null,null,1],\"473\":[3],\"474\":[3,10],\"475\":[3],\"476\":[3,5],\"477\":[4,23],\"478\":[4,13],\"479\":[6,67],\"480\":[2],\"481\":[4,35],\"482\":[3,14],\"483\":[3,20],\"484\":[3,50],\"485\":[5,16],\"486\":[4],\"487\":[4,127],\"488\":[5,95],\"489\":[3,33],\"490\":[6,57],\"491\":[null,null,1],\"492\":[null,null,1],\"493\":[4],\"494\":[2,187],\"495\":[2],\"496\":[3,11],\"497\":[2,64],\"498\":[2,19],\"499\":[2,6],\"500\":[null,null,1],\"501\":[null,null,1],\"502\":[4],\"503\":[3,27],\"504\":[3,40],\"505\":[5,52],\"506\":[3,40],\"507\":[4,88],\"508\":[2,232],\"509\":[null,null,1],\"510\":[null,null,1],\"511\":[2],\"512\":[3,55],\"513\":[2,71],\"514\":[2],\"515\":[5,35],\"516\":[4,148],\"517\":[5,142],\"518\":[5,138],\"519\":[4,69],\"520\":[5,119],\"521\":[2],\"522\":[5,61],\"523\":[5,109],\"524\":[7,4],\"525\":[null,null,1],\"526\":[null,null,1],\"527\":[1,3],\"528\":[1],\"529\":[2],\"530\":[1],\"531\":[1],\"532\":[1],\"533\":[2],\"534\":[1],\"535\":[1],\"536\":[1],\"537\":[1],\"538\":[1],\"539\":[2]},\"averageFieldLength\":[2.572119029244947,44.19388271673722,0.9228320537124667],\"storedFields\":{\"0\":{\"h\":\"个人介绍\"},\"1\":{\"h\":\"介绍\",\"t\":[\"这是一个档案主页的案例。\",\"要使用此布局，你应该在页面 Frontmatter 中设置 home: true 和 portfolio: true。\",\"相关配置文档请见 档案主页。\"]},\"2\":{\"h\":\"计算机\",\"t\":[\"此处存放一些计算机大类的笔记，包括编程语言、计算机网络、操作系统、数据库、Linux、Git、Docker等等。\"]},\"3\":{\"h\":\"目录\"},\"4\":{\"h\":\"编程语言\"},\"5\":{\"h\":\"计算机网络\"},\"6\":{\"h\":\"数据库\"},\"7\":{\"h\":\"操作系统\"},\"8\":{\"h\":\"设计模式\"},\"9\":{\"h\":\"中间件\",\"t\":[\"中间件（英语：Middleware）：是一种在系统软件和用户应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件在客户服务器的操作系统、网络和数据库之上，管理计算资源和网络通信。总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。\",\"也就是说，关于中间件，可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件；中间件不仅仅实现互连，还要实现应用之间的互操作。\",\"中间件与操作系统和数据库共同构成基础软件三大支柱，是一种应用于分布式系统的基础软件，位于应用与操作系统、数据库之间，为上层应用软件提供开发、运行和集成的平台。中间件解决了异构网络环境下软件互联和互操作等共性问题，并提供标准接口、协议，为应用软件间共享资源提供了可复用的“标准件”。\",\"常见中间件主要分为：Web中间件、数据库中间件、消息中间件、安全中间件、事务中间件、应用程序服务器中间件、分布式计算中间件等。\"]},\"10\":{\"h\":\"Git\"},\"11\":{\"h\":\"Docker\"},\"12\":{\"h\":\"学习笔记\",\"t\":[\"此处存放自己写的一些学习笔记，帮助学习。\"]},\"13\":{\"h\":\"算法笔记\",\"t\":[\"此处存放刷题时的思路和笔记，包括算法题、笔试题和面试题等。\"]},\"14\":{\"h\":\"开源项目\",\"t\":[\"此处存放自己写和一些优秀的开源项目，帮助学习。\"]},\"15\":{\"h\":\"博客搭建\",\"t\":[\"此教程将指引你创建一个 VuePress Theme Hope 项目。\"]},\"16\":{\"h\":\"教程章节\",\"t\":[\"运行环境搭建\",\"创建项目\",\"配置项目\",\"项目部署\"]},\"17\":{\"c\":[\"学习笔记\",\"VuePress\"]},\"18\":{\"h\":\"项目配置\",\"t\":[\"本教程指引你如何配置 VuePress 项目。\"]},\"19\":{\"c\":[\"VuePress\",\"Tutorial\",\"Get Started\"]},\"20\":{\"c\":[\"Project Config\"]},\"21\":{\"h\":\"创建项目\",\"t\":[\"此教程将指引你创建一个 VuePress Theme Hope 项目。\"]},\"22\":{\"h\":\"1. 项目初始化\",\"t\":[\"使用 vuepress-theme-hope 主题提供的脚手架工具创建项目\",\"用管理员模式打开 cmd 窗口\",\"切换到想要放置项目的路径\",\"例如要切换到 E:\\\\Project ，执行 e: 切换到 E 盘，执行 cd [dir] 进入 [dir] 目录\",\"注意\",\"[dir]指的是你将要放置你的项目所在的文件路径\",\"执行以下命令：\",\"npm init vuepress-theme-hope my-docs\",\"注意\",\"这里的 my-docs 是一个参数，代表 VuePress Theme Hope 项目的文件夹名称，在本教程中，我们将项目生成至当前目录下的 my-docs 文件夹。 如果你有需求，你可以更改此参数来使用一个新文件夹名称。\",\"选择一些默认的配置\",\"选择包管理器 npm\",\"设置协议 MIT\",\"项目需要用到多语言么 NO\",\"你想要创建什么类型的项目 docs\",\"是否需要一个自动部署文档到 GitHub Pages 的工作流 YES\",\"选择你想使用的源 当前源\"]},\"23\":{\"h\":\"2. 安装依赖\",\"t\":[\"由于插件之间版本不同容易出现依赖冲突，可以直接修改package.json文件\",\"{ \\\"name\\\": \\\"vuepress-theme-hope-template\\\", \\\"description\\\": \\\"A project of vuepress-theme-hope\\\", \\\"version\\\": \\\"2.0.0\\\", \\\"license\\\": \\\"MIT\\\", \\\"type\\\": \\\"module\\\", \\\"scripts\\\": { \\\"docs:build\\\": \\\"vuepress-vite build src\\\", \\\"docs:clean-dev\\\": \\\"vuepress-vite dev src --clean-cache\\\", \\\"docs:dev\\\": \\\"vuepress-vite dev src\\\", \\\"docs:update-package\\\": \\\"npx vp-update\\\" }, \\\"devDependencies\\\": { \\\"@types/katex\\\": \\\"0.16.7\\\", \\\"@vue/repl\\\": \\\"4.4.2\\\", \\\"@vuepress/bundler-vite\\\": \\\"2.0.0-rc.15\\\", \\\"@vuepress/bundler-webpack\\\": \\\"2.0.0-rc.15\\\", \\\"@vuepress/helper\\\": \\\"2.0.0-rc.47\\\", \\\"@vuepress/plugin-feed\\\": \\\"2.0.0-rc.47\\\", \\\"@vuepress/plugin-revealjs\\\": \\\"2.0.0-rc.48\\\", \\\"@vueuse/core\\\": \\\"11.1.0\\\", \\\"@waline/client\\\": \\\"^3.3.2\\\", \\\"artplayer\\\": \\\"5.1.7\\\", \\\"echarts-wordcloud\\\": \\\"2.1.0\\\", \\\"flowchart.ts\\\": \\\"3.0.1\\\", \\\"katex\\\": \\\"0.16.11\\\", \\\"kotlin-playground\\\": \\\"1.30.0\\\", \\\"markmap-lib\\\": \\\"0.17.0\\\", \\\"markmap-toolbar\\\": \\\"0.17.0\\\", \\\"markmap-view\\\": \\\"0.17.0\\\", \\\"mermaid\\\": \\\"11.2.1\\\", \\\"sandpack-vue3\\\": \\\"3.1.11\\\", \\\"sass-embedded\\\": \\\"1.79.3\\\", \\\"sass-loader\\\": \\\"16.0.2\\\", \\\"vue\\\": \\\"3.5.8\\\", \\\"vuepress\\\": \\\"2.0.0-rc.15\\\", \\\"vuepress-plugin-components\\\": \\\"2.0.0-rc.54\\\", \\\"vuepress-plugin-md-enhance\\\": \\\"2.0.0-rc.54\\\", \\\"vuepress-plugin-search-pro\\\": \\\"^2.0.0-rc.54\\\", \\\"vuepress-shared\\\": \\\"2.0.0-rc.54\\\", \\\"vuepress-theme-hope\\\": \\\"2.0.0-rc.56\\\" } }\",\"用管理员模式在项目根目录(也就是你package.json所在的文件夹目录)执行以下命令，等待自动下载\",\"npm install\",\"下载完成后执行以下命令即可在本地打开博客：\",\"npm run docs:dev\",\"执行过程中出现 vuepress-theme-hope: ✖ @vuepress/plugin-redirect is not installed! 的报错是正常的，不需要管，也不要下载这个插件，容易出现依赖冲突\",\"根据返回的网址，即可在本地访问你的blog\"]},\"24\":{\"c\":[\"VuePress Theme Hope\"]},\"25\":{\"h\":\"项目部署\",\"t\":[\"本教程指引你如何部署 VuePress 项目。\"]},\"26\":{\"h\":\"推送代码到 Github\",\"t\":[\"首先你需要创建一个 GitHub 的仓库，仓库地址是一个普通的形如 https://github.com/<USERNAME>/<REPO> 的格式。\",\"初始化 Git 仓库\",\"git init\",\"连接到远程仓库\",\"git remote add origin https://github.com/<USERNAME>/<REPO>\",\"将当前目录下的所有更改（包括新增、修改或删除的文件）添加到暂存区，准备进行下一次提交\",\"git add .\",\"如果出现有关`CRLF`、`LF`之类换行符的报错，执行以下命令之一：\",\"git config --global core.autocrlf true\",\"git add --renormalize .\",\"将当前暂存区中的更改提交到本地 Git 仓库\",\"git commit -m \\\"提交信息\\\"\",\"将本地 Git 仓库中的更改推送到远程仓库\",\"git push origin 分支\",\"分支具体查看`.github\\\\workflows\\\\deploy-docs.yml`文件\",\"静态部署\",\"npm run docs:build\"]},\"27\":{\"h\":\"使用 Github Pages 发布站点\",\"t\":[\"上一步完成推送后，应该会自动生成 gh-pages 分支，前往 GitHub 仓库的Pages，选择 gh-pages 作为 GitHub Pages 的源。\",\" 你的网站将会被发布到 https://<USERNAME>.github.io/<REPO>/ 。\"]},\"28\":{\"c\":[\"VuePress\",\"GitHub\"]},\"29\":{\"h\":\"运行环境搭建\",\"t\":[\"本教程将指导你如何搭建 VuePress 的运行环境。\"]},\"30\":{\"h\":\"Node.js\",\"t\":[\"介绍\",\"Node.js® 是一个基于 Chrome's V8 JavaScript engine的 JavaScript 运行时环境。\",\"你需要下载并安装最新的长期维护版。\"]},\"31\":{\"h\":\"。\"},\"32\":{\"h\":\"2. 运行安装包，保持所有的默认设置，一路下一步即可。\",\"t\":[\"自定义安装路径\",\"不建议安装在C盘，自定义一下安装路径\"]},\"33\":{\"h\":\"3. 然后再在安装路径的根目录下新建两个文件夹， 和 ,如图所示：\"},\"34\":{\"h\":\"4. 环境配置\",\"t\":[\"建好以后开始配置环境：高级系统设置——环境变量\",\"新建一个NODE_HOME，变量值为安装路径\",\"然后再在系统变量的path中添加\",\"%NODE_HOME%\",\"%NODE_HOME%\\\\node_global\",\"%NODE_HOME%\\\\node_cache\",\"然后将用户变量默认的 C:\\\\User\\\\35025\\\\AppDate\\\\Roaming\\\\npm 改成 前面新建文件夹node_global的路径，例如我的是D:\\\\Environment\\\\nodejs\\\\node_globle\",\"到这一步，环境就已经完全配好了，现在开始查看，键盘Win+R进入cmd 输入以下指令\",\"node -v\",\"npm -v\",\"能够正确显示版本号说明安装成功\"]},\"35\":{\"h\":\"5. 修改缓存目录和全局目录\",\"t\":[\"用管理员模式打开 cmd 窗口执行以下指令\",\"-设置缓存到 node_cache 文件夹：\",\"npm config set cache [dir]\",\"-设置全局模块的安装路径到 node_global 文件夹：\",\"npm config set prefix [dir]\",\"[dir]是你对应文件夹的绝对路径\"]},\"36\":{\"c\":[\"环境配置\",\"Node.js\"]},\"37\":{\"c\":[\"Runtime\"]},\"38\":{\"h\":\"题目创建\",\"t\":[\"此教程将指引你使用Polygon平台创建 算法题目。\"]},\"39\":{\"h\":\"教程章节\",\"t\":[\"Polygon\",\"notion\",\"上传题目数据\"]},\"40\":{\"c\":[\"学习笔记\",\"Polygon\"]},\"41\":{\"h\":\"Notion\",\"t\":[\"Notion 是一个互联工作空间，可以管理 Wikis 百科、文档和项目，支持多种内容类型和视图，还有内置的 Al智能助手。\"]},\"42\":{\"c\":[\"Notion\"]},\"43\":{\"h\":\"Polygon\",\"t\":[\"本页面将简要介绍使用多人协作出题平台 Polygon 出题\"]},\"44\":{\"h\":\"📍简介\",\"t\":[\"网址：Index Page - Polygon\",\"Polygon 是一个支持多人协作的出题平台，功能非常完善。官网描述为「Polygon 的使命是为创建编程竞赛题目提供平台。」\",\"在 Codeforces (CF) 出题必须使用 Polygon。在其它地方出题，尤其是多人合作出题时，使用 Polygon 也是不错的选择。\",\"优点\",\"有版本管理系统，多人合作时不会乱成一团，也不需要互相传文件。\",\"出题系统完善，validator、generator、checker、solutions 环环相扣，输出自动生成。\",\"可以为 solutions 设置标签，错解 AC、正解未 AC 都会警告，方便地逐一卡掉错解。\",\"可以方便地对拍，拍出来的数据可以直接添加到题目数据中。\",\"发现问题可以提 issue，而不会被消息刷屏却一直没有 fix。\",\"为日后出 CF 做准备。\",\"……\"]},\"45\":{\"h\":\"📍题目创建\",\"t\":[\"Polygon 的大部分功能都不需要学，能看懂英文就基本能用了。\",\"进入网址后，先注册登陆，然后点击 New Problem 开始创建一个题目表格，注意此处的 Name 只是项目名，不是最终的题目名。\",\"点击 start 开始编辑题目\"]},\"46\":{\"h\":\"📌️General Info\",\"t\":[\"在这个页面中可以设置题目的时间限制、空间限制、题目类型（是否为交互题）。\"]},\"47\":{\"h\":\"📌️Statement\",\"t\":[\"这个页面是用来写题面和题解的。还可以通过 \\\"Review\\\" 按钮来查看题面、validator 与 checker，一般用于审核。 可以通过最上方的 \\\"In HTML\\\" 链接查看渲染后的题面，通过 \\\"Tutorial in HTML\\\" 查看渲染后的题解。\",\"如果需要在题面中添加图片，需要先在下面的 \\\"Statement Resource Files\\\" 中上传图片，然后在题面中加上 \\\\includegraphics{filename.png}。\",\"注意\",\"题面和题解都需要使用 LaTeX 的语法，不能使用 Markdown。\",\"题面编辑内容不包括样例，样例在 Tests 中生成\",\"题面编辑完后需要 Save\"]},\"48\":{\"h\":\"📌️Files\",\"t\":[\"\\\"Source Files\\\" 是用来存放 除了 solutions 外 的其它代码的，如 validator、checker、generator，如果是 IO 式交互题还有 interactor。\",\"如果这些代码需要 include 其它文件，例如 Tree-Generator，需要放在 \\\"Resource Files\\\" 中。\",\"grader 式交互参见 官方教程。\"]},\"49\":{\"h\":\"📌️Checker\",\"t\":[\"testlib.h 提供了一些内置的 checker，在选择框中有简要介绍，也可以选择后再点 \\\"View source\\\" 查看源码。\",\"注意\",\"后续需要自定义 validator、checker、generator、interactor 文件，均需要包含头文件 testlib.h\",\"自行去 https://github.com/MikeMirzayanov/testlib 将项目 clone 下来\",\"如果需要自己编写 checker，请参考官方 checker 教程。\",\"下面的 \\\"Checker tests\\\" 是通过 \\\"Add test\\\" 添加若干组输出以及对应的期望评测结果，然后点击 \\\"Run tests\\\" 就可以测试 checker 是否正确返回了评测结果。\"]},\"50\":{\"h\":\"📌️Interactor\",\"t\":[\"在 General Info 页面中勾选了 Interactive 才有该选项\",\"仅 IO 式交互题需要，请参考官方 interactor 教程。\"]},\"51\":{\"h\":\"📌️Validator\",\"t\":[\"validator 用来检测数据合法性，编写请参考官方 validator 教程。\",\"下面的 \\\"Validator tests\\\" 类似于 \\\"Checker tests\\\"，需要提供输入和期望是否合法，用来测试 validator。\"]},\"52\":{\"h\":\"📌️Tests\",\"t\":[\"这个页面是用来管理数据的。\",\"运行脚本后即可得到下述的各个数据，其中点击每个测试点的 Example 可以将测试点设置为样例，即展示在题面中。\",\"测试点的 Example 如果勾选了 \\\"Use in statements\\\"，这组数据就会成为样例，自动加在题面里。\",\"可以参考 Polygon 提供的教程 使用 Freemarker 来批量生成脚本。\"]},\"53\":{\"h\":\"📌️Stresses\",\"t\":[\"这个页面是用来对拍的。\",\"点击 \\\"Add Stress\\\" 就可以添加一组对拍，\\\"Script pattern\\\" 是一个生成数据的脚本，其中可以使用 \\\"[10..100]\\\" 之类的来表示在一个范围内随机选择。\",\"然后运行对拍，如果拍出错就会显示 \\\"Crashed\\\"，并且可以一键把这组数据加到 Tests 中。\"]},\"54\":{\"h\":\"📌️Solution Files\",\"t\":[\"这个页面是用来放解这道题的代码的，可以是正解也可以是错解。将错解传上来可以便捷地卡掉它们，也可以提醒自己需要卡掉它们。\"]},\"55\":{\"h\":\"📌️Invocations\",\"t\":[\"这个页面是用来运行 solutions 的。\",\"选择代码和测试点就可以运行了，之后可以在列表里点进去（\\\"View\\\"）查看详细信息。\",\"评测状态 \\\"FL\\\" 表示评测出错了，一般是数据没有过 validate 或者 validator/checker/interactor 之类的 RE 了。\\\"RJ\\\" 有两种情况，一种是出现了 \\\"FL\\\"，另一种是这份代码第一个测试点就没有通过。\",\"如果用时在时限的一半到两倍之间，会用黄色标识出来。\",\"如果数据中存在变量没有达到最小值或最大值，会在最下方提醒。\"]},\"56\":{\"h\":\"📌️Issues\",\"t\":[\"用来提 Issue 的地方。\"]},\"57\":{\"h\":\"📌️Packages\",\"t\":[\"Package 包含了一道题的全部信息。Commit Changes 后，点击 Standard 即可进行打包。打包成功后，基本的题目就算创建完成了。\",\"\\\"Verify\\\" 是测试所有 solution 都符合标签（AC、WA、TLE），并且 checker 通过 checker tests，validator 通过 validator tests。\"]},\"58\":{\"c\":[\"Polygon\"]},\"59\":{\"h\":\"上传题目数据\"},\"60\":{\"c\":[\"OJ\"]},\"61\":{\"h\":\"招聘网站爬虫\",\"t\":[\"此教程将指引你创建一个 招聘网站爬虫 项目。\"]},\"62\":{\"h\":\"教程章节\",\"t\":[\"环境配置\",\"数据爬取\",\"数据处理\",\"数据可视化\"]},\"63\":{\"c\":[\"学习笔记\",\"python\",\"爬虫\"]},\"64\":{\"h\":\"环境配置\",\"t\":[\"本教程将指导你如何配置 招聘网站爬虫 的运行环境。\"]},\"65\":{\"h\":\"⬇️Python 安装\",\"t\":[\"前言\",\"人生苦短，快用Python！\",\"Python作为众多编程语言之一，是学习者比较容易上手的一门语言，有着简单、易学、好用等特点\"]},\"66\":{\"h\":\"。\"},\"67\":{\"h\":\"2. ✅️️运行安装包。\",\"t\":[\"相关信息\",\"python安装非常简单，双击下载好的安装包，进入选择安装方式\",\"第一种：Install Now 立即安装，即采用默认安装方式，不能自行指定安装的路径。\",\"第二种：Customize installation 自定义安装，可以自己选择安装的路径（建议自定义安装）。\",\"选择第二种，自定义安装，把最底下Add python.exe to PATH打上勾，否则需要手动添加环境变量\",\"下一步：默认把所有的勾选上即可\",\"下一步：修改安装路径，建议别安装在C盘。如果没有联网，请不要勾选第六项\",\"下一步：安装完成，点击Close关闭即可\",\"安装完成之后，使用win+R键输入cmd进入DOS界面，输入python验证，如下图所示即安装成功，继续输入exit()退出即可\"]},\"68\":{\"h\":\"⬇️Pycharm 安装\",\"t\":[\"相关信息\",\"PyCharm是一款非常好用的Python IDE，由JetBrains开发而成。\",\"官方下载：Download PyCharm: Python IDE for Professional Developers by JetBrains\",\"我下载的是 专业版本\",\"PyCharm针对每个平台都有Professional和Community两个版本，自己可根据自己的需要进行选择。\",\"Professional：专业版（建议选择专业版），功能强大，属于收费版。\",\"Community：社区版，只支持Python开发，开源、免费，用作学习也够用。\"]},\"69\":{\"h\":\"1. ✅️️安装包下载\",\"t\":[\"由于专业版本需要付费，一下包含破解教程\",\"警告\",\"涉及版权，自行选择\",\"微信公众号搜索软件管家\",\"对话中发送pycharm\"]},\"70\":{\"h\":\"2. ✅️️Pycharm 安装教程\",\"t\":[\"下载的内容为 JetBrains 全家桶，安装教程以IDEA为例子\",\"下面将讲解 Pycharm 的安装教程，破解过程与IDEA一致\",\"首先找到解压包下的安装包\",\"PyCharm的安装通用非常简单，双击进行下一步即可\",\"下一步：修改安装路径，建议别放在C盘。\",\"下一步：可以都勾选上\",\"下一步：直接点击Install安装即可\",\"安装完成：点击I want to manually reboot later稍后重启系统\",\"如何破解，请参照公众号文章教程\"]},\"71\":{\"h\":\"3.✅️️Pycharm 常用快捷键\",\"t\":[\"折叠 Ctrl -: 折叠当前代码 Ctrl +: 展开当前代码S Ctrl Shift -: 折叠所有代码 Ctrl Shift +: 展开所有代码 移动 Shift+Enter: 在行中间执行时，智能跳到下一行。 Ctrl+Alt+Enter: 向上插入一行 注释 Ctrl /: 注释、取消注释行 编辑 Ctrl + D: 未选中时，复制当前行到下一行，选中时复制粘贴选中部分。 删除 Ctrl + Y: 删除当前行 查看 Ctrl + Q: 查看文档 缩进 Shift + Tab: 反向退格 替换 Ctrl + r: 替换\",\"以上就是Python+Pycharm的详细安装过程，及PyCharm的使用！\"]},\"72\":{\"c\":[\"Python\",\"Jupyter notebook\",\"pyecharts\"]},\"73\":{\"c\":[\"爬虫\"]},\"74\":{\"h\":\"数据处理\",\"t\":[\"本教程将指导你如何处理 爬取 招聘网站 后的求职信息 。\"]},\"75\":{\"h\":\"1. ✅️️数据合并\",\"t\":[\"前面我们获取了两个网站的数据，我们现在将两个网站数据进行合并\",\"def merge_and_deduplicate(file1, file2, output_file): # 读取两个 CSV 文件的数据 df1 = pd.read_csv(file1) df2 = pd.read_csv(file2) # 合并两个 DataFrame df_combined = pd.concat([df1, df2]) # 去除重复行，假设根据职位、公司、城市字段去重 df_cleaned = df_combined.drop_duplicates(subset=['职位', '公司', '城市']) # 保存合并且去重后的数据到新的 CSV 文件 df_cleaned.to_csv(output_file, index=False) print(f\\\"数据已去重并保存为 {output_file}\\\")\",\"批量收集网站数据\",\"keywords = ['python', 'java', 'PHP', 'c/c++', 'C#', '.NET', 'Golang', 'Node.js', 'Android', 'iOS', '网络安全', '后端开发', '人工智能', 'web前端', '深度学习', '算法工程师', 'UI设计师'] for keyword in keywords: city = '全国' safe_keyword = keyword.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') safe_city = city.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') zhilian_spider = Zhilian(keyword=keyword, city=city) zhilian_spider.run() # 创建 Boss 对象并生成对应的 CSV 文件 boss_spider = Boss(keyword=keyword, city=city) boss_spider.run() file1 = f'Boss直聘_关键词_{safe_keyword}_城市_{safe_city}.csv' file2 = f'智联招聘_关键词_{safe_keyword}_城市_{safe_city}.csv' output_file = f'{safe_keyword}.csv' merge_and_deduplicate(file1, file2, output_file)\"]},\"76\":{\"h\":\"2. ✅️️数据处理\",\"t\":[\"前言\",\"我们在招聘网站中获取到的数据，有些需要进行处理 例如薪资\",\"日期有 时，日，周，月 单位有 元，千，万，k，w 还有一些为面议\",\"比如还有城市\",\"城市对应的省份，我们在获取城市代码的过程中可以获取到它对应的省（参考智联招聘的city.json文件）\",\"但是该文件的省份为缩写，由于我们在后面的可视化表格需要全称，故我们在此一并处理\",\"def getUnit(text): x = 1 if('时' in text): x = 8*30 elif ('周' in text): x = 4 elif ('日' in text) or ('天' in text): x = 30 if('万' in text) or ('w' in text) or ('W' in text): return 10000 * x if('千' in text) or ('k' in text) or ('K' in text): return 1000 * x return 1 * x def getSalary(salary): parts = str(salary).split('-') if len(parts) ==2: part1, part2 = parts ##正则表达式获取数字（包含小数） number1 = re.match(r\\\"(\\\\d+(\\\\.\\\\d+)?)\\\", part1) number2 = re.match(r\\\"(\\\\d+(\\\\.\\\\d+)?)\\\", part2) number1 = number1.group(1) number2 = number2.group(1) text1 = part1[len(number1):] text2 = part2[len(number2):] #获取单位 p1 = getUnit(text1) p2 = getUnit(text2) if not text1 : p1 = p2 return [int(float(number1) * p1), int(float(number2) * p2)] else: return False #获取城市对应省份全称 def getProvince(province): for pro in ['内蒙古自治区', '新疆维吾尔自治区', '西藏自治区', '广西壮族自治区', '宁夏回族自治区', '香港特别行政区', '澳门特别行政区', '北京市','天津市', '重庆市', '上海市']: if province in pro: return pro return province + '省' city_dict = {'北京': '北京', '上海': '上海', '天津': '天津', '重庆': '重庆', '哈尔滨': '黑龙江', '齐齐哈尔': '黑龙江', '牡丹江': '黑龙江', '佳木斯': '黑龙江', '绥化': '黑龙江', '黑河': '黑龙江', '伊春': '黑龙江', '大庆': '黑龙江', '七台河': '黑龙江', '鸡西': '黑龙江', '鹤岗': '黑龙江', '双鸭山': '黑龙江', '大兴安岭地区': '黑龙江', '长春': '吉林', '吉林': '吉林', '四平': '吉林', '通化': '吉林', '白城': '吉林', '辽源': '吉林', '松原': '吉林', '白山': '吉林', '延边朝鲜族自治州': '吉林', '沈阳': '辽宁', '大连': '辽宁', '鞍山': '辽宁', '抚顺': '辽宁', '本溪': '辽宁', '丹东': '辽宁', '锦州': '辽宁', '营口': '辽宁', '阜新': '辽宁', '辽阳': '辽宁', '铁岭': '辽宁', '朝阳': '辽宁', '盘锦': '辽宁', '葫芦岛': '辽宁', '呼和浩特': '内蒙古', '包头': '内蒙古', '乌海': '内蒙古', '通辽': '内蒙古', '赤峰': '内蒙古', '鄂尔多斯': '内蒙古', '呼伦贝尔': '内蒙古', '巴彦淖尔': '内蒙古', '乌兰察布': '内蒙古', '锡林郭勒盟': '内蒙古', '兴安盟': '内蒙古', '阿拉善盟': '内蒙古', '石家庄': '河北', '保定': '河北', '张家口': '河北', '承德': '河北', '唐山': '河北', '廊坊': '河北', '沧州': '河北', '衡水': '河北', '邢台': '河北', '邯郸': '河北', '秦皇岛': '河北', '太原': '山西', '大同': '山西', '阳泉': '山西', '晋中': '山西', '长治': '山西', '晋城': '山西', '临汾': '山西', '运城': '山西', '朔州': '山西', '忻州': '山西', '吕梁': '山西', '西安': '陕西', '咸阳': '陕西', '延安': '陕西', '榆林': '陕西', '渭南': '陕西', '商洛': '陕西', '安康': '陕西', '汉中': '陕西', '宝鸡': '陕西', '铜川': '陕西', '济南': '山东', '青岛': '山东', '淄博': '山东', '德州': '山东', '烟台': '山东', '潍坊': '山东', '济宁': '山东', '泰安': '山东', '临沂': '山东', '菏泽': '山东', '滨州': '山东', '东营': '山东', '威海': '山东', '枣庄': '山东', '日照': '山东', '聊城': '山东', '乌鲁木齐': '新疆', '克拉玛依': '新疆', '昌吉回族自治州': '新疆', '巴音郭楞蒙古自治州': '新疆', '博尔塔拉蒙古自治州': '新疆', '伊犁哈萨克自治州': '新疆', '吐鲁番': '新疆', '哈密': '新疆', '阿克苏地区': '新疆', '克孜勒苏柯尔克孜自治州': '新疆', '喀什地区': '新疆', '和田地区': '新疆', '塔城地区': '新疆', '阿勒泰地区': '新疆', '石河子': '新疆', '阿拉尔': '新疆', '图木舒克': '新疆', '五家渠': '新疆', '铁门关': '新疆', '北屯市': '新疆', '可克达拉市': '新疆', '昆玉市': '新疆', '双河市': '新疆', '新星市': '新疆', '胡杨河市': '新疆', '白杨市': '新疆', '拉萨': '西藏', '日喀则': '西藏', '昌都': '西藏', '林芝': '西藏', '山南': '西藏', '那曲': '西藏', '阿里地区': '西藏', '西宁': '青海', '海东': '青海', '海北藏族自治州': '青海', '黄南藏族自治州': '青海', '海南藏族自治州': '青海', '果洛藏族自治州': '青海', '玉树藏族自治州': '青海', '海西蒙古族藏族自治州': '青海', '兰州': '甘肃', '定西': '甘肃', '平凉': '甘肃', '庆阳': '甘肃', '武威': '甘肃', '金昌': '甘肃', '张掖': '甘肃', '酒泉': '甘肃', '天水': '甘肃', '白银': '甘肃', '陇南': '甘肃', '嘉峪关': '甘肃', '临夏回族自治州': '甘肃', '甘南藏族自治州': '甘肃', '银川': '宁夏', '石嘴山': '宁夏', '吴忠': '宁夏', '固原': '宁夏', '中卫': '宁夏', '郑州': '河南', '安阳': '河南', '新乡': '河南', '许昌': '河南', '平顶山': '河南', '信阳': '河南', '南阳': '河南', '开封': '河南', '洛阳': '河南', '商丘': '河南', '焦作': '河南', '鹤壁': '河南', '濮阳': '河南', '周口': '河南', '漯河': '河南', '驻马店': '河南', '三门峡': '河南', '济源': '河南', '南京': '江苏', '无锡': '江苏', '镇江': '江苏', '苏州': '江苏', '南通': '江苏', '扬州': '江苏', '盐城': '江苏', '徐州': '江苏', '淮安': '江苏', '连云港': '江苏', '常州': '江苏', '泰州': '江苏', '宿迁': '江苏', '武汉': '湖北', '襄阳': '湖北', '鄂州': '湖北', '孝感': '湖北', '黄冈': '湖北', '黄石': '湖北', '咸宁': '湖北', '荆州': '湖北', '宜昌': '湖北', '十堰': '湖北', '随州': '湖北', '荆门': '湖北', '恩施土家族苗族自治州': '湖北', '仙桃': '湖北', '潜江': '湖北', '天门': '湖北', '神农架': '湖北', '杭州': '浙江', '湖州': '浙江', '嘉兴': '浙江', '宁波': '浙江', '绍兴': '浙江', '台州': '浙江', '温州': '浙江', '丽水': '浙江', '金华': '浙江', '衢州': '浙江', '舟山': '浙江', '合肥': '安徽', '蚌埠': '安徽', '芜湖': '安徽', '淮南': '安徽', '马鞍山': '安徽', '安庆': '安徽', '宿州': '安徽', '阜阳': '安徽', '亳州': '安徽', '滁州': '安徽', '淮北': '安徽', '铜陵': '安徽', '宣城': '安徽', '六安': '安徽', '池州': '安徽', '黄山': '安徽', '福州': '福建', '厦门': '福建', '宁德': '福建', '莆田': '福建', '泉州': '福建', '漳州': '福建', '龙岩': '福建', '三明': '福建', '南平': '福建', '南昌': '江西', '九江': '江西', '上饶': '江西', '抚州': '江西', '宜春': '江西', '吉安': '江西', '赣州': '江西', '景德镇': '江西', '萍乡': '江西', '新余': '江西', '鹰潭': '江西', '长沙': '湖南', '湘潭': '湖南', '株洲': '湖南', '衡阳': '湖南', '郴州': '湖南', '常德': '湖南', '益阳': '湖南', '娄底': '湖南', '邵阳': '湖南', '岳阳': '湖南', '张家界': '湖南', '怀化': '湖南', '永州': '湖南', '湘西土家族苗族自治州': '湖南', '贵阳': '贵州', '遵义': '贵州', '安顺': '贵州', '铜仁': '贵州', '毕节': '贵州', '六盘水': '贵州', '黔东南苗族侗族自治州': '贵州', '黔南布依族苗族自治州': '贵州', '黔西南布依族苗族自治州': '贵州', '成都': '四川', '攀枝花': '四川', '自贡': '四川', '绵阳': '四川', '南充': '四川', '达州': '四川', '遂宁': '四川', '广安': '四川', '巴中': '四川', '泸州': '四川', '宜宾': '四川', '内江': '四川', '资阳': '四川', '乐山': '四川', '眉山': '四川', '雅安': '四川', '德阳': '四川', '广元': '四川', '阿坝藏族羌族自治州': '四川', '凉山彝族自治州': '四川', '甘孜藏族自治州': '四川', '广州': '广东', '韶关': '广东', '惠州': '广东', '梅州': '广东', '汕头': '广东', '深圳': '广东', '珠海': '广东', '佛山': '广东', '肇庆': '广东', '湛江': '广东', '江门': '广东', '河源': '广东', '清远': '广东', '云浮': '广东', '潮州': '广东', '东莞': '广东', '中山': '广东', '阳江': '广东', '揭阳': '广东', '茂名': '广东', '汕尾': '广东', '东沙群岛': '广东', '昆明': '云南', '曲靖': '云南', '保山': '云南', '玉溪': '云南', '普洱': '云南', '昭通': '云南', '临沧': '云南', '丽江': '云南', '西双版纳傣族自治州': '云南', '文山壮族苗族自治州': '云南', '红河哈尼族彝族自治州': '云南', '德宏傣族景颇族自治州': '云南', '怒江傈僳族自治州': '云南', '迪庆藏族自治州': '云南', '大理白族自治州': '云南', '楚雄彝族自治州': '云南', '南宁': '广西', '崇左': '广西', '柳州': '广西', '来宾': '广西', '桂林': '广西', '梧州': '广西', '贺州': '广西', '贵港': '广西', '玉林': '广西', '百色': '广西', '钦州': '广西', '河池': '广西', '北海': '广西', '防城港': '广西', '海口': '海南', '三亚': '海南', '三沙': '海南', '儋州': '海南', '五指山': '海南', '琼海': '海南', '文昌': '海南', '万宁': '海南', '东方': '海南', '定安': '海南', '屯昌': '海南', '澄迈': '海南', '临高': '海南', '白沙黎族自治县': '海南', '昌江黎族自治县': '海南', '乐东黎族自治县': '海南', '陵水黎族自治县': '海南', '保亭黎族苗族自治县': '海南', '琼中黎族苗族自治县': '海南', '香港': '香港', '澳门': '澳门', '台湾': '台湾'}\"]},\"77\":{\"h\":\"📌完整代码\",\"t\":[\"from DrissionPage import SessionPage, ChromiumPage import re import csv import pandas as pd def getUnit(text): x = 1 if('时' in text): x = 8*30 elif ('周' in text): x = 4 elif ('日' in text) or ('天' in text): x = 30 if('万' in text) or ('w' in text) or ('W' in text): return 10000 * x if('千' in text) or ('k' in text) or ('K' in text): return 1000 * x return 1 * x def getSalary(salary): parts = str(salary).split('-') if len(parts) ==2: part1, part2 = parts number1 = re.match(r\\\"(\\\\d+(\\\\.\\\\d+)?)\\\", part1) number2 = re.match(r\\\"(\\\\d+(\\\\.\\\\d+)?)\\\", part2) number1 = number1.group(1) number2 = number2.group(1) text1 = part1[len(number1):] text2 = part2[len(number2):] p1 = getUnit(text1) p2 = getUnit(text2) if not text1 : p1 = p2 return [int(float(number1) * p1), int(float(number2) * p2)] else: return False def getProvince(province): for pro in ['内蒙古自治区', '新疆维吾尔自治区', '西藏自治区', '广西壮族自治区', '宁夏回族自治区', '香港特别行政区', '澳门特别行政区', '北京市','天津市', '重庆市', '上海市']: if province in pro: return pro return province + '省' city_dict = {'北京': '北京', '上海': '上海', '天津': '天津', '重庆': '重庆', '哈尔滨': '黑龙江', '齐齐哈尔': '黑龙江', '牡丹江': '黑龙江', '佳木斯': '黑龙江', '绥化': '黑龙江', '黑河': '黑龙江', '伊春': '黑龙江', '大庆': '黑龙江', '七台河': '黑龙江', '鸡西': '黑龙江', '鹤岗': '黑龙江', '双鸭山': '黑龙江', '大兴安岭地区': '黑龙江', '长春': '吉林', '吉林': '吉林', '四平': '吉林', '通化': '吉林', '白城': '吉林', '辽源': '吉林', '松原': '吉林', '白山': '吉林', '延边朝鲜族自治州': '吉林', '沈阳': '辽宁', '大连': '辽宁', '鞍山': '辽宁', '抚顺': '辽宁', '本溪': '辽宁', '丹东': '辽宁', '锦州': '辽宁', '营口': '辽宁', '阜新': '辽宁', '辽阳': '辽宁', '铁岭': '辽宁', '朝阳': '辽宁', '盘锦': '辽宁', '葫芦岛': '辽宁', '呼和浩特': '内蒙古', '包头': '内蒙古', '乌海': '内蒙古', '通辽': '内蒙古', '赤峰': '内蒙古', '鄂尔多斯': '内蒙古', '呼伦贝尔': '内蒙古', '巴彦淖尔': '内蒙古', '乌兰察布': '内蒙古', '锡林郭勒盟': '内蒙古', '兴安盟': '内蒙古', '阿拉善盟': '内蒙古', '石家庄': '河北', '保定': '河北', '张家口': '河北', '承德': '河北', '唐山': '河北', '廊坊': '河北', '沧州': '河北', '衡水': '河北', '邢台': '河北', '邯郸': '河北', '秦皇岛': '河北', '太原': '山西', '大同': '山西', '阳泉': '山西', '晋中': '山西', '长治': '山西', '晋城': '山西', '临汾': '山西', '运城': '山西', '朔州': '山西', '忻州': '山西', '吕梁': '山西', '西安': '陕西', '咸阳': '陕西', '延安': '陕西', '榆林': '陕西', '渭南': '陕西', '商洛': '陕西', '安康': '陕西', '汉中': '陕西', '宝鸡': '陕西', '铜川': '陕西', '济南': '山东', '青岛': '山东', '淄博': '山东', '德州': '山东', '烟台': '山东', '潍坊': '山东', '济宁': '山东', '泰安': '山东', '临沂': '山东', '菏泽': '山东', '滨州': '山东', '东营': '山东', '威海': '山东', '枣庄': '山东', '日照': '山东', '聊城': '山东', '乌鲁木齐': '新疆', '克拉玛依': '新疆', '昌吉回族自治州': '新疆', '巴音郭楞蒙古自治州': '新疆', '博尔塔拉蒙古自治州': '新疆', '伊犁哈萨克自治州': '新疆', '吐鲁番': '新疆', '哈密': '新疆', '阿克苏地区': '新疆', '克孜勒苏柯尔克孜自治州': '新疆', '喀什地区': '新疆', '和田地区': '新疆', '塔城地区': '新疆', '阿勒泰地区': '新疆', '石河子': '新疆', '阿拉尔': '新疆', '图木舒克': '新疆', '五家渠': '新疆', '铁门关': '新疆', '北屯市': '新疆', '可克达拉市': '新疆', '昆玉市': '新疆', '双河市': '新疆', '新星市': '新疆', '胡杨河市': '新疆', '白杨市': '新疆', '拉萨': '西藏', '日喀则': '西藏', '昌都': '西藏', '林芝': '西藏', '山南': '西藏', '那曲': '西藏', '阿里地区': '西藏', '西宁': '青海', '海东': '青海', '海北藏族自治州': '青海', '黄南藏族自治州': '青海', '海南藏族自治州': '青海', '果洛藏族自治州': '青海', '玉树藏族自治州': '青海', '海西蒙古族藏族自治州': '青海', '兰州': '甘肃', '定西': '甘肃', '平凉': '甘肃', '庆阳': '甘肃', '武威': '甘肃', '金昌': '甘肃', '张掖': '甘肃', '酒泉': '甘肃', '天水': '甘肃', '白银': '甘肃', '陇南': '甘肃', '嘉峪关': '甘肃', '临夏回族自治州': '甘肃', '甘南藏族自治州': '甘肃', '银川': '宁夏', '石嘴山': '宁夏', '吴忠': '宁夏', '固原': '宁夏', '中卫': '宁夏', '郑州': '河南', '安阳': '河南', '新乡': '河南', '许昌': '河南', '平顶山': '河南', '信阳': '河南', '南阳': '河南', '开封': '河南', '洛阳': '河南', '商丘': '河南', '焦作': '河南', '鹤壁': '河南', '濮阳': '河南', '周口': '河南', '漯河': '河南', '驻马店': '河南', '三门峡': '河南', '济源': '河南', '南京': '江苏', '无锡': '江苏', '镇江': '江苏', '苏州': '江苏', '南通': '江苏', '扬州': '江苏', '盐城': '江苏', '徐州': '江苏', '淮安': '江苏', '连云港': '江苏', '常州': '江苏', '泰州': '江苏', '宿迁': '江苏', '武汉': '湖北', '襄阳': '湖北', '鄂州': '湖北', '孝感': '湖北', '黄冈': '湖北', '黄石': '湖北', '咸宁': '湖北', '荆州': '湖北', '宜昌': '湖北', '十堰': '湖北', '随州': '湖北', '荆门': '湖北', '恩施土家族苗族自治州': '湖北', '仙桃': '湖北', '潜江': '湖北', '天门': '湖北', '神农架': '湖北', '杭州': '浙江', '湖州': '浙江', '嘉兴': '浙江', '宁波': '浙江', '绍兴': '浙江', '台州': '浙江', '温州': '浙江', '丽水': '浙江', '金华': '浙江', '衢州': '浙江', '舟山': '浙江', '合肥': '安徽', '蚌埠': '安徽', '芜湖': '安徽', '淮南': '安徽', '马鞍山': '安徽', '安庆': '安徽', '宿州': '安徽', '阜阳': '安徽', '亳州': '安徽', '滁州': '安徽', '淮北': '安徽', '铜陵': '安徽', '宣城': '安徽', '六安': '安徽', '池州': '安徽', '黄山': '安徽', '福州': '福建', '厦门': '福建', '宁德': '福建', '莆田': '福建', '泉州': '福建', '漳州': '福建', '龙岩': '福建', '三明': '福建', '南平': '福建', '南昌': '江西', '九江': '江西', '上饶': '江西', '抚州': '江西', '宜春': '江西', '吉安': '江西', '赣州': '江西', '景德镇': '江西', '萍乡': '江西', '新余': '江西', '鹰潭': '江西', '长沙': '湖南', '湘潭': '湖南', '株洲': '湖南', '衡阳': '湖南', '郴州': '湖南', '常德': '湖南', '益阳': '湖南', '娄底': '湖南', '邵阳': '湖南', '岳阳': '湖南', '张家界': '湖南', '怀化': '湖南', '永州': '湖南', '湘西土家族苗族自治州': '湖南', '贵阳': '贵州', '遵义': '贵州', '安顺': '贵州', '铜仁': '贵州', '毕节': '贵州', '六盘水': '贵州', '黔东南苗族侗族自治州': '贵州', '黔南布依族苗族自治州': '贵州', '黔西南布依族苗族自治州': '贵州', '成都': '四川', '攀枝花': '四川', '自贡': '四川', '绵阳': '四川', '南充': '四川', '达州': '四川', '遂宁': '四川', '广安': '四川', '巴中': '四川', '泸州': '四川', '宜宾': '四川', '内江': '四川', '资阳': '四川', '乐山': '四川', '眉山': '四川', '雅安': '四川', '德阳': '四川', '广元': '四川', '阿坝藏族羌族自治州': '四川', '凉山彝族自治州': '四川', '甘孜藏族自治州': '四川', '广州': '广东', '韶关': '广东', '惠州': '广东', '梅州': '广东', '汕头': '广东', '深圳': '广东', '珠海': '广东', '佛山': '广东', '肇庆': '广东', '湛江': '广东', '江门': '广东', '河源': '广东', '清远': '广东', '云浮': '广东', '潮州': '广东', '东莞': '广东', '中山': '广东', '阳江': '广东', '揭阳': '广东', '茂名': '广东', '汕尾': '广东', '东沙群岛': '广东', '昆明': '云南', '曲靖': '云南', '保山': '云南', '玉溪': '云南', '普洱': '云南', '昭通': '云南', '临沧': '云南', '丽江': '云南', '西双版纳傣族自治州': '云南', '文山壮族苗族自治州': '云南', '红河哈尼族彝族自治州': '云南', '德宏傣族景颇族自治州': '云南', '怒江傈僳族自治州': '云南', '迪庆藏族自治州': '云南', '大理白族自治州': '云南', '楚雄彝族自治州': '云南', '南宁': '广西', '崇左': '广西', '柳州': '广西', '来宾': '广西', '桂林': '广西', '梧州': '广西', '贺州': '广西', '贵港': '广西', '玉林': '广西', '百色': '广西', '钦州': '广西', '河池': '广西', '北海': '广西', '防城港': '广西', '海口': '海南', '三亚': '海南', '三沙': '海南', '儋州': '海南', '五指山': '海南', '琼海': '海南', '文昌': '海南', '万宁': '海南', '东方': '海南', '定安': '海南', '屯昌': '海南', '澄迈': '海南', '临高': '海南', '白沙黎族自治县': '海南', '昌江黎族自治县': '海南', '乐东黎族自治县': '海南', '陵水黎族自治县': '海南', '保亭黎族苗族自治县': '海南', '琼中黎族苗族自治县': '海南', '香港': '香港', '澳门': '澳门', '台湾': '台湾'} output_file = f'data.csv' f = open(output_file, mode='w', encoding='utf-8', newline='') csv_writer = csv.DictWriter(f, fieldnames=['keyword', 'name', 'averSalary', 'number']) csv_writer.writeheader() keywords = ['python', 'java', 'PHP', 'c/c++', 'C#', '.NET', 'Golang', 'Node.js', 'Android', 'iOS', '网络安全', '后端开发', '人工智能', 'web前端', '深度学习', '算法工程师', 'UI设计师'] for keyword in keywords: safe_keyword = keyword.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') file = f'{safe_keyword}.csv' df = pd.read_csv(file) city_info = {} for index, row in df.iterrows(): salary = getSalary(row['薪资']) if salary == False: # print(row) continue if row['城市'] in city_dict: city = city_dict[row['城市']] else: # print(row) continue if (city in city_info): city_info[city]['minSalary'] += salary[0] city_info[city]['maxSalary'] += salary[1] city_info[city]['number'] += 1 else: info = { 'minSalary': salary[0], 'maxSalary': salary[1], 'number': 1, 'city': city, } city_info[city] = info aversal=0 number=0 for city in city_info: aversal += int((city_info[city]['minSalary']+city_info[city]['maxSalary'])/(2*city_info[city]['number'])) number += 1 data = { 'keyword': keyword, 'name': getProvince(city), 'averSalary': int((city_info[city]['minSalary']+city_info[city]['maxSalary'])/(2*city_info[city]['number'])), 'number': city_info[city]['number'], } csv_writer.writerow(data) #计算工作的平均工资（后面制作表格需要） print(int(aversal/number),end=', ')\",\"生成的数据如下\",\"12373, 10794, 9616, 15584, 11876, 11348, 14679, 12854, 14158, 15898, 10988, 12989, 15096, 10200, 17128, 18482, 8751\",\"处理完成后的数据如下\"]},\"78\":{\"c\":[\"Python\",\"pandas\",\"re\",\"csv\"]},\"79\":{\"h\":\"数据采集\",\"t\":[\"本教程将指导你如何爬取 招聘网站 中的求职信息 。\"]},\"80\":{\"h\":\"1. Boss直聘\"},\"81\":{\"h\":\"✅️URL获取\",\"t\":[\"打开官网Boss直聘\",\"我们随便搜索一个求职信息如 python\",\"网址中 可以发现有两个参数 qurey=python 和city=100010000\",\"我们再搜索一个求职信息如 java\",\"发现参数qurey=java和city=100010000\",\"通过对比两个网址 qurey代表求职信息即我们搜索框中输入的内容 city可以知道是职业的地区参数， 100010000对应的是全国参数\",\"现在的问题就是每个城市对应的参数是什么\",\"返回到主页，按F12打开开发者工具，选择网络一栏\",\"刷新一下网页（若网络一栏无文件，则需要刷新网页），搜索框中搜索city\",\"找到city.json（就是城市的参数文件）\",\"访问网址 !! city.json !!\",\"每个城市对应的参数都在该网址\"]},\"82\":{\"h\":\"✅️招聘信息获取\",\"t\":[\"刚刚我们获取完url的两个参数信息\",\"以qurey=python city=100010000 举例 所以对应的url = https://www.zhipin.com/web/geek/job?query=python&city=100010000\",\"我们访问网址，打开开发者工具，选择网络一栏\",\"选择 标头 一栏 ，找到请求标头的:path一栏 复制search/joblist.json 后面编写代码需要\",\"以上，我们就完成了编写代码的准备环节\"]},\"83\":{\"h\":\"✅️代码编写\",\"t\":[\"用到的包DrissionPage\",\"使用文档\"]},\"84\":{\"h\":\"📌️URL获取模块\",\"t\":[\" def _get_city_code(self): \\\"\\\"\\\"获取城市编码\\\"\\\"\\\" #生成页面对象 page = SessionPage() #访问在线网页 page.get('https://www.zhipin.com/wapi/zpCommon/data/city.json')#刚刚获取到的city.json网址 json_data = page.json['zpData']['cityList'] for dit in json_data: for city_json in dit['subLevelModelList']: if city_json['name'] == self.city: return str(city_json['code']) return '100010000' # 默认值为全国 def _get_url(self): \\\"\\\"\\\"根据关键词和城市编码生成正确的URL\\\"\\\"\\\" #正则表达式进行替换 self.url = re.sub(r'(?<=query=)[^&]+', self.keyword, self.url) self.url = re.sub(r'(?<=city=)[^&]+', self._get_city_code(), self.url) print(self.url) return self.url\",\"提示\",\"page.json返回的是一个字典类型\",\"'zpData'访问的是\",\"'cityList'访问的是\",\"这里的dit['subLevelModelList']代表\"]},\"85\":{\"h\":\"📌数据抓取\",\"t\":[\"def run(self): \\\"\\\"\\\"爬取数据并写入CSV\\\"\\\"\\\" page = None try: #ChromiumPage区别于SessionPage，它是一个可交互性的网页 page = ChromiumPage() page.listen.start('search/joblist.json')#此处是我们要在网络中获取的数据文件 page.get(self._get_url()) for page_num in range(1000): # 翻页处理 page.scroll.to_bottom() # 滚动到页面底部，加载新内容 response = page.listen.wait() # 等待监听到的请求响应 json_data = response.response.body jobList = json_data['zpData']['jobList'] for job in jobList: data = { '职位': job['jobName'], '城市': job['cityName'], '公司': job['brandName'], '薪资': job['salaryDesc'], '经验': job['jobExperience'], '学历': job['jobDegree'], '领域': job['brandIndustry'], '技能': ', '.join(job['skills']), '福利': ', '.join(job['welfareList']), } self.csv_writer.writerow(data) # 翻页操作 next_page_btn = page.ele('css:.options-pages a:last-of-type') if 'disable' in next_page_btn.attr('class'): break else: next_page_btn.click() # 点击下一页按钮 except Exception as e: print(f\\\"发生错误: {e}\\\") finally: if page: page.quit() # 关闭浏览器实例\",\"提示\",\"关于翻页操作的参数\",\"可以看到下一页的按钮标签名称为 ui-icon-arrow-right\",\"但是同上操作在最后一页下一页的按钮为 disabled\",\"为此做一个区分，下一页的标签在 class = \\\"options-pages\\\" 的最后一个，所以我们使用'css:.options-pages a:last-of-type'来获取最后一个元素，来判断是否进行下一页\"]},\"86\":{\"h\":\"✅️源代码如下\",\"t\":[\"from DrissionPage import SessionPage, ChromiumPage import re import csv class Boss(object): def __init__(self, keyword, city): self.keyword = keyword self.city = city self.url = 'https://www.zhipin.com/web/geek/job?query=python&city=101200100' # 替换掉文件名中的非法字符 safe_keyword = self.keyword.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') safe_city = self.city.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') # 生成文件名 file_name = f'Boss直聘_关键词_{safe_keyword}_城市_{safe_city}.csv' try: self.f = open(file_name, mode='w', encoding='utf-8', newline='') self.csv_writer = csv.DictWriter(self.f, fieldnames=[ '职位', '城市', '公司', '薪资', '经验', '学历', '领域', '技能', '福利', ]) self.csv_writer.writeheader() except Exception as e: print(f\\\"打开文件时发生错误: {e}\\\") self.f = None # 确保如果文件打开失败，self.f 不会被引用 def __del__(self): \\\"\\\"\\\"确保在对象销毁时关闭CSV文件\\\"\\\"\\\" if hasattr(self, 'f') and self.f: # 检查是否存在 f 属性 self.f.close() def _get_city_code(self): \\\"\\\"\\\"获取城市编码\\\"\\\"\\\" page = SessionPage() page.get('https://www.zhipin.com/wapi/zpCommon/data/city.json') json_data = page.json['zpData']['cityList'] for dit in json_data: for city_json in dit['subLevelModelList']: if city_json['name'] == self.city: return str(city_json['code']) return '100010000' # 默认值为全国 def _get_url(self): \\\"\\\"\\\"根据关键词和城市编码生成正确的URL\\\"\\\"\\\" self.url = re.sub(r'(?<=query=)[^&]+', self.keyword, self.url) self.url = re.sub(r'(?<=city=)[^&]+', self._get_city_code(), self.url) print(self.url) return self.url def run(self): \\\"\\\"\\\"爬取数据并写入CSV\\\"\\\"\\\" page = None try: page = ChromiumPage() page.listen.start('search/joblist.json') page.get(self._get_url()) for page_num in range(1000): # 翻页处理 page.scroll.to_bottom() # 滚动到页面底部，加载新内容 response = page.listen.wait() # 等待监听到的请求响应 json_data = response.response.body jobList = json_data['zpData']['jobList'] for job in jobList: data = { '职位': job['jobName'], '城市': job['cityName'], '公司': job['brandName'], '薪资': job['salaryDesc'], '经验': job['jobExperience'], '学历': job['jobDegree'], '领域': job['brandIndustry'], '技能': ', '.join(job['skills']), '福利': ', '.join(job['welfareList']), } self.csv_writer.writerow(data) # 翻页操作 next_page_btn = page.ele('css:.options-pages a:last-of-type') if 'disable' in next_page_btn.attr('class'): break else: next_page_btn.click() # 点击下一页按钮 except Exception as e: print(f\\\"发生错误: {e}\\\") finally: if page: page.quit() # 关闭浏览器实例 if __name__ == '__main__': city = input('请输入城市名：') keyword = input('请输入搜索关键词：') # 确保用户输入不为空 if keyword: boss_spider = Boss(keyword=keyword, city=city) boss_spider.run() else: print(\\\"关键词和城市名不能为空！\\\")\"]},\"87\":{\"h\":\"2. 智联招聘\"},\"88\":{\"h\":\"✅️URL获取\",\"t\":[\"打开官网智联招聘\",\"同理\",\"基础URL https://www.zhaopin.com/sou/?jl=489&kw=python&p=2\",\"参数有3个，jl=城市，kw=招聘岗位，p=页面\",\"城市参数网址\",\"每个城市对应的参数都在该网址\"]},\"89\":{\"h\":\"✅️招聘信息获取\",\"t\":[\"有别于Boss直聘\",\"你在搜索公司名称时，发现找不到对应的json文件\",\"但我们翻到第二页的时候\",\"对应的文件找到了\",\"获取到:path: search/positions\"]},\"90\":{\"h\":\"✅️代码编写\",\"t\":[\"用到的包DrissionPage\",\"使用文档\"]},\"91\":{\"h\":\"📌URL获取模块\",\"t\":[\" def _get_city_code(self): \\\"\\\"\\\"获取城市编码\\\"\\\"\\\" page = SessionPage() page.get('https://fe-api.zhaopin.com/c/i/search/base/data') json_data = page.json['data']['allCity'] for dit in json_data: if dit['name'] == self.city: return str(dit['code']) for city_json in dit['sublist']: if city_json['name'] == self.city: return str(city_json['code']) return '489' # 默认值为全国 def _get_url(self): \\\"\\\"\\\"根据关键词和城市编码生成正确的URL\\\"\\\"\\\" self.url = re.sub(r'(?<=jl=)[^&]+', self._get_city_code(), self.url) self.url = re.sub(r'(?<=kw=)[^&]+', self.keyword, self.url) print(self.url) return self.url\"]},\"92\":{\"h\":\"📌数据抓取\",\"t\":[\" def run(self): \\\"\\\"\\\"爬取数据并写入CSV\\\"\\\"\\\" page = None try: page = ChromiumPage() page.listen.start('/search/positions') page.get(self._get_url()) page.scroll.to_bottom() # 滚动到页面底部，加载新内容 page.ele('css:.soupager__btn').click() for page_num in range(1000): # 翻页处理 page.scroll.to_bottom() # 滚动到页面底部，加载新内容 response = page.listen.wait() # 等待监听到的请求响应 json_data = response.response.body jobList = json_data['data']['list'] for job in jobList: data = { '职位': job['name'], '城市': job['workCity'], '公司': job['companyName'], '薪资': job['salary60'], '经验': job['workingExp'], '学历': job['education'], '领域': job['industryName'], '技能': ', '.join(skill['name'] for skill in job['jobSkillTags']), '福利': ', '.join(job['jobKnowledgeWelfareFeatures']), } self.csv_writer.writerow(data) # 翻页操作 next_page_btn = page.ele('css:.soupager a:last-of-type') if 'soupager__btn--disable' in next_page_btn.attr('class'): break else: next_page_btn.click() # 点击下一页按钮 except Exception as e: print(f\\\"发生错误: {e}\\\") finally: if page: page.quit() # 关闭浏览器实例\",\"提示\",\"关于翻页操作的参数\",\"可以看到上一页和下一页的按钮标签名称都为 btn soupager__btn\",\"为此做一个区分，下一页的标签在 class = \\\"soupager\\\" 的最后一个，所以我们使用'css:.soupager a:last-of-type'来获取最后一个元素，来判断是否进行下一页\",\"最后一页的下一页的标签为 'soupager__btn--disable'\"]},\"93\":{\"h\":\"✅️源代码如下\",\"t\":[\"import time from DrissionPage import SessionPage, ChromiumPage import re import csv class Zhilian(object): def __init__(self, keyword, city): self.keyword = keyword self.city = city self.url = 'https://www.zhaopin.com/sou/?jl=489&kw=python&p=2' # 替换掉文件名中的非法字符 safe_keyword = self.keyword.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') safe_city = self.city.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') # 生成文件名 file_name = f'智联招聘_关键词_{safe_keyword}_城市_{safe_city}.csv' try: self.f = open(file_name, mode='w', encoding='utf-8', newline='') self.csv_writer = csv.DictWriter(self.f, fieldnames=[ '职位', '城市', '公司', '薪资', '经验', '学历', '领域', '技能', '福利', ]) self.csv_writer.writeheader() except Exception as e: print(f\\\"打开文件时发生错误: {e}\\\") self.f = None # 确保如果文件打开失败，self.f 不会被引用 def __del__(self): \\\"\\\"\\\"确保在对象销毁时关闭CSV文件\\\"\\\"\\\" if hasattr(self, 'f') and self.f: # 检查是否存在 f 属性 self.f.close() def _get_city_code(self): \\\"\\\"\\\"获取城市编码\\\"\\\"\\\" page = SessionPage() page.get('https://fe-api.zhaopin.com/c/i/search/base/data') json_data = page.json['data']['allCity'] for dit in json_data: if dit['name'] == self.city: return str(dit['code']) for city_json in dit['sublist']: if city_json['name'] == self.city: return str(city_json['code']) return '489' # 默认值为全国 def _get_url(self): \\\"\\\"\\\"根据关键词和城市编码生成正确的URL\\\"\\\"\\\" self.url = re.sub(r'(?<=jl=)[^&]+', self._get_city_code(), self.url) self.url = re.sub(r'(?<=kw=)[^&]+', self.keyword, self.url) print(self.url) return self.url def run(self): \\\"\\\"\\\"爬取数据并写入CSV\\\"\\\"\\\" page = None try: page = ChromiumPage() page.listen.start('/search/positions') page.get(self._get_url()) time.sleep(2) page.scroll.to_bottom() # 滚动到页面底部，加载新内容 page.ele('css:.soupager__btn').click() for page_num in range(1000): # 翻页处理 page.scroll.to_bottom() # 滚动到页面底部，加载新内容 response = page.listen.wait() # 等待监听到的请求响应 json_data = response.response.body jobList = json_data['data']['list'] for job in jobList: data = { '职位': job['name'], '城市': job['workCity'], '公司': job['companyName'], '薪资': job['salary60'], '经验': job['workingExp'], '学历': job['education'], '领域': job['industryName'], '技能': ', '.join(skill['name'] for skill in job['jobSkillTags']), '福利': ', '.join(job['jobKnowledgeWelfareFeatures']), } self.csv_writer.writerow(data) # 翻页操作 next_page_btn = page.ele('css:.soupager a:last-of-type') if 'soupager__btn--disable' in next_page_btn.attr('class'): break else: next_page_btn.click() # 点击下一页按钮 except Exception as e: print(f\\\"发生错误: {e}\\\") finally: if page: page.quit() # 关闭浏览器实例 if __name__ == '__main__': city = input('请输入城市名：') keyword = input('请输入搜索关键词：') # 确保用户输入不为空 if keyword: Zhilian_spider = Zhilian(keyword=keyword, city=city) Zhilian_spider.run() else: print(\\\"关键词和城市名不能为空！\\\")\"]},\"94\":{\"h\":\"3. 前程无忧\",\"t\":[\"打开官网前程无忧\",\"前情提要\",\"由于该网站招聘信息 技能要求和福利 等信息在一块，后期数据处理很麻烦，故在这里只教程如何爬取内容\"]},\"95\":{\"h\":\"✅️URL获取\",\"t\":[\"https://we.51job.com/pc/search?jobArea=020000&keyword=java&searchType=2&keywordType=\",\"四个参数\",\"jobArea 城市参数 keyword 职业关键字 searchType 1 搜公司 2 搜全文 keywordType 作用不大\",\"城市参数 https://js.51jobcdn.com/in/js/2023/dd/dd_city.json\",\"监听参数 job/search-pc\",\"但是\",\"例子\",\"需要手动验证\",\"所以该网站不能像前面俩一样爬取（大家可以尝试编写代码，突破验证）\",\"通过直接爬取网页元素（该方法相较于前面，比较麻烦）\"]},\"96\":{\"h\":\"✅️简单demo编写\",\"t\":[\"根据页面元素可以得到，页面中一个工作的信息包含在 class=joblist_item中 所以我们可以通过ChromiumPage()对象的eles方法获取页面中所有joblist_item\",\"公司信息如图所示\",\"公司标签如图所示\",\"import json from pprint import pprint from DrissionPage import SessionPage, ChromiumPage page = ChromiumPage() page.get('https://we.51job.com/pc/search?jobArea=020000&keyword=java&searchType=2&keywordType=') # 获取所有职位信息所在的div标签 divs = page.eles('css:.joblist-item') for div in divs: # 提取具体的数据内容 info = div.ele('css:.joblist-item-job').attr('sensorsdata') # 把json字符串转为json字典数据 json_data = json.loads(info) # 公司姓名 c_name = div.ele('css:.cname').attr('title') # 公司领域 dc = div.ele('css:.dc').text # 提取标签 tags = ','.join([i.text for i in div.eles('css:.tag')]) # 提取相关数据内容，保存在字典内 dit = { '职位': json_data['jobTitle'], '薪资': json_data['jobSalary'], '城市': json_data['jobArea'], '经验': json_data['jobYear'], '学历': json_data['jobDegree'], '公司': c_name, '领域': dc, '标签': tags, } print(dit)\",\"以上就是 前程无忧 网站信息爬取过程\"]},\"97\":{\"c\":[\"Python\",\"DrissionPage\"]},\"98\":{\"c\":[\"Boss 直聘\",\"智联招聘\",\"前程无忧\"]},\"99\":{\"h\":\"数据可视化\",\"t\":[\"本教程将指导你如何制作可视化图表 。\",\"前言\",\"需要用到的库有 jupyter notebook 、pyecharts\",\"安装jupyter notebook\",\"pip install jupyter notebook\",\"运行jupyter notebook\",\"jupyter notebook\",\"pip install pyecharts\",\"官方文档可参考pyecharts\",\"以及一些表格的例子pyecharts-gallery\"]},\"100\":{\"h\":\"1. 全国招聘工作工资分布可视化表.html\"},\"101\":{\"h\":\"📌数据获取\",\"t\":[\"# 之前数据清洗过之后的文件 file = f'data.csv' df = pd.read_csv(file) data = [] work = {} for index, row in df.iterrows(): keyword = row['keyword'] province = row['name'] averSalary = row['averSalary'] number = row['number'] if keyword not in work: work[keyword] = {'work': keyword, 'data': []} work[keyword]['data'].append({ 'province': province, 'value': [averSalary, number, province] }) data = list(work.values()) work_list = ['python', 'java', 'PHP', 'c/c++', 'C#', '.NET', 'Golang', 'Node.js', 'Android', 'iOS', '网络安全', '后端开发', '人工智能', 'web前端', '深度学习', '算法工程师', 'UI设计师'] # 数据清洗中得出的平均工资 total_num = [12373, 10794, 9616, 15584, 11876, 11348, 14679, 12854, 14158, 15898, 10988, 12989, 15096, 10200, 17128, 18482, 8751] maxNum = 60000 # 定义的最大值 minNum = 5000 # 定义的最小值\",\"生成的 data 如下\"]},\"102\":{\"h\":\"📌map_chart（地图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\"map_data = [ [[x[\\\"province\\\"], x[\\\"value\\\"]] for x in d[\\\"data\\\"]] for d in data if d[\\\"work\\\"] == work ][0] min_data, max_data = (minNum, maxNum) map_chart = ( Map() .add( series_name=\\\"\\\", data_pair=[[x[0], x[1][0]] for x in map_data], # 传入的为二维列表，对应的为省份名称和对应职位的工资 （相当于横纵坐标） zoom=1, # 地图的缩放比 center=[130, 25], is_map_symbol_show=False, tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{b}: {c}\\\"), # 设置鼠标放置旁边时，显示具体数据 ) .set_global_opts( title_opts=opts.TitleOpts( title=\\\"\\\" + str(work) + \\\"全国各省份平均工资 数据来源：boss直聘，智联招聘\\\", # 标题 subtitle=\\\"\\\", pos_left=\\\"center\\\", pos_top=\\\"top\\\", title_textstyle_opts=opts.TextStyleOpts( font_size=25 ), ), tooltip_opts=opts.TooltipOpts( is_show=True, formatter=JsCode( \\\"\\\"\\\"function(params) { if ('value' in params.data) { return params.data.value[2] + ': ' + params.data.value[0]; } }\\\"\\\"\\\" ), ), # 设置热力图 visualmap_opts=opts.VisualMapOpts( is_calculable=True, dimension=0, pos_left=\\\"30\\\", pos_top=\\\"top\\\", range_text=[\\\"High\\\", \\\"Low\\\"], range_color=[\\\"lightskyblue\\\", \\\"yellow\\\", \\\"orangered\\\"],# 定义热力图中的颜色 textstyle_opts=opts.TextStyleOpts(color=\\\"#ddd\\\"), min_=min_data, max_=max_data, # 定义热力图的最大值和最小值 ), ) )\"]},\"103\":{\"h\":\"📌line_chart（折线图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\" line_chart = ( Line() .add_xaxis(work_list) # 横坐标 .add_yaxis( '', total_num, # 纵坐标 markpoint_opts=opts.MarkPointOpts(data=[opts.MarkPointItem(type_=\\\"max\\\")]), # 展示所有数据中最大的一项 tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{c}\\\"), # 设置鼠标放置旁边时，显示具体数据 ) .set_series_opts(label_opts=opts.LabelOpts(is_show=False)) .set_global_opts( title_opts=opts.TitleOpts( title=\\\"全国岗位平均工资（单位：元）\\\", pos_left=\\\"72%\\\", pos_top=\\\"5%\\\" #标题 ) ) )\"]},\"104\":{\"h\":\"📌bar_chart（柱状图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\" bar_x_data = [x[0] for x in map_data] # 横坐标 bar_y_data = [{\\\"work\\\": x[0], \\\"value\\\": x[1][0]} for x in map_data] #纵坐标 bar = ( Bar() .add_xaxis(xaxis_data=bar_x_data) .add_yaxis( series_name=\\\"\\\", y_axis=bar_y_data, label_opts=opts.LabelOpts( is_show=True, position=\\\"right\\\", formatter=\\\"{b} : {c}\\\" # 将具体数据固定在表格的右边 ), ) .reversal_axis() .set_global_opts( title_opts=opts.TitleOpts( title=\\\"\\\" + str(work) + \\\"各省份平均工资（单位：元/月）\\\", pos_left=\\\"0%\\\", pos_top=\\\"45%\\\" # 标题 ), xaxis_opts=opts.AxisOpts( max_=60000, axislabel_opts=opts.LabelOpts(is_show=False) ), yaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(is_show=False)), tooltip_opts=opts.TooltipOpts(is_show=False), ) )\"]},\"105\":{\"h\":\"📌grid_chart（并行多图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\" grid_chart = ( Grid() .add( bar, grid_opts=opts.GridOpts( pos_left=\\\"10\\\", pos_right=\\\"45%\\\", pos_top=\\\"50%\\\", pos_bottom=\\\"5\\\" # 控制表格位置 ), ) .add( line_chart, grid_opts=opts.GridOpts( pos_left=\\\"58%\\\", pos_right=\\\"65\\\", pos_top=\\\"10%\\\", pos_bottom=\\\"50%\\\" # 控制表格位置 ), ) .add(map_chart, grid_opts=opts.GridOpts()) )\"]},\"106\":{\"h\":\"📌timeline （时间线）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\" timeline = Timeline( init_opts=opts.InitOpts(width=\\\"1650px\\\", height=\\\"900px\\\", theme=ThemeType.DARK) ) for y in work_list: # 按照职业将对应图表添加到时间线上 g = get_work_chart(work=y) timeline.add(g, time_point=str(y)) timeline.add_schema( orient=\\\"vertical\\\", # 纵向排列 is_auto_play=True, # 自动播放 is_inverse=True, # 反向播放 play_interval=5000, # 每个图表间隔5秒 pos_left=\\\"null\\\", # 左边距设置为 null（自动） pos_right=\\\"5\\\", # 右边距设置为 5 pos_top=\\\"20\\\", # 上边距设置为 20 pos_bottom=\\\"20\\\", # 下边距设置为 20 width=\\\"60\\\", # 时间轴的宽度 label_opts=opts.LabelOpts(is_show=True, color=\\\"#fff\\\", position=\\\"left\\\"), # 文本位置设置为右侧 ) timeline.render(\\\"全国招聘工作工资分布可视化表.html\\\")\"]},\"107\":{\"h\":\"📌完整代码\",\"t\":[\"from pprint import pprint import pyecharts.options as opts from pyecharts.globals import ThemeType from pyecharts.commons.utils import JsCode from pyecharts.charts import Timeline, Grid, Bar, Map, Pie, Line import pandas as pd file = f'data.csv' df = pd.read_csv(file) data = [] work = {} for index, row in df.iterrows(): keyword = row['keyword'] province = row['name'] averSalary = row['averSalary'] number = row['number'] if keyword not in work: work[keyword] = {'work': keyword, 'data': []} work[keyword]['data'].append({ 'province': province, 'value': [averSalary, number, province] }) data = list(work.values()) work_list = ['python', 'java', 'PHP', 'c/c++', 'C#', '.NET', 'Golang', 'Node.js', 'Android', 'iOS', '网络安全', '后端开发', '人工智能', 'web前端', '深度学习', '算法工程师', 'UI设计师'] total_num = [12373, 10794, 9616, 15584, 11876, 11348, 14679, 12854, 14158, 15898, 10988, 12989, 15096, 10200, 17128, 18482, 8751] maxNum = 60000 minNum = 5000 def get_work_chart(work: str): map_data = [ [[x[\\\"province\\\"], x[\\\"value\\\"]] for x in d[\\\"data\\\"]] for d in data if d[\\\"work\\\"] == work ][0] min_data, max_data = (minNum, maxNum) map_chart = ( Map() .add( series_name=\\\"\\\", data_pair=[[x[0], x[1][0]] for x in map_data], zoom=1, center=[130, 25], is_map_symbol_show=False, tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{b}: {c}\\\"), ) .set_global_opts( title_opts=opts.TitleOpts( title=\\\"\\\" + str(work) + \\\"全国各省份平均工资 数据来源：boss直聘，智联招聘\\\", subtitle=\\\"\\\", pos_left=\\\"center\\\", pos_top=\\\"top\\\", title_textstyle_opts=opts.TextStyleOpts( font_size=25 ), ), tooltip_opts=opts.TooltipOpts( is_show=True, formatter=JsCode( \\\"\\\"\\\"function(params) { if ('value' in params.data) { return params.data.value[2] + ': ' + params.data.value[0]; } }\\\"\\\"\\\" ), ), visualmap_opts=opts.VisualMapOpts( is_calculable=True, dimension=0, pos_left=\\\"30\\\", pos_top=\\\"top\\\", range_text=[\\\"High\\\", \\\"Low\\\"], range_color=[\\\"lightskyblue\\\", \\\"yellow\\\", \\\"orangered\\\"], textstyle_opts=opts.TextStyleOpts(color=\\\"#ddd\\\"), min_=min_data, max_=max_data, ), ) ) line_chart = ( Line() .add_xaxis(work_list) .add_yaxis( '', total_num, markpoint_opts=opts.MarkPointOpts(data=[opts.MarkPointItem(type_=\\\"max\\\")]), tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{c}\\\"), ) .set_series_opts(label_opts=opts.LabelOpts(is_show=False)) .set_global_opts( title_opts=opts.TitleOpts( title=\\\"全国岗位平均工资（单位：元）\\\", pos_left=\\\"72%\\\", pos_top=\\\"5%\\\" ) ) ) bar_x_data = [x[0] for x in map_data] bar_y_data = [{\\\"work\\\": x[0], \\\"value\\\": x[1][0]} for x in map_data] bar = ( Bar() .add_xaxis(xaxis_data=bar_x_data) .add_yaxis( series_name=\\\"\\\", y_axis=bar_y_data, label_opts=opts.LabelOpts( is_show=True, position=\\\"right\\\", formatter=\\\"{b} : {c}\\\" ), ) .reversal_axis() .set_global_opts( title_opts=opts.TitleOpts( title=\\\"\\\" + str(work) + \\\"各省份平均工资（单位：元/月）\\\", pos_left=\\\"0%\\\", pos_top=\\\"45%\\\" ), xaxis_opts=opts.AxisOpts( max_=60000, axislabel_opts=opts.LabelOpts(is_show=False) ), yaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(is_show=False)), tooltip_opts=opts.TooltipOpts(is_show=False), ) ) grid_chart = ( Grid() .add( bar, grid_opts=opts.GridOpts( pos_left=\\\"10\\\", pos_right=\\\"45%\\\", pos_top=\\\"50%\\\", pos_bottom=\\\"5\\\" ), ) .add( line_chart, grid_opts=opts.GridOpts( pos_left=\\\"58%\\\", pos_right=\\\"65\\\", pos_top=\\\"10%\\\", pos_bottom=\\\"50%\\\" ), ) .add(map_chart, grid_opts=opts.GridOpts()) ) return grid_chart if __name__ == \\\"__main__\\\": timeline = Timeline( init_opts=opts.InitOpts(width=\\\"1650px\\\", height=\\\"900px\\\", theme=ThemeType.DARK) ) for y in work_list: g = get_work_chart(work=y) timeline.add(g, time_point=str(y)) timeline.add_schema( orient=\\\"vertical\\\", # 纵向排列 is_auto_play=True, # 自动播放 is_inverse=True, # 反向播放 play_interval=5000, # 每个图表间隔5秒 pos_left=\\\"null\\\", # 左边距设置为 null（自动） pos_right=\\\"5\\\", # 右边距设置为 5 pos_top=\\\"20\\\", # 上边距设置为 20 pos_bottom=\\\"20\\\", # 下边距设置为 20 width=\\\"60\\\", # 时间轴的宽度 label_opts=opts.LabelOpts(is_show=True, color=\\\"#fff\\\", position=\\\"left\\\"), # 文本位置设置为右侧 ) timeline.render(\\\"全国招聘工作工资分布可视化表.html\\\")\"]},\"108\":{\"h\":\"📌成果展示\"},\"109\":{\"h\":\"2. 全国招聘工作数量可视化表.html\"},\"110\":{\"h\":\"📌数据获取\",\"t\":[\"获取数据与上图一样\"]},\"111\":{\"h\":\"📌map_chart（地图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\"# 区别于上面 def get_map_chart(work:str): map_data = [[x[0], x[1][1]] for x in [[[x[\\\"province\\\"], x[\\\"value\\\"]] for x in d[\\\"data\\\"]] for d in data if d[\\\"work\\\"] == work][0]] #这边x[1][1]获取的是工作岗位的数量，其他参数与上面类似，这里就不过多赘述 map_chart = ( Map() .add( series_name=\\\"\\\", data_pair=map_data, center=[130, 25], is_map_symbol_show=False, tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{b}: {c}\\\"), ) .set_global_opts( title_opts=opts.TitleOpts( title=\\\"\\\" + str(work) + \\\"全国招聘数量分布 数据来源：boss直聘，智联招聘\\\", subtitle=\\\"\\\", pos_left=\\\"center\\\", pos_top=\\\"top\\\", title_textstyle_opts=opts.TextStyleOpts( font_size=25 ), ), visualmap_opts=opts.VisualMapOpts( is_calculable=True, dimension=0, pos_left=\\\"30\\\", pos_top=\\\"top\\\", range_text=[\\\"High\\\", \\\"Low\\\"], range_color=[\\\"lightskyblue\\\", \\\"yellow\\\", \\\"orangered\\\"], textstyle_opts=opts.TextStyleOpts(color=\\\"#ddd\\\"), min_=0, max_=400, ), ) ) return map_chart\"]},\"112\":{\"h\":\"📌pie_chart（饼图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\"def get_pie_chart(work:str): pie_data = [[x[0], x[1][1]] for x in [[[x[\\\"province\\\"], x[\\\"value\\\"]] for x in d[\\\"data\\\"]] for d in data if d[\\\"work\\\"] == work][0]] # 获取的数据与地图一样 pie_chart = ( Pie() .add( series_name=\\\"\\\", data_pair=pie_data, radius=[\\\"15%\\\", \\\"35%\\\"], center=[\\\"80%\\\", \\\"82%\\\"], itemstyle_opts=opts.ItemStyleOpts( border_width=1, border_color=\\\"rgba(0,0,0,0.3)\\\" ), ) .set_global_opts( tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{b}: {c}\\\"), # 设置鼠标放置旁边时，显示具体数据 legend_opts=opts.LegendOpts(is_show=False), ) ) return pie_chart\"]},\"113\":{\"h\":\"📌grid_chart（并行多图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\"def get_grid_chart(work:str): grid_chart = ( Grid() .add(get_pie_chart(work), grid_opts=opts.GridOpts()) .add(get_map_chart(work), grid_opts=opts.GridOpts()) ) return grid_chart\"]},\"114\":{\"h\":\"📌timeline （时间线）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\" timeline = Timeline(init_opts=opts.InitOpts(width=\\\"1650px\\\", height=\\\"900px\\\", theme=ThemeType.DARK)) for work in work_list: timeline.add(get_grid_chart(work), time_point=str(work)) timeline.add_schema( orient=\\\"vertical\\\", # 纵向排列 is_auto_play=True, # 自动播放 is_inverse=True, # 反向播放 play_interval=5000, # 每个图表间隔5秒 pos_left=\\\"null\\\", # 左边距设置为 null（自动） pos_right=\\\"5\\\", # 右边距设置为 5 pos_top=\\\"20\\\", # 上边距设置为 20 pos_bottom=\\\"20\\\", # 下边距设置为 20 width=\\\"60\\\", # 时间轴的宽度 label_opts=opts.LabelOpts(is_show=True, color=\\\"#fff\\\", position=\\\"left\\\"), # 文本位置设置为右侧 ) timeline.render(\\\"全国招聘工作数量可视化表.html\\\")\"]},\"115\":{\"h\":\"📌完整代码\",\"t\":[\"from pprint import pprint import pyecharts.options as opts from pyecharts.globals import ThemeType from pyecharts.charts import Timeline, Grid, Bar, Map, Pie, Line, Page import pandas as pd file = f'data.csv' df = pd.read_csv(file) data =[] work = {} for index, row in df.iterrows(): keyword = row['keyword'] province = row['name'] averSalary = row['averSalary'] number = row['number'] if keyword not in work: work[keyword] = {'work': keyword, 'data': []} work[keyword]['data'].append({ 'province': province, 'value': [averSalary, number, province] }) data = list(work.values()) work_list = ['python', 'java', 'PHP', 'c/c++', 'C#', '.NET', 'Golang', 'Node.js', 'Android', 'iOS', '网络安全', '后端开发', '人工智能', 'web前端', '深度学习', '算法工程师', 'UI设计师'] def get_map_chart(work:str): map_data = [[x[0], x[1][1]] for x in [[[x[\\\"province\\\"], x[\\\"value\\\"]] for x in d[\\\"data\\\"]] for d in data if d[\\\"work\\\"] == work][0]] map_chart = ( Map() .add( series_name=\\\"\\\", data_pair=map_data, center=[130, 25], is_map_symbol_show=False, tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{b}: {c}\\\"), ) .set_global_opts( title_opts=opts.TitleOpts( title=\\\"\\\" + str(work) + \\\"全国招聘数量分布 数据来源：boss直聘，智联招聘\\\", subtitle=\\\"\\\", pos_left=\\\"center\\\", pos_top=\\\"top\\\", title_textstyle_opts=opts.TextStyleOpts( font_size=25 ), ), visualmap_opts=opts.VisualMapOpts( is_calculable=True, dimension=0, pos_left=\\\"30\\\", pos_top=\\\"top\\\", range_text=[\\\"High\\\", \\\"Low\\\"], range_color=[\\\"lightskyblue\\\", \\\"yellow\\\", \\\"orangered\\\"], textstyle_opts=opts.TextStyleOpts(color=\\\"#ddd\\\"), min_=0, max_=400, ), ) ) return map_chart def get_pie_chart(work:str): pie_data = [[x[0], x[1][1]] for x in [[[x[\\\"province\\\"], x[\\\"value\\\"]] for x in d[\\\"data\\\"]] for d in data if d[\\\"work\\\"] == work][0]] pie_chart = ( Pie() .add( series_name=\\\"\\\", data_pair=pie_data, radius=[\\\"15%\\\", \\\"35%\\\"], center=[\\\"80%\\\", \\\"82%\\\"], itemstyle_opts=opts.ItemStyleOpts( border_width=1, border_color=\\\"rgba(0,0,0,0.3)\\\" ), ) .set_global_opts( tooltip_opts=opts.TooltipOpts(is_show=True, formatter=\\\"{b}: {c}\\\"), legend_opts=opts.LegendOpts(is_show=False), ) ) return pie_chart def get_grid_chart(work:str): grid_chart = ( Grid() .add(get_pie_chart(work), grid_opts=opts.GridOpts()) .add(get_map_chart(work), grid_opts=opts.GridOpts()) ) return grid_chart if __name__ == \\\"__main__\\\": timeline = Timeline(init_opts=opts.InitOpts(width=\\\"1650px\\\", height=\\\"900px\\\", theme=ThemeType.DARK)) for work in work_list: timeline.add(get_grid_chart(work), time_point=str(work)) timeline.add_schema( orient=\\\"vertical\\\", # 纵向排列 is_auto_play=True, # 自动播放 is_inverse=True, # 反向播放 play_interval=5000, # 每个图表间隔5秒 pos_left=\\\"null\\\", # 左边距设置为 null（自动） pos_right=\\\"5\\\", # 右边距设置为 5 pos_top=\\\"20\\\", # 上边距设置为 20 pos_bottom=\\\"20\\\", # 下边距设置为 20 width=\\\"60\\\", # 时间轴的宽度 label_opts=opts.LabelOpts(is_show=True, color=\\\"#fff\\\", position=\\\"left\\\"), # 文本位置设置为右侧 ) timeline.render(\\\"全国招聘工作数量可视化表.html\\\")\"]},\"116\":{\"h\":\"📌成果展示\"},\"117\":{\"h\":\"3. 岗位词云统计.html\"},\"118\":{\"h\":\"📌数据获取\",\"t\":[\" safe_keyword = keyword.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') #获取对应职业文件姓名 file = f'{safe_keyword}.csv' df = pd.read_csv(file) # 读取对应excel count = {} # 统计该词出现的次数 for index, row in df.iterrows(): skills = row['技能'] # 获取'技能'一列 parts = str(skills).split(', ') # 以', '为分割符 for part in parts: if part in count: count[part] += 1 else: count[part] = 1 words=[] # 词云 for part in count: words.append((part, count[part]))\"]},\"119\":{\"h\":\"📌WordCloud（词云图）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\"c = ( WordCloud() .add( \\\"\\\", words, word_size_range=[20, 100], textstyle_opts=opts.TextStyleOpts(font_family=\\\"cursive\\\"), ) .set_global_opts(title_opts=opts.TitleOpts(title=keyword+\\\"岗位技能词云\\\")) )\"]},\"120\":{\"h\":\"📌timeline（时间线）\",\"t\":[\"若需要知道具体数据作用，请参照 使用文档\",\"timeline.add_schema( is_auto_play=True, # 自动播放 play_interval=5000, # 每个图表间隔5秒 pos_left=\\\"null\\\", # 左边距设置为 null（自动） width=\\\"1400\\\", # 时间轴的宽度 ) timeline.render('岗位词云统计.html')\"]},\"121\":{\"h\":\"📌完整代码\",\"t\":[\"from pyecharts import options as opts from pyecharts.charts import WordCloud,Timeline import pandas as pd keywords = ['python', 'java', 'PHP', 'c/c++', 'C#', '.NET', 'Golang', 'Node.js', 'Android', 'iOS', '网络安全', '后端开发', '人工智能', 'web前端', '深度学习', '算法工程师', 'UI设计师'] timeline = Timeline(init_opts=opts.InitOpts(width=\\\"1650px\\\", height=\\\"900px\\\", theme=ThemeType.LIGHT)) for keyword in keywords: safe_keyword = keyword.replace('/', '_').replace('\\\\\\\\', '_').replace(':', '_') file = f'{safe_keyword}.csv' df = pd.read_csv(file) count = {} for index, row in df.iterrows(): skills = row['技能'] parts = str(skills).split(', ') for part in parts: if part in count: count[part] += 1 else: count[part] = 1 words=[] for part in count: words.append((part, count[part])) c = ( WordCloud() .add( \\\"\\\", words, word_size_range=[20, 100], textstyle_opts=opts.TextStyleOpts(font_family=\\\"cursive\\\"), ) .set_global_opts(title_opts=opts.TitleOpts(title=keyword+\\\"岗位技能词云\\\")) ) timeline.add(c, time_point=str(keyword)) timeline.add_schema( is_auto_play=True, # 自动播放 play_interval=5000, # 每个图表间隔5秒 pos_left=\\\"null\\\", # 左边距设置为 null（自动） width=\\\"1400\\\", # 时间轴的宽度 ) timeline.render('岗位词云统计.html')\"]},\"122\":{\"h\":\"📌成果展示\"},\"123\":{\"c\":[\"Python\",\"Jupyter Notebook\",\"pyecharts\"]},\"124\":{\"c\":[\"地图\",\"柱状图\",\"折线图\",\"饼图\",\"时间轴\",\"词云图\"]},\"125\":{\"h\":\"MinIO 安装与部署\",\"t\":[\"官方仓库\",\"GitHub：https://github.com/minio\",\"GItee镜像：https://gitee.com/mirrors/minio\",\"官网下载：https://www.minio.org.cn/download.shtml#/\"]},\"126\":{\"h\":\"Linux 安装启动\",\"t\":[\"下载安装包：\",\"wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio\",\"赋予可执行权限：\",\"chmod +x minio\",\"前台启动：\",\"MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address \\\":9001\\\"\",\"命令解释：\",\"MINIO_ROOT_USER=admin：指定MinIO的用户名\",\"MINIO_ROOT_PASSWORD=password：指定MinIO密码 （用户名和密码都可以省略，默认均为 minioadmin）\",\"./minio server：在 minio 所在目录下启动 minio 服务，可修改\",\"/mnt/data：指定数据存放位置，可以自定义修改\",\"--console-address \\\":9001\\\"：指定 MinIO 控制台的监听地址和端口\",\"后台启动：\",\"# 最简单的，只需要在最后面加上 & 即可，但关闭会话服务会停止 nohub ./minio server /mnt/data > /opt/minio/data/minio.log 2>&1 --console-address \\\":9001\\\" &\",\"命令解释：\",\"nohup：这是一个 Unix 命令，用于运行另一个命令在后台，并且忽略挂起（HUP）信号，即使你退出了终端或关闭了会话，该命令也会继续执行；\",\"> /opt/minio/data/minio.log：这部分是将标准输出（stdout）重定向到 /opt/minio/data/minio.log 文件，这意味着 MinIO 服务器的所有正常输出（如启动信息、状态更新等）都会被写入到这个日志文件中；\",\"2>&1：这部分是将标准错误输出（stderr）重定向到标准输出（stdout），即输出到 /opt/minio/data/minio.log 文件，这样，无论是标准输出还是错误输出，都会被写入到同一个日志文件中；\",\"&：这个符号是在命令的末尾，用于将命令放到后台执行，也就是即使你启动了 MinIO 服务器，你的终端或 shell 会话也不会被阻塞，你可以继续执行其他命令；\"]},\"127\":{\"h\":\"Docker 安装启动\",\"t\":[\"搜索 MinIO 镜像：\",\"docker search minio\",\"拉取 MinIO 镜像：\",\"docker pull minio/minio\",\"启动 MinIO 容器：\",\"docker run -p 9000:9000 -p 9001:9001 minio/minio server /mnt/docker/data --console-address \\\":9001\\\"\"]},\"128\":{\"h\":\"Windows 安装启动\",\"t\":[\"下载 Windows 版的 MinIO：\",\"https://dl.min.io/server/minio/release/windows-amd64/minio.exe\",\"进入到 minio.exe 所在的目录，导航栏输入 cmd 进入终端，执行：\",\"minio.exe server D:\\\\dev\\\\MinIO\\\\data --console-address \\\":9001\\\"\",\"启动 MinIO 服务，其中 D:\\\\dev\\\\MinIO\\\\data 是 MinIO 存储数据的目录路径\",\"在浏览器输入 http://localhost:9000/，登录 MinIO 服务器 web 管理后台\",\"提示\",\"默认用户名和密码都是 minioadmin\"]},\"129\":{\"h\":\"Windows 后台服务安装\",\"t\":[\"使用上述命令将 MinIO 在 Windows 上启动，关闭终端后服务就会停止。如果要使用 Windows 搭建 MinIO 服务器，需要将其注册为 Windows 服务。\",\"下载 WinSW-x64.exe：https://github.com/winsw/winsw/releases\",\"将 WinSW.exe 复制到自己指定的目录，重命名为 minio-server.exe.\",\"在同目录下创建 minio-server.xml。注意，xml 和 exe 必须同名。\",\"配置 minio-server.xml 文件，内容如下:\",\"<service> <id>minio-server</id> <name>minio-server</name> <description>minio文件存储服务</description> <executable>%BASE%\\\\minio.exe</executable> <arguments>server \\\"%BASE%\\\\data\\\"</arguments> <logpath>%BASE%\\\\logs</logpath> <log mode=\\\"roll-by-size-time\\\"> <sizeThreshold>10240</sizeThreshold> <pattern>yyyyMMdd</pattern> <autoRollAtTime>00:00:00</autoRollAtTime> <zipOlderThanNumDays>5<zipOlderThanNumDays> <zipDateFormat>yyyyMMdd</zipDateFormat> </log> </service>\",\"执行 cmd 命令注册系统服务\",\"minio-server.exe install\",\"卸载服务\",\"minio-server.exe uninstall\"]},\"130\":{\"c\":[\"中间件\"]},\"131\":{\"c\":[\"MinIO\"]},\"132\":{\"h\":\"MinIO 概述\",\"t\":[\"官网链接\",\"MinIO官网：https://min.io/\",\"中文官网：http://minio.org.cn/\",\"MinIO 是一个高性能的分布式对象存储系统，基于 Apache License v2.0 开源协议，兼容亚马逊 S3 云存储服务接口，非常适合存储大容量的数据，包括但不限于：\",\"文本数据：新闻报道、社交媒体文章、博客......\",\"语音数据：音频形式存储的数据，语音mp3文件......\",\"图像数据：各种图片......\",\"视频数据：各种视频、电影......\",\"非结构化数据：没有明确结构的数据，比如社交评论、日志文件......\"]},\"133\":{\"h\":\"什么是对象存储？\",\"t\":[\"对象存储（Object Storage）是一种数据存储架构，它以对象为单位来处理、存储和检索数据，每个对象都包含了数据本身以及元数据，适合存放任意类型的文件。通常通过基于 HTTP 或 HTTPS 协议的 API（应用程序编程接口）进行数据读写。常见的有阿里云对象存储服务（OSS）、腾讯云对象存储（COS）等。\",\"所以基于对象的形式， MinIO 存储的元数据主要包括对象的描述信息，如用户（account）、存储桶（bucket）以及存储桶索引（bucket index）等。\",\"对于企业来说，可以使用各种公有云提供的 OSS 服务，将业务数据存储在云上，既能节省存储成本，也能使用云存储服务提供的 API 接口，方便使用和管理数据。但对于数据传输的安全性和及时性有较高要求的业务来说，使用公有云的 OSS 服务，就要付出较高的公网带宽传输成本，以及对数据安全的保障服务。在这种情况下，利用 MinIO 轻便、高性能、可拓展性的特点，企业可以快速搭建自己的内部对象存储服务。\",\"当然，对于个人来说，MinIO 是 100% 开源的，这就意味着个人也可以基于 MinIO 搭建自己专属的对象存储服务器。\"]},\"134\":{\"h\":\"特点\",\"t\":[\"文档全面： MinIO 作为一款基于 Golang 语言开发的一款高性能的分布式式存储方案的开源项目，有十分完善的官方文档。\",\"MinIO 文档\",\"中文文档地址：https://www.minio.org.cn/docs/minio/\",\"高性能： MinIO 号称是目前速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以高达 183GB/s 和 171GB/s。对象存储可以作为主存储层，用来处理 Spark、Presto、TensorFlow、HAO.ai 等各种复杂工作负载以及成为 Hadoop HDFS 的替代品。\",\"云原生： 容器化、基于 K8S 的编排、多租户支持。 用作云原生应用程序的主要存储，和传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。\",\"可拓展： 不同 MinIO 集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。 并且除了 MinIO 自己的文件系统，还支持 DAS、 JBODs、NAS、Google 云存储和 Azure Blob 存储。\",\"Amazon S3 标准兼容: 亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界内大家都认可的标准。MinIO 在很早的时候就采用了 S3 兼容协议，并且 MinIO 是第一个支持 S3 Select 的产品。 使用 Amazon S3 v2 / v4 API，可以使用 MinIO SDK，MinIO Client，AWS SDK 和 AWS CLI 访问 MinIO 服务器。\",\"支持全面： 目前 MinIO 支持市面主流的开发语言并且可以通过 SDK 快速集成快速集成使用。\",\"常用语言的 SDK\",\"GO SDK：https://github.com/minio/minio-go\",\"Java SDK：https://github.com/minio/minio-java\",\"Python SDK：https://github.com/minio/minio-py\",\"可视化管理界面： MinIO 除了通过传统的命令行进行操作之外，还提供可视化的操作管理界面，在服务安装后，可以直接通过浏览器登录系统，完成文件夹、文件的管理，非常方便使用。\",\"数据存储高容错： Minio 的存储机制使用纠删码（Erasure Code）和校验和（CheckSum）。 校验和：保护数据免受硬件故障和无声数据损坏。 纠删码：是一种恢复丢失和损坏数据的数学算法。通过数学算法将数据分割成多个数据块和校验块，并将这些块分散存储在不同的磁盘上。这种机制使得即使部分磁盘发生故障，也能通过剩余的数据块和校验块恢复原始数据，从而提高系统的可靠性和容错能力。 具体地，MinIO 使用 Reed-Solomon 码作为其纠删码算法，将一个对象拆分成 N/2 份数据和 N/2 份奇偶校验块。如果是 12 块盘，一个对象会被分成 6 个数据块、 6 个奇偶校验块，可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），仍可以从剩下的盘中的数据进行恢复。 这样的设计，保证了即使在最坏的情况，即丢失一半数量的硬盘的情况下仍能保证数据的安全性。\"]},\"135\":{\"c\":[\"中间件\"]},\"136\":{\"c\":[\"MinIO\"]},\"137\":{\"h\":\"SpringBoot 整合 MinIO\"},\"138\":{\"h\":\"引入依赖\",\"t\":[\"<dependency> <groupId>io.minio</groupId> <artifactId>minio</artifactId> <version>8.5.9</version> </dependency>\"]},\"139\":{\"h\":\"配置文件\",\"t\":[\"MinIO 中的 Bucket、Object\",\"Bucket 是存储 Object 的逻辑空间，每个 Bucket 之间的数据是相互隔离的，对用户而言，相当于存放文件的顶层文件夹\",\"Object 是存储到 MinIO 的基本对象，对用户而言，相当于文件\",\"SpringBoot 使用 MinIO 非常方便，只需要创建 MinIOClient 即可，后续通过调用 API 对 MinIO 服务进行配置和操作。\",\"在 application.yml 中配置 MinIO 连接信息\",\"minio: endpoint: http://localhost:9000 # 服务器地址和端口 accessKey: minioadmin # minio用户名 secretKey: minioadmin # minio密码 bucket: user-bucket # 使用的存储桶（可选）\",\"添加 MinIO 实体类\",\"@Data @Component @ConfigurationProperties(prefix = \\\"minio\\\") public class MinIOInfo { private String endpoint; private String accessKey; private String secretKey; private String bucket; }\",\"将 MinIOClient 注册为 Bean 对象，后续通过注入 minioClient 对象即可实现对 MinIO 的操作。\",\"@Configuration public class Config { @Resource private MinIOInfo minIOInfo; @Bean public MinioClient minioClient() { //链式编程，构建MinioClient对象 return MinioClient.builder() .endpoint(minIOInfo.getEndpoint()) .credentials(minIOInfo.getAccessKey(), minIOInfo.getSecretKey()) .build(); } }\",\"支持多线程\",\"MinioClient 对象是单例的，那么有没有线程安全问题呢？\",\"答案是：没有线程安全问题。MinIO 官方团队表示，可以多个线程共同使用一个 MinIOClient 对象。\"]},\"140\":{\"h\":\"MinioClient 的常用 API\"},\"141\":{\"h\":\"Bucket 操作\",\"t\":[\"bucketExists()：用于检查指定的存储桶是否存在，返回布尔值，表示存储桶是否存在\",\" void test01() throws Exception { boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\\\"myfile\\\").build()); System.out.println(\\\"myfile目录是否存在：\\\" + isBucketExists); }\",\"makeBucket()：用于创建一个新的存储桶（bucket），需要指定存储桶的名称\",\" void test02() throws Exception { String bucketName = \\\"myfile2\\\"; boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build()); if (!isBucketExists) { minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build()); } else { System.out.println(\\\"bucket已经存在，不需要创建\\\"); } String policyJsonString = \\\"{\\\\\\\"Version\\\\\\\" : \\\\\\\"2012-10-17\\\\\\\",\\\\\\\"Statement\\\\\\\":[{\\\\\\\"Sid\\\\\\\":\\\\\\\"PublicRead\\\\\\\",\\\\\\\"Effect\\\\\\\":\\\\\\\"Allow\\\\\\\",\\\\\\\"Principal\\\\\\\":{\\\\\\\"AWS\\\\\\\":\\\\\\\"*\\\\\\\"},\\\\\\\"Action\\\\\\\":[\\\\\\\"s3:GetObject\\\\\\\"],\\\\\\\"Resource\\\\\\\":[\\\\\\\"arn:aws:s3:::\\\" + bucketName + \\\"/*\\\\\\\"]}]}\\\"; //创建存储桶的时候，设置该存储桶里面的文件的访问策略，运行公开的读； minioClient.setBucketPolicy(SetBucketPolicyArgs.builder() .bucket(bucketName) .config(policyJsonString)//json串，里面是访问策略 .build()); }\",\"listBuckets()：用于列出用户有权访问的所有存储桶，返回存储桶的列表\",\" void test03() throws Exception { List<Bucket> bucketList = minioClient.listBuckets(); bucketList.forEach(bucket -> { System.out.println(bucket.name() + \\\" -- \\\" + bucket.creationDate()); }); }\",\"removeBucket()：用于删除一个已存在的存储桶（bucket），删除失败会抛出异常\",\" void test04() throws Exception { minioClient.removeBucket(RemoveBucketArgs.builder().bucket(\\\"myfile2\\\").build()); }\"]},\"142\":{\"h\":\"Object 操作\",\"t\":[\"putObject()：用于上传文件到指定的存储桶\",\" void test05() throws Exception { File file = new File(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\"); // 文件路径 ObjectWriteResponse objectWriteResponse = minioClient.putObject(PutObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .stream(new FileInputStream(file), file.length(), -1) // 使用stream流读取文件，自动获取文件大小 .build() ); System.out.println(objectWriteResponse); ObjectWriteResponse objectWriteResponse2 = minioClient.uploadObject(UploadObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test2.jpg\\\") .filename(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\") // 指定文件路径 .build() ); System.out.println(objectWriteResponse); }\",\"statObject()：用于检查指定的对象（文件）的状态\",\" void test06() throws Exception { StatObjectResponse statObjectResponse = minioClient.statObject(StatObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(statObjectResponse); }\",\"getPresignedObjectUrl()：用于生成一个对象（文件）的签名URL，以便可以通过HTTP访问\",\" void test07() throws Exception { String presignedObjectUrl = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .expiry(3, TimeUnit.MINUTES) .method(Method.GET) .build() ); System.out.println(presignedObjectUrl); }\",\"getObject()：用于从指定的存储桶中下载文件\",\" void test08() throws Exception { GetObjectResponse getObjectResponse = minioClient.getObject(GetObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(getObjectResponse.transferTo(new FileOutputStream(\\\"D:\\\\\\\\MinIO\\\\\\\\123.jpg\\\"))); }\",\"listObjects()：用于列出指定存储桶中的所有对象（文件）\",\" void test09() throws Exception { Iterable<Result<Item>> listObjects = minioClient.listObjects(ListObjectsArgs.builder() .bucket(\\\"myfile\\\") .build() ); listObjects.forEach( itemResult -> { try { Item item = itemResult.get(); System.out.println(item.objectName()); } catch (Exception e) { throw new RuntimeException(e); } }); }\",\"removeObject()：用于删除指定存储桶中的对象，需要指定存储桶名称和对象键\",\" void test10() throws Exception { minioClient.removeObject(RemoveObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); }\"]},\"143\":{\"c\":[\"中间件\"]},\"144\":{\"c\":[\"MinIO\"]},\"145\":{\"h\":\"Shell 语法\"},\"146\":{\"h\":\"概论\",\"t\":[\"shell 是我们通过命令行与操作系统沟通的语言。\",\"shell 脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 AC Terminal 中的命令行可以看成是一个\\\"shell脚本在逐行执行\\\"。\",\"Linux 中常见的 shell 脚本有很多种，常见的有：\",\"Bourne Shell ( /usr/bin/sh 或 /bin/sh )\",\"Bourne Again Shell ( /bin/bash )\",\"C Shell ( /usr/bin/csh )\",\"K Shell ( /usr/bin/ksh )\",\"zsh ...\",\"Linux 系统中一般默认使用 bash，所以接下来讲解 bash 中的语法。 文件开头需要写 #! /bin/bash ，指明 bash 为脚本解释器。\",\"学习技巧\",\"不要死记硬背，遇到含糊不清的地方，可以在 AC Terminal 里实际运行一遍。\",\"脚本示例\",\"新建一个 test.sh 文件，内容如下：\",\"#! /bin/bash echo \\\"Hello World!\\\"\",\"运行方式\",\"作为可执行文件\",\"acs@9e0ebfcd82d7:~$ chmod +x test.sh # 使脚本具有可执行权限 acs@9e0ebfcd82d7:~$ ./test.sh # 当前路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ /home/acs/test.sh # 绝对路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ ~/test.sh # 家目录路径下执行 Hello World! # 脚本输出\",\"用解释器执行\",\"acs@9e0ebfcd82d7:~$ bash test.sh Hello World! # 脚本输出\"]},\"147\":{\"h\":\"1. 注释\"},\"148\":{\"h\":\"1.1 单行注释\",\"t\":[\"每行中 # 之后的内容均是注释。\",\"# 这是一行注释 echo 'Hello World' # 这也是注释\"]},\"149\":{\"h\":\"1.2 多行注释\",\"t\":[\"格式：\",\":<<EOF 第一行注释 第二行注释 第三行注释 EOF\",\"其中 EOF 可以换成其它任意字符串。例如：\",\":<<abc 第一行注释 第二行注释 第三行注释 abc :<<! 第一行注释 第二行注释 第三行注释 !\"]},\"150\":{\"h\":\"2. 变量\"},\"151\":{\"h\":\"2.1 定义变量\",\"t\":[\"定义变量，不需要加 $ 符号，例如：\",\"name1='yxc' # 单引号定义字符串 name2=\\\"yxc\\\" # 双引号定义字符串 name3=yxc # 也可以不加引号，同样表示字符串\"]},\"152\":{\"h\":\"2.2 使用变量\",\"t\":[\"使用变量，需要加上 $ 符号，或者 ${} 符号。花括号是可选的，主要为了帮助解释器识别变量边界。\",\"name=yxc echo $name # 输出yxc echo ${name} # 输出yxc echo ${name}acwing # 输出yxcacwing\"]},\"153\":{\"h\":\"2.3 只读变量\",\"t\":[\"使用 readonly 或者 declare 可以将变量变为只读。\",\"name=yxc readonly name declare -r name # 两种写法均可 name=abc # 会报错，因为此时name只读\"]},\"154\":{\"h\":\"2.4 删除变量\",\"t\":[\"unset 可以删除变量。\",\"name=yxc unset name echo $name # 输出空行\"]},\"155\":{\"h\":\"2.5 变量类型\",\"t\":[\"自定义变量（局部变量）\",\"子进程不能访问的变量\",\"环境变量（全局变量）\",\"子进程可以访问的变量\",\"自定义变量改成环境变量：\",\"acs@9e0ebfcd82d7:~$ name=yxc # 定义变量 acs@9e0ebfcd82d7:~$ export name # 第一种方法 acs@9e0ebfcd82d7:~$ declare -x name # 第二种方法\",\"环境变量改为自定义变量：\",\"acs@9e0ebfcd82d7:~$ export name=yxc # 定义环境变量 acs@9e0ebfcd82d7:~$ declare +x name # 改为自定义变量\"]},\"156\":{\"h\":\"2.6 字符串\",\"t\":[\"字符串可以用单引号，也可以用双引号，也可以不用引号。\",\"单引号与双引号的区别：\",\"单引号中的内容会原样输出，不会执行、不会取变量；\",\"双引号中的内容可以执行、可以取变量；\",\"name=yxc # 不用引号 echo 'hello, $name \\\\\\\"hh\\\\\\\"' # 单引号字符串，输出 hello, $name \\\\\\\"hh\\\\\\\" echo \\\"hello, $name \\\\\\\"hh\\\\\\\"\\\" # 双引号字符串，输出 hello, yxc \\\"hh\\\"\",\"获取字符串长度\",\"name=\\\"yxc\\\" echo ${#name} # 输出3\",\"提取子串\",\"name=\\\"hello, yxc\\\" echo ${name:0:5} # 提取从0开始的5个字符\"]},\"157\":{\"h\":\"3. 默认变量\"},\"158\":{\"h\":\"3. 1 文件参数变量\",\"t\":[\"在执行 shell 脚本时，可以向脚本传递参数。$1 是第一个参数，$2 是第二个参数，以此类推。特殊的，$0 是文件名（包含路径）。例如：\",\"创建文件 test.sh ：\",\"#! /bin/bash echo \\\"文件名：\\\"$0 echo \\\"第一个参数：\\\"$1 echo \\\"第二个参数：\\\"$2 echo \\\"第三个参数：\\\"$3 echo \\\"第四个参数：\\\"$4\",\"然后执行该脚本：\",\"acs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4 文件名：./test.sh 第一个参数：1 第二个参数：2 第三个参数：3 第四个参数：4\"]},\"159\":{\"h\":\"3.2 其它参数相关变量\",\"t\":[\"参数\",\"说明\",\"$#\",\"代表文件传入的参数个数，如上例中值为4\",\"$*\",\"由所有参数构成的用空格隔开的字符串，如上例中值为 \\\"$1 $2 $3 $4\\\"\",\"$@\",\"每个参数分别用双引号括起来的字符串，如上例中值为 \\\"$1\\\" \\\"$2\\\" \\\"$3\\\" \\\"$4\\\"\",\"$$\",\"脚本当前运行的进程ID\",\"$?\",\"上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\",\"$(command)\",\"返回 command这条命令的stdout（可嵌套）\",\"command\",\"返回 command 这条命令的stdout（不可嵌套）\"]},\"160\":{\"h\":\"4. 数组\",\"t\":[\"数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。 数组 下标从0开始。\"]},\"161\":{\"h\":\"4.1 定义\",\"t\":[\"数组用小括号表示，元素之间用空格隔开。例如：\",\"array=(1 abc \\\"def\\\" yxc)\",\"也可以直接定义数组中某个元素的值：\",\"array[0]=1 array[1]=abc array[2]=\\\"def\\\" array[3]=yxc\"]},\"162\":{\"h\":\"4.2 读取数组中某个元素的值\",\"t\":[\"格式：\",\"${array[index]}\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${array[0]} echo ${array[1]} echo ${array[2]} echo ${array[3]}\"]},\"163\":{\"h\":\"4.3 读取整个数组\",\"t\":[\"格式：\",\"${array[@]} # 第一种写法 ${array[*]} # 第二种写法\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${array[@]} # 第一种写法 echo ${array[*]} # 第二种写法\"]},\"164\":{\"h\":\"4.4 数组长度\",\"t\":[\"类似于字符串\",\"${#array[@]} # 第一种写法 ${#array[*]} # 第二种写法\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${#array[@]} # 第一种写法 echo ${#array[*]} # 第二种写法\"]},\"165\":{\"c\":[\"Linux\"]},\"166\":{\"c\":[\"基础\"]},\"167\":{\"h\":\"MySQL 基础知识\"},\"168\":{\"h\":\"1. 基础\"},\"169\":{\"h\":\"1.1 连接\",\"t\":[\"MySQL服务器启动完毕后，然后再使用如下指令，来连接 MySQL 服务器：\",\"mysql -u用户名 -p密码 [-h数据库服务器的IP地址 -P端口号]\",\"命令解释\",\"-h 参数不加，默认连接的是本地 127.0.0.1 的 MySQL 服务器\",\"-P 参数不加，默认连接的端口号是 3306\",\"上述指令，可以有两种形式：\",\"密码直接在 -p 参数之后直接指定 （这种方式不安全，密码直接以明文形式出现在命令行）\",\"密码在 -p 回车之后，在命令行中输入密码，然后回车\"]},\"170\":{\"h\":\"1.2 SQL 简介\",\"t\":[\"SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\"]},\"171\":{\"h\":\"1.2.1 SQL 通用语法\",\"t\":[\"1、SQL 语句可以单行或多行书写，以分号结尾。\",\"2、SQL 语句可以使用空格/缩进来增强语句的可读性。\",\"3、MySQL 数据库的 SQL 语句不区分大小写。\",\"4、注释：\",\"单行注释：-- 注释内容或 # 注释内容 (MySQL特有)\",\"多行注释： /* 注释内容 */\"]},\"172\":{\"h\":\"1.2.2 分类\",\"t\":[\"SQL 语句根据其功能被分为四大类：DDL、DML、DQL、DCL\",\"分类\",\"全称\",\"说明\",\"DDL\",\"Data Definition Language\",\"数据定义语言，用来定义数据库对象(数据库，表，字段)\",\"DML\",\"Data Manipulation Language\",\"数据操作语言，用来对数据库表中的数据进行增删改\",\"DQL\",\"Data Query Language\",\"数据查询语言，用来查询数据库中表的记录\",\"DCL\",\"Data Control Language\",\"数据控制语言，用来创建数据库用户、控制数据库的访问权限\"]},\"173\":{\"h\":\"2. 数据库设计-DDL\",\"t\":[\"针对于数据库设计，主要包括三个阶段：\",\"数据库设计阶段 \",\"参照页面原型以及需求文档设计数据库表结构\",\"数据库操作阶段 \",\"根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作\",\"数据库优化阶段 \",\"通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等\"]},\"174\":{\"h\":\"2.1 数据库操作\",\"t\":[\"DDL 英文全称是 Data Definition Language (数据定义语言)，用来定义数据库对象(数据库、表)。\",\"DDL 中数据库的常见操作：查询、创建、使用、删除。\"]},\"175\":{\"h\":\"2.1.1 查询数据库\",\"t\":[\"查询所有数据库：\",\"show databases;\",\"查询当前数据库：\",\"select database();\",\"用法\",\"我们要操作某一个数据库，必须要切换到对应的数据库中。\",\"通过指令 select database()，就可以查询到当前所处的数据库\"]},\"176\":{\"h\":\"2.1.2 创建数据库\",\"t\":[\"语法：\",\"create database [ if not exists ] 数据库名;\",\"注意：在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。\",\"可以使用 if not exists 来避免这个问题\",\"-- 数据库不存在,则创建该数据库；如果存在则不创建 create database if not extists my_database;\"]},\"177\":{\"h\":\"2.1.3 使用数据库\",\"t\":[\"语法：\",\"use 数据库名 ;\",\"切换数据库\",\"我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则不能操作。\"]},\"178\":{\"h\":\"2.1.4 删除数据库\",\"t\":[\"语法：\",\"drop database [ if exists ] 数据库名 ;\",\"如果删除一个不存在的数据库，将会报错。\",\"可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\",\"案例：删除 itcast 数据库\",\"drop database if exists itcast; -- itcast数据库存在时删除\",\"命令执行效果如下：\",\"说明\",\"上述语法中的 database，也可以替换成 schema\",\"如：create schema db01;\",\"如：show schemas;\"]},\"179\":{\"h\":\"2.2 表操作\",\"t\":[\"关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。\"]},\"180\":{\"h\":\"2.2.1 创建\"},\"181\":{\"h\":\"2.2.1.1 语法\",\"t\":[\"create table 表名( 字段1 字段1类型 [约束] [comment 字段1注释 ], 字段2 字段2类型 [约束] [comment 字段2注释 ], ...... 字段n 字段n类型 [约束] [comment 字段n注释 ] ) [ comment 表注释 ] ;\",\"注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号\"]},\"182\":{\"h\":\"2.2.1.2 约束\",\"t\":[\"概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。\",\"作用：就是来保证数据库当中数据的正确性、有效性和完整性。\",\"在MySQL数据库当中，提供了以下5种约束：\",\"约束\",\"描述\",\"关键字\",\"非空约束\",\"限制该字段值不能为null\",\"not null\",\"唯一约束\",\"保证字段的所有数据都是唯一、不重复的\",\"unique\",\"主键约束\",\"主键是一行数据的唯一标识，要求非空且唯一\",\"primary key\",\"默认约束\",\"保存数据时，如果未指定该字段值，则采用默认值\",\"default\",\"外键约束\",\"让两张表的数据建立连接，保证数据的一致性和完整性\",\"foreign key\",\"注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\",\"MySQL数据库为解决id问题，提供了一个关键字：auto_increment（自动增长）\",\"主键自增：auto_increment\",\"每次插入新的行记录时，数据库自动生成 id 字段(主键)下的值\",\"具有 auto_increment 的数据列是一个正数序列开始增长(从 1 开始自增)\"]},\"183\":{\"h\":\"2.2.1.3 数据类型\",\"t\":[\"MySQL中的数据类型主要分为三类：数值类型、字符串类型、日期时间类型。\",\"数值类型\",\"类型\",\"大小\",\"有符号(SIGNED)范围\",\"无符号(UNSIGNED)范围\",\"描述\",\"TINYINT\",\"1byte\",\"(-128，127)\",\"(0，255)\",\"小整数值\",\"SMALLINT\",\"2bytes\",\"(-32768，32767)\",\"(0，65535)\",\"大整数值\",\"MEDIUMINT\",\"3bytes\",\"(-8388608，8388607)\",\"(0，16777215)\",\"大整数值\",\"INT/INTEGER\",\"4bytes\",\"(-2147483648，2147483647)\",\"(0，4294967295)\",\"大整数值\",\"BIGINT\",\"8bytes\",\"(-263，263-1)\",\"(0，2^64-1)\",\"极大整数值\",\"FLOAT\",\"4bytes\",\"(-3.402823466 E+38，3.402823466351 E+38)\",\"0 和 (1.175494351 E-38，3.402823466 E+38)\",\"单精度浮点数值\",\"DOUBLE\",\"8bytes\",\"(-1.7976931348623157 E+308，1.7976931348623157 E+308)\",\"0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)\",\"双精度浮点数值\",\"DECIMAL\",\"依赖于M(精度)和D(标度)的值\",\"依赖于M(精度)和D(标度)的值\",\"小数值(精确定点数)\",\"字符串类型\",\"类型\",\"大小\",\"描述\",\"CHAR\",\"0-255 bytes\",\"定长字符串(需要指定长度)\",\"VARCHAR\",\"0-65535 bytes\",\"变长字符串(需要指定长度)\",\"TINYBLOB\",\"0-255 bytes\",\"不超过255个字符的二进制数据\",\"TINYTEXT\",\"0-255 bytes\",\"短文本字符串\",\"BLOB\",\"0-65 535 bytes\",\"二进制形式的长文本数据\",\"TEXT\",\"0-65 535 bytes\",\"长文本数据\",\"MEDIUMBLOB\",\"0-16 777 215 bytes\",\"二进制形式的中等长度文本数据\",\"MEDIUMTEXT\",\"0-16 777 215 bytes\",\"中等长度文本数据\",\"LONGBLOB\",\"0-4 294 967 295 bytes\",\"二进制形式的极大文本数据\",\"LONGTEXT\",\"0-4 294 967 295 bytes\",\"极大文本数据\",\"char 与 varchar 都可以描述字符串，char 是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。 而 varchar 是变长字符串，指定的长度为最大占用长度 。相对来说，char 的性能会更高些。\",\"示例： 用户名 username ---长度不定, 最长不会超过50 username varchar(50) 手机号 phone ---固定长度为11 phone char(11)\",\"日期时间类型\",\"类型\",\"大小\",\"范围\",\"格式\",\"描述\",\"DATE\",\"3\",\"1000-01-01 至 9999-12-31\",\"YYYY-MM-DD\",\"日期值\",\"TIME\",\"3\",\"-838:59:59 至 838:59:59\",\"HH:MM:SS\",\"时间值或持续时间\",\"YEAR\",\"1\",\"1901 至 2155\",\"YYYY\",\"年份值\",\"DATETIME\",\"8\",\"1000-01-01 00:00:00 至 9999-12-31 23:59:59\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值\",\"TIMESTAMP\",\"4\",\"1970-01-01 00:00:01 至 2038-01-19 03:14:07\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值，时间戳\"]},\"184\":{\"h\":\"2.2.2 查询\",\"t\":[\"查询当前数据库所有表\",\"show tables;\",\"查看指定表结构\",\"desc 表名 ; #可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息\",\"查询指定表的建表语句\",\"show create table 表名 ;\"]},\"185\":{\"h\":\"2.2.3 修改\",\"t\":[\"添加字段\",\"alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];\",\"案例： 为 tb_emp 表添加字段 qq，字段类型为 varchar(11)\",\"alter table tb_emp add qq varchar(11) comment 'QQ号码';\",\"修改数据类型\",\"alter table 表名 modify 字段名 新数据类型(长度);\",\"alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];\",\"案例：修改 qq 字段名为 qq_num，字段类型 varchar(13)\",\"alter table tb_emp change qq qq_num varchar(13) comment 'QQ号码';\",\"删除字段\",\"alter table 表名 drop 字段名;\",\"修改表名\",\"rename table 表名 to 新表名;\"]},\"186\":{\"h\":\"2.2.4 删除\",\"t\":[\"删除表语法：\",\"drop table [ if exists ] 表名;\",\"if exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\"]},\"187\":{\"h\":\"3. 数据库操作-DML\",\"t\":[\"DML英文全称是 Data Manipulation Language (数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\",\"添加数据（INSERT）\",\"修改数据（UPDATE）\",\"删除数据（DELETE）\"]},\"188\":{\"h\":\"3.1 增加 (insert)\",\"t\":[\"insert 语法：\",\"向指定字段添加数据\",\"insert into 表名 (字段名1, 字段名2) values (值1, 值2);\",\"全部字段添加数据\",\"insert into 表名 values (值1, 值2, ...);\",\"批量添加数据（指定字段）\",\"insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2);\",\"批量添加数据（全部字段）\",\"insert into 表名 values (值1, 值2, ...), (值1, 值2, ...);\",\"Insert 操作的注意事项：\",\"插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\",\"字符串和日期型数据应该包含在引号中。\",\"插入的数据大小，应该在字段的规定范围内。\"]},\"189\":{\"h\":\"3.2 修改 (update)\",\"t\":[\"update 语法：\",\"update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件] ;\",\"案例：将 tb_emp 表中 id 为 1 的员工，姓名 name 字段更新为'张三'\",\"update tb_emp set name='张三',update_time=now() where id=1;\",\"注意事项\",\"修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\",\"在修改数据时，一般需要同时修改公共字段 update_time，将其修改为当前操作时间。\"]},\"190\":{\"h\":\"3.3 删除 (delete)\",\"t\":[\"delete 语法：\",\"delete from 表名 [where 条件] ;\",\"注意事项\",\"DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\",\"DELETE 语句不能删除某一个字段的值(可以使用 UPDATE，将该字段值置为 NULL 即可)。\",\"当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击 Execute 即可。\"]},\"191\":{\"h\":\"4. 数据库操作-DQL\"},\"192\":{\"h\":\"4.1 语法\",\"t\":[\"DQL 查询语句，语法结构如下：\",\"SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数\",\"查询分为以下几种类型：\",\"基本查询（不带任何条件）\",\"条件查询（where）\",\"分组查询（group by）\",\"排序查询（order by）\",\"分页查询（limit）\"]},\"193\":{\"h\":\"4.2 基本查询\",\"t\":[\"在基本查询的 DQL 语句中，不带任何的查询条件，语法如下：\",\"查询多个字段\",\"select 字段1, 字段2, 字段3 from 表名;\",\"查询所有字段（通配符）\",\"select * from 表名;\",\"设置别名\",\"select 字段1 [ as 别名1 ] , 字段2 [ as 别名2 ] from 表名;\",\"去除重复记录\",\"select distinct 字段列表 from 表名;\"]},\"194\":{\"h\":\"4.3 条件查询\",\"t\":[\"语法：\",\"select 字段列表 from 表名 where 条件列表 ; -- 条件列表：意味着可以有多个条件\",\"在SQL语句当中构造条件的运算符分为两类：\",\"比较运算符\",\"逻辑运算符\",\"常用的比较运算符如下:\",\"比较运算符\",\"功能\",\">\",\"大于\",\">=\",\"大于等于\",\"<\",\"小于\",\"<=\",\"小于等于\",\"=\",\"等于\",\"<> 或 !=\",\"不等于\",\"between ... and ...\",\"在某个范围之内(含最小、最大值)\",\"in(...)\",\"在in之后的列表中的值，多选一\",\"like 占位符\",\"模糊匹配(_匹配单个字符, %匹配任意个字符)\",\"is null\",\"是null\",\"常用的逻辑运算符如下:\",\"逻辑运算符\",\"功能\",\"and 或 &&\",\"并且 (多个条件同时成立)\",\"or 或 ||\",\"或者 (多个条件任意一个成立)\",\"not 或 !\",\"非 , 不是\"]},\"195\":{\"h\":\"4.4 聚合函数\",\"t\":[\"使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）\",\"语法：\",\"select 聚合函数(字段列表) from 表名 ;\",\"注意 : 聚合函数会忽略空值，对NULL值不作为统计。\",\"常用聚合函数：\",\"函数\",\"功能\",\"count\",\"统计数量\",\"max\",\"最大值\",\"min\",\"最小值\",\"avg\",\"平均值\",\"sum\",\"求和\",\"说明\",\"count ：按照列去统计有多少行数据。\",\"在根据指定的列统计的时候，如果这一列中有 null 的行，该行不会被统计在其中。\",\"sum ：计算指定列的数值和，如果不是数值类型，那么计算结果为0\",\"max ：计算指定列的最大值\",\"min ：计算指定列的最小值\",\"avg ：计算指定列的平均值\"]},\"196\":{\"h\":\"4.5 分组查询\",\"t\":[\"分组： 按照某一列或者某几列，把相同的数据进行合并输出。\",\"分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。\",\"分组查询通常会使用聚合函数进行计算。\",\"语法：\",\"select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\",\"注意事项\",\"分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\",\"执行顺序：where > 聚合函数 > having\",\"where 与 having 区别（面试题）\",\"执行时机不同：where 是分组之前进行过滤，不满足 where 条件，不参与分组；而 having 是分组之后对结果进行过滤。\",\"判断条件不同：where 不能对聚合函数进行判断，而 having 可以。\"]},\"197\":{\"h\":\"4.6 排序查询\",\"t\":[\"排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\",\"语法：\",\"select 字段列表 from 表名 [where 条件列表] [group by 分组字段 ] order by 字段1 排序方式1 , 字段2 排序方式2 … ;\",\"排序方式：\",\"ASC ：升序（默认值）\",\"DESC：降序\",\"注意事项：如果是升序, 可以不指定排序方式ASC\"]},\"198\":{\"h\":\"4.7 分页查询\",\"t\":[\"分页操作在业务系统开发时，也是非常常见的一个功能，日常我们在网站中看到的各种各样的分页条，后台也都需要借助于数据库的分页操作。\",\"分页查询语法：\",\"select 字段列表 from 表名 limit 起始索引, 查询记录数 ;\",\"注意事项\",\"起始索引从 0 开始。\",\"计算公式：起始索引 = （查询页码 - 1）* 每页显示记录数\",\"分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 LIMIT\",\"如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 条数\",\"前端查询数据库的流程：\",\"前端在请求服务端时，传递的参数 \",\"当前页码 page\",\"每页显示条数 pageSize\",\"后端需要响应什么数据给前端 \",\"所查询到的数据列表（存储到 List 集合中）\",\"总记录数\",\"示例\",\"后台给前端返回的数据包含：List 集合（数据列表）、total（总记录数）\",\"当数据量较大时，通常封装到 PageBean 对象中，并将该对象转换为 json 格式的数据响应回给浏览器。\",\"@Data @NoArgsConstructor @AllArgsConstructor public class PageBean { private Long total; // 总记录数 private List rows; // 当前页数据列表 }\"]},\"199\":{\"h\":\"5. 多表设计\",\"t\":[\"项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\",\"一对多（多对一）\",\"多对多\",\"一对一\"]},\"200\":{\"h\":\"5.1 一对多 - 外键约束\",\"t\":[\"一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。\",\"外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。\",\"对应的关键字：foreign key\",\"语法：\",\"-- 创建表时指定 create table 表名( 字段名 数据类型, ... [constraint] [外键名称] foreign key (外键字段名) references 主表 (主表列名) ); -- 建完表后，添加外键 alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);\",\"物理外键和逻辑外键\",\"物理外键\",\"概念：使用 foreign key 定义外键关联另外一张表。\",\"缺点： \",\"影响增、删、改的效率（需要检查外键关系）。\",\"仅用于单节点数据库，不适用与分布式、集群场景。\",\"容易引发数据库的死锁问题，消耗性能。\",\"逻辑外键\",\"概念：在业务层逻辑中，解决外键关联。\",\"通过逻辑外键，就可以很方便的解决上述问题。\",\"在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key\"]},\"201\":{\"h\":\"5.2 一对一\",\"t\":[\"一对一关系表在实际开发中应用起来比较简单，通常是用来做单表的拆分，也就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他的字段放在另外一张表当中，以此来提高数据的操作效率。\",\"一对一的应用场景：用户表(基本信息+身份信息)\",\"基本信息：用户的ID、姓名、性别、手机号、学历\",\"身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间)\",\"如果在业务系统当中，对用户的基本信息查询频率特别的高，但是对于用户的身份信息查询频率很低，此时出于提高查询效率的考虑，可以将这张大表拆分成两张小表，第一张表存放的是用户的基本信息，而第二张表存放的就是用户的身份信息。他们两者之间一对一的关系，一个用户只能对应一个身份证，而一个身份证也只能关联一个用户。\",\"那么在数据库层面怎么去体现上述两者之间是一对一的关系呢？\",\"其实一对一我们可以看成一种特殊的一对多。一对多我们是怎么设计表关系的？是不是在多的一方添加外键。同样我们也可以通过外键来体现一对一之间的关系，我们只需要在任意一方来添加一个外键就可以了。\",\"一对一 ：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 (UNIQUE)\"]},\"202\":{\"h\":\"5.3 多对多\",\"t\":[\"多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。\",\"案例：学生与课程的关系\",\"关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\",\"实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\"]},\"203\":{\"h\":\"6. 多表查询\"},\"204\":{\"h\":\"6.1 概述\"},\"205\":{\"h\":\"6.1.1 介绍\",\"t\":[\"多表查询：查询时从多张表中获取所需数据\",\"多表查询\",\"单表查询的 SQL 语句：select 字段列表 from 表名;\",\"那么要执行多表查询，只需要使用逗号分隔多张表即可，如：select 字段列表 from 表1, 表2;\",\"查询用户表和部门表中的数据：\",\"select * from tb_emp , tb_dept;\",\"笛卡尔积：笛卡尔乘积是指在数学中，两个集合（A 集合和 B 集合）的所有组合情况。\",\"在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据。\",\"在查询时给多表查询加上连接查询的条件：\",\"select * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ;\"]},\"206\":{\"h\":\"6.1.2 分类\",\"t\":[\"多表查询可以分为：\",\"连接查询\",\"内连接：相当于查询 A、B 交集部分数据\",\"外连接\",\"左外连接：查询左表所有数据(包括两张表交集部分数据)\",\"右外连接：查询右表所有数据(包括两张表交集部分数据)\",\"子查询\"]},\"207\":{\"h\":\"6.3 内连接\",\"t\":[\"内连接查询：查询两表或多表中交集部分数据。\",\"内连接从语法上可以分为：\",\"隐式内连接\",\"显式内连接\",\"隐式内连接语法：\",\"select 字段列表 from 表1 , 表2 where 条件 ... ;\",\"显式内连接语法：\",\"select 字段列表 from 表1 [ inner ] join 表2 on 连接条件 ... ;\",\"多表查询时给表起别名：\",\"- tableA as 别名1, tableB as 别名2 ; - tableA 别名1, tableB 别名2 ;\",\"注意事项\",\"一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\"]},\"208\":{\"h\":\"6.3 外连接\",\"t\":[\"外连接分为两种：左外连接 和 右外连接。\",\"左外连接语法结构：\",\"select 字段列表 from 表1 left [ outer ] join 表2 on 连接条件 ... ;\",\"左外连接相当于查询表1（左表）的所有数据，当然也包含表1和表2交集部分的数据。\",\"右外连接语法结构：\",\"select 字段列表 from 表1 right [ outer ] join 表2 on 连接条件 ... ;\",\"右外连接相当于查询表2（右表）的所有数据，当然也包含表1和表2交集部分的数据。\",\"注意事项\",\"左外连接和右外连接是可以相互替换的，只需要调整连接查询时 SQL 语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\"]},\"209\":{\"h\":\"6.4 子查询\"},\"210\":{\"h\":\"6.4.1 介绍\",\"t\":[\"SQL 语句中嵌套 select 语句，称为嵌套查询，又称子查询。\",\"SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ... );\",\"子查询外部的语句可以是 insert / update / delete / select 的任何一个，最常见的是 select.\",\"根据子查询结果的不同分为：\",\"标量子查询（子查询结果为单个值「一行一列」）\",\"列子查询（子查询结果为一列，但可以是多行）\",\"行子查询（子查询结果为一行，但可以是多列）\",\"表子查询（子查询结果为多行多列「相当于子查询结果是一张表」）\",\"子查询可以书写的位置：\",\"where 之后\",\"from 之后\",\"select 之后\"]},\"211\":{\"h\":\"6.4.2 标量子查询\",\"t\":[\"子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。\",\"常用的操作符： =<>>>=<<=\"]},\"212\":{\"h\":\"6.4.3 列子查询\",\"t\":[\"子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。\",\"常用的操作符：\",\"操作符\",\"描述\",\"IN\",\"在指定的集合范围之内，多选一\",\"NOT IN\",\"不在指定的集合范围之内\"]},\"213\":{\"h\":\"6.4.4 行子查询\",\"t\":[\"子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。\",\"常用的操作符：= 、<> 、IN 、NOT IN\"]},\"214\":{\"h\":\"6.4.5 表子查询\",\"t\":[\"子查询返回的结果是多行多列，常作为临时表，这种子查询称为表子查询。\"]},\"215\":{\"h\":\"7. 事务\"},\"216\":{\"h\":\"7.1 介绍\",\"t\":[\"在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条 SQL 语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的 SQL 语句全部执行成功。如果其中有一条 SQL 语句失败，就进行事务的回滚，所有的 SQL 语句全部执行失败。\",\"简而言之：事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\",\"事务作用：保证在一个事务中多次操作数据库表中数据时，要么全都成功,要么全都失败。\"]},\"217\":{\"h\":\"7.2 操作\",\"t\":[\"MYSQL中有两种方式进行事务的操作：\",\"自动提交事务：即执行一条 sql 语句提交一次事务。（默认 MySQL 的事务是自动提交）\",\"手动提交事务：先开启，再提交\",\"事务操作有关的 SQL 语句：\",\"SQL语句\",\"描述\",\"start transaction; / begin ;\",\"开启手动控制事务\",\"commit;\",\"提交事务\",\"rollback;\",\"回滚事务\",\"手动提交事务使用步骤：\",\"第1种情况：开启事务 => 执行SQL语句 => 成功 => 提交事务\",\"第2种情况：开启事务 => 执行SQL语句 => 失败 => 回滚事务\"]},\"218\":{\"h\":\"7.3 四大特性\",\"t\":[\"原子性（Atomicity） ：原子性是指事务包装的一组 sql 是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。\",\"一致性（Consistency）：一个事务完成之后数据都必须处于一致性状态。\",\"如果事务成功的完成，那么数据库的所有变化将生效。\",\"如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。\",\"隔离性（Isolation）：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。\",\"一个事务的成功或者失败对于其他的事务是没有影响。\",\"持久性（Durability）：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。\",\"关键\",\"面试题：事务有哪些特性？\",\"原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。\",\"一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\",\"隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\",\"持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\",\"事务的四大特性简称为：ACID\"]},\"219\":{\"h\":\"8. 索引\"},\"220\":{\"h\":\"8.1 介绍\",\"t\":[\"索引 index ：是帮助数据库高效获取数据的数据结构 。\",\"简单来讲，就是使用索引可以提高查询的效率。\",\"优点：\",\"提高数据查询的效率，降低数据库的 IO 成本。\",\"通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 消耗。\",\"缺点：\",\"索引会占用存储空间。\",\"索引大大提高了查询效率，同时却也降低了 insert、update、delete 的效率。\"]},\"221\":{\"h\":\"8.2 结构\",\"t\":[\"MySQL 数据库支持的索引结构有很多，如：Hash 索引、B+Tree 索引、Full-Text 索引等。\",\"我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\",\"二叉查找树\",\"二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大\",\"二叉查找树\",\"当我们向二叉查找树保存数据时，是按照从大到小（或从小到大）的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。\",\"退化的二叉查找树\",\"可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）\",\"平衡二叉树\",\"但是在 Mysql 数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。\",\"思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？\",\"答案 最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。 因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。 \",\"说明\",\"如果数据结构是红黑树，那么查询 1000 万条数据，根据计算树的高度大概是 23 左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要 23 次磁盘 IO，那么 100 万用户，那么会造成效率极其低下。\",\"所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。而 B+Tree 就满足这种要求。\",\"B+Tree（多路平衡搜索树）结构中如何避免这个问题：\",\"B+Tree 结构：\",\"每一个节点，可以存储多个 key（有 n 个 key，就有 n 个指针）\",\"节点分为：叶子节点、非叶子节点 \",\"叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上\",\"非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key + 指针\",\"为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询\",\"拓展\",\"非叶子节点都是由 key + 指针域 组成的，一个 key 占 8 字节，一个指针占 6 字节，而一个节点总共容量是 16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 / (8+6) = 1170 个元素。\",\"查看 mysql 索引节点大小：\",\"show global status like 'innodb_page_size'; -- 节点大小：16384\",\"当根节点中可以存储 1170 个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储 1170 个元素，那么第二层即第二次 IO 的时候就会找到数据大概是：1170∗1170=135W。也就是说 B+Tree 数据结构中只需要经历两次磁盘 IO 就可以找到 135W 条数据。\",\"对于第二层每个元素有指针，那么会找到第三层，第三层由 key + 数据 组成，假设 key + 数据 总大小是 1KB，而每个节点一共能存储 16KB，所以一个第三层一个节点大概可以存储 16 个元素(即 16 条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是 135W 个元素，那么第三层总元素大小就是：135W∗16 结果就是 2000W+ 的元素个数。\",\"结合上述分析 B+Tree 有如下优点：\",\"千万条数据，B+Tree 可以控制在小于等于 3 的高度\",\"所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找\"]},\"222\":{\"h\":\"8.3 语法\",\"t\":[\"创建索引\",\"create [ unique ] index 索引名 on 表名 (字段名,... ) ;\",\"查看索引\",\"show index from 表名;\",\"删除索引\",\"drop index 索引名 on 表名;\",\"注意事项\",\"主键字段，在建表时，会自动创建主键索引\",\"添加唯一约束时，数据库实际上会添加唯一索引\"]},\"223\":{\"c\":[\"MySQL\"]},\"224\":{\"c\":[\"基础\"]},\"225\":{\"h\":\"哈希表\"},\"226\":{\"h\":\"哈希表的工作原理\",\"t\":[\"哈希表（Hash Table），也称为散列表，是一种通过哈希函数将键（Key）映射到表中一个位置以便存储和检索数据的数据结构。其工作原理主要包括以下几个步骤：\",\"哈希函数：哈希表使用一个哈希函数来计算键的哈希值。这个哈希值是一个整数，它表示了该键在哈希表中存储的位置（即索引）。\",\"处理冲突：理想情况下，哈希函数会为每个键生成一个唯一的哈希值，但在实际应用中，不同的键可能会产生相同的哈希值，这种现象称为冲突。哈希表通过以下几种方法来处理冲突：\",\"链地址法（Separate Chaining）：每个哈希表的槽位（slot）都链接一个链表，所有具有相同哈希值的元素都存储在这个链表中。\",\"开放寻址法（Open Addressing）：当冲突发生时，哈希表会在表中寻找下一个空闲位置来存储元素。常见的探测方法包括线性探测、二次探测和双重散列。\",\"插入操作：向哈希表中添加元素时，首先计算元素键的哈希值，然后根据哈希值将元素存储在表中适当的位置。\",\"查找操作：检索元素时，同样先计算键的哈希值，然后根据哈希值快速定位到元素在表中的位置，如果存在冲突，则通过冲突解决策略找到元素。\",\"删除操作：删除元素时，首先找到元素的位置，然后从该位置移除元素，并可能需要处理冲突链表或调整开放寻址中的空闲位置。\"]},\"227\":{\"h\":\"优点\",\"t\":[\"高效的数据检索：在理想情况下，哈希表可以在常数时间 (O(1)) 内完成插入、查找和删除操作。\",\"动态大小：哈希表可以根据需要动态调整大小，以适应数据的增减。\",\"键值对存储：哈希表支持键值对的存储方式，使得数据的存储和检索更加灵活。\",\"灵活的键类型：可以使用各种类型的键，包括整数、字符串等。\"]},\"228\":{\"h\":\"缺点\",\"t\":[\"冲突问题：冲突可能导致性能下降，特别是在冲突解决策略不够高效时。\",\"空间效率：为了减少冲突，哈希表通常需要预留一定比例的空闲空间，这可能导致空间的浪费。\",\"哈希函数的选择：一个不好的哈希函数可能导致性能下降，特别是在面对不理想的数据分布时。\",\"负载因子的调整：负载因子（表中元素数量与槽位数的比值）需要适时调整，以保持操作的效率，这可能需要重新哈希和复制整个表。\",\"不是有序的：哈希表不保证元素的顺序，如果需要有序的数据，可能需要额外的逻辑或使用其他数据结构。\",\"哈希表是一种非常实用的数据结构，适用于需要快速查找、插入和删除操作的场景。然而，设计和使用哈希表时需要仔细考虑哈希函数的选择、冲突解决策略以及负载因子的调整等问题。\"]},\"229\":{\"c\":[\"Java\"]},\"230\":{\"c\":[\"基础\"]},\"231\":{\"h\":\"Java 基础知识\"},\"232\":{\"h\":\"一、语法基础\"},\"233\":{\"h\":\"1.1 变量\",\"t\":[\"变量必须先定义，才可以使用。不能重名。\",\"变量定义的方式：\",\"public class Main { public static void main(String[] args) { int a = 5; int b, c = a, d = 10 / 2; } }\",\"内置数据类型：\",\"类型\",\"字节数\",\"举例\",\"byte\",\"1\",\"123\",\"short\",\"2\",\"12345\",\"int\",\"4\",\"123456789\",\"long\",\"8\",\"1234567891011L\",\"float\",\"4\",\"1.2F\",\"double\",\"8\",\"1.2, 1.2D\",\"boolean\",\"1\",\"true, false\",\"char\",\"2\",\"‘A’\",\"常量：\",\"使用final修饰：\",\"final int N = 110;\",\"类型转化：\",\"显示转化：int x = (int)'A';\",\"隐式转化：double x = 12, y = 4 * 3.3;\"]},\"234\":{\"h\":\"1.2 运算符\",\"t\":[\"A = 10, B = 20\",\"运算符\",\"描述\",\"实例\",\"+\",\"把两个数相加\",\"A + B 将得到 30\",\"-\",\"从第一个数中减去第二个数\",\"A - B 将得到 -10\",\"*\",\"把两个数相乘\",\"A * B 将得到 200\",\"/\",\"分子除以分母\",\"B / A 将得到 2\",\"%\",\"取模运算符，向零整除后的余数，注意余数可能为负数\",\"B % A 将得到 0\",\"++\",\"自增运算符\",\"A++：先取值后加1；++A：先加1后取值\",\"--\",\"自减运算符\",\"A--：先取值后减1；--A：先减1后取值\",\"+=\",\"第一个数加上第二个数\",\"A = A + B 可以简写为 A += B\",\"-=\",\"第一个数减去第二个数\",\"A = A - B 可以简写为 A -= B\",\"*=\",\"第一个数乘以第二个数\",\"A = A * B 可以简写为 A *= B\",\"/=\",\"第一个数除以第二个数\",\"A = A / B 可以简写为 A /= B\",\"%=\",\"第一个对第二个数取余数\",\"A = A % B 可以简写为 A %= B\"]},\"235\":{\"h\":\"1.3 表达式\",\"t\":[\"整数的加减乘除四则运算：\",\"public class Main { public static void main(String[] args) { int a = 6 + 3 * 4 / 2 - 2; System.out.println(a); int b = a * 10 + 5 / 2; System.out.println(b); System.out.println(23 * 56 - 78 / 3); } }\",\"浮点数（小数）的运算：\",\"public class Main { public static void main(String[] args) { double x = 1.5, y = 3.2; System.out.println(x * y); System.out.println(x + y); System.out.println(x - y); System.out.println(x / y); } }\",\"整型变量的自增、自减：\",\"public class Main { public static void main(String[] args) { int a = 1; int b = a ++ ; System.out.println(a + \\\" \\\" + b); int c = ++ a; System.out.println(a + \\\" \\\" + c); } }\"]},\"236\":{\"h\":\"1.4 输入\",\"t\":[\"方式1：效率较低，输入规模较小时使用。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); String str = sc.next(); // 读入下一个字符串 int x = sc.nextInt(); // 读入下一个整数 float y = sc.nextFloat(); // 读入下一个单精度浮点数 double z = sc.nextDouble(); // 读入下一个双精度浮点数 String line = sc.nextLine(); // 读入下一行 } }\",\"方式2：效率较高，输入规模较大时使用。注意需要抛异常。\",\"import java.io.BufferedReader; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); System.out.println(str); } }\"]},\"237\":{\"h\":\"1.5 输出\",\"t\":[\"方式1：效率较低，输出规模较小时使用。\",\"public class Main { public static void main(String[] args) throws Exception { System.out.println(123); // 输出整数 + 换行 System.out.println(\\\"Hello World\\\"); // 输出字符串 + 换行 System.out.print(123); // 输出整数 System.out.print(\\\"yxc\\\\n\\\"); // 输出字符串 System.out.printf(\\\"%04d %.2f\\\\n\\\", 4, 123.456D); // 格式化输出，float与double都用%f输出 } }\",\"System.out.printf() 中不同类型变量的输出格式：\",\"(1) int：%d (2) float: %f, 默认保留6位小数 (3) double: %f， 默认保留6位小数 (4) char: %c, 回车也是一个字符，用 '\\\\n' 表示 (5) String: %s\",\"方式2：效率较高，输出规模较大时使用。注意需要抛异常。\",\"import java.io.BufferedWriter; import java.io.OutputStreamWriter; public class Main { public static void main(String[] args) throws Exception { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); bw.write(\\\"Hello World\\\\n\\\"); bw.flush(); // 需要手动刷新缓冲区 } }\"]},\"238\":{\"h\":\"二、判断语句\",\"t\":[\"学习语言最好的方式就是实践，每当掌握一个新功能时，就要立即将这个功能应用到实践中。——闫学灿\"]},\"239\":{\"h\":\"2.1 if 语句\",\"t\":[\"基本 if-else 语句\",\"当条件成立时，执行某些语句；否则执行另一些语句。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) { System.out.printf(\\\"%d is big!\\\\n\\\", a); System.out.printf(\\\"%d + 1 = %d\\\\n\\\", a, a + 1); } else { System.out.printf(\\\"%d is small!\\\\n\\\", a); System.out.printf(\\\"%d - 1 = %d\\\\n\\\", a, a - 1); } } }\",\"else 语句可以省略：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) { System.out.printf(\\\"%d is big!\\\\n\\\", a); System.out.printf(\\\"%d + 1 = %d\\\\n\\\", a, a + 1); } } }\",\"当只有一条语句时，大括号可以省略：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) System.out.printf(\\\"%d is big!\\\\n\\\", a); else System.out.printf(\\\"%d is small!\\\\n\\\", a); } }\",\"练习：输入一个整数，输出这个数的绝对值。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); if (x > 0) System.out.println(x); else System.out.println(-x); } }\",\"练习：输入两个整数，输出两个数中较大的那个。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(); if (a > b) System.out.println(a); else System.out.println(b); } }\",\"if-else 语句内部也可以是 if-else 语句。\",\"练习：输入三个整数，输出三个数中最大的那个。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(); if (a > b) { if (a > c) System.out.println(a); else System.out.println(c); } else { if (b > c) System.out.println(b); else System.out.println(c); } } }\",\"常用比较运算符\",\"(1) 大于 > (2) 小于 < (3) 大于等于 >= (4) 小于等于 <= (5) 等于 == (6) 不等于 !=\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(); if (a > b) System.out.printf(\\\"%d > %d\\\\n\\\", a, b); if (a >= b) System.out.printf(\\\"%d >= %d\\\\n\\\", a, b); if (a < b) System.out.printf(\\\"%d < %d\\\\n\\\", a, b); if (a <= b) System.out.printf(\\\"%d <= %d\\\\n\\\", a, b); if (a == b) System.out.printf(\\\"%d == %d\\\\n\\\", a, b); if (a != b) System.out.printf(\\\"%d != %d\\\\n\\\", a, b); } }\",\"if-else连写：\",\"输入一个0到100之间的分数， 如果大于等于85，输出A； 如果大于等于70并且小于85，输出B； 如果大于等于60并且小于70，输出C； 如果小于60，输出 D；\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int s = sc.nextInt(); if (s >= 85) { System.out.println(\\\"A\\\"); } else if (s >= 70) { System.out.println(\\\"B\\\"); } else if (s >= 60) { System.out.println(\\\"C\\\"); } else { System.out.println(\\\"D\\\"); } } }\",\"练习：\",\"1.判断闰年。闰年有两种情况： (1) 能被100整除时，必须能被400整除； (2) 不能被100整除时，被4整除即可。 输入一个年份，如果是闰年输出yes，否则输出no。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int year = sc.nextInt(); if (year % 100 == 0) { if (year % 400 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } else { if (year % 4 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } } }\"]},\"240\":{\"h\":\"2.2 条件表达式\",\"t\":[\"​ (1) 与 && ​ (2) 或 || ​ (3) 非!\",\"例题：输入三个数，输出三个数中的最大值。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(); if (a >= b && a >= c) System.out.println(a); else if (b >= a && b >= c) System.out.println(b); else System.out.println(c); } }\",\"练习：用一条 if 语句，判断闰年。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int year = sc.nextInt(); if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } }\"]},\"241\":{\"h\":\"2.3 switch 语句\",\"t\":[\"注意： swtich 语句中如果不加 break 语句，则从上到下匹配到第一个 case 后，会顺次执行后面每个 case 中的语句。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int day = sc.nextInt(); String name; switch(day) { case 1: name = \\\"Monday\\\"; break; case 2: name = \\\"Tuesday\\\"; break; case 3: name = \\\"Wednesday\\\"; break; case 4: name = \\\"Thursday\\\"; break; case 5: name = \\\"Friday\\\"; break; case 6: name = \\\"Saturday\\\"; break; case 7: name = \\\"Sunday\\\"; break; default: name = \\\"not valid\\\"; } System.out.println(name); } }\"]},\"242\":{\"h\":\"三、循环语句\",\"t\":[\"学习编程语言语法是次要的，思维是主要的。如何把头脑中的想法变成简洁的代码，至关重要。——闫学灿\",\"学习循环语句只需要抓住一点 —— 代码执行顺序！\"]},\"243\":{\"h\":\"3. 1 while 循环\",\"t\":[\"可以简单理解为循环版的 if 语句。if 语句是判断一次，如果条件成立，则执行后面的语句；\",\"while 是每次判断，如果成立，则执行循环体中的语句，否则停止。\",\"public class Main { public static void main(String[] args) { int i = 0; while (i < 10) { System.out.println(i); i ++ ; } } }\",\"练习：求 1~100 中所有数的立方和。\",\"public class Main { public static void main(String[] args) { int i = 1, sum = 0; while (i <= 100) { sum += i * i * i; i ++ ; } System.out.println(sum); } }\",\"练习：求斐波那契数列的第 n 项。f(1)=1,f(2)=1,f(3)=2,f(n)=f(n−1)+f(n−2)。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int a = 1, b = 1, i = 1; while (i < n) { int c = a + b; a = b; b = c; i ++ ; } System.out.println(a); } }\",\"死循环：循环永久执行，无法结束。我们要避免写出死循环。\",\"public class Main { public static void main(String[] args) { int x = 1; while (x == 1) System.out.println(\\\"!\\\"); } }\"]},\"244\":{\"h\":\"3.2 do while 循环\",\"t\":[\"do while 循环不常用。\",\"do while语句与 while 语句非常相似。唯一的区别是，do while 语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。\",\"public class Main { public static void main(String[] args) { int x = 1; while (x < 1) { System.out.println(\\\"x!\\\"); } int y = 1; do { System.out.println(\\\"y!\\\"); } while (y < 1); } }\"]},\"245\":{\"h\":\"3.3 for 循环\",\"t\":[\"基本思想：把控制循环次数的变量从循环体中剥离。\",\"for (init-statement; condition; expression) { statement }\",\"init-statement 可以是声明语句、表达式、空语句，一般用来初始化循环变量；\",\"condition 是条件表达式，和 while 中的条件表达式作用一样；可以为空，空语句表示true；\",\"expression 一般负责修改循环变量，可以为空。\",\"public class Main { public static void main(String[] args) { for (int i = 0; i < 10; i ++ ) { // 循环体中只有一条语句时，可以不加大括号 System.out.println(i); } } }\",\"练习：求 1~100 中所有数的立方和。\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1; i <= 100; i ++ ) sum += i * i * i; System.out.println(sum); } }\",\"练习：求斐波那契数列的第 n 项。f(1)=1,f(2)=1,f(3)=2,f(n)=f(n−1)+f(n−2)。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int a = 1, b = 1; for (int i = 1; i < n; i ++ ) { int c = a + b; a = b; b = c; } System.out.println(a); } }\",\"init-statement 可以定义多个变量，expression 也可以修改多个变量。\",\"例如求 1 * 10 + 2 * 9 + 3 * 8 + 4 * 7 + 5 * 6：\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1, j = 10; i < j; i ++, j -- ) { sum += i * j; } System.out.println(sum); } }\"]},\"246\":{\"h\":\"3.4 跳转语句\"},\"247\":{\"h\":\"3.4.1 break\",\"t\":[\"可以提前从循环中退出，一般与 if 语句搭配。\",\"例题：判断一个大于 1 的数是否是质数：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); boolean isPrime = true; for (int i = 2; i < n; i ++ ) if (n % i == 0) { isPrime = false; break; } if (isPrime) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } }\"]},\"248\":{\"h\":\"3.4.2 continue\",\"t\":[\"可以直接跳到当前循环体的结尾。作用与 if 语句类似。\",\"例题：求 1~100 中所有偶数的和。\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1; i <= 100; i ++ ) { if (i % 2 == 1) continue; sum += i; } System.out.println(sum); } }\"]},\"249\":{\"h\":\"3.5 多层循环\",\"t\":[\"将 1~100 打印到一个 10×10 的矩阵中：\",\"public class Main { public static void main(String[] args) { for (int i = 0, k = 1; i < 10; i ++ ) { for (int j = 0; j < 10; j ++, k ++ ) { System.out.printf(\\\"%d \\\", k); } System.out.println(); } } }\",\"练习：打印 1~100 中的所有质数\",\"public class Main { public static void main(String[] args) { for (int i = 2; i <= 100; i ++ ) { boolean isPrime = true; for (int j = 2; j < i; j ++ ) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) System.out.println(i); } } }\"]},\"250\":{\"h\":\"四、数组\",\"t\":[\"程序 = 逻辑 + 数据，数组是存储数据的强而有力的手段。 ——闫学灿\"]},\"251\":{\"h\":\"4.1 一维数组\"},\"252\":{\"h\":\"4.1.1 数组的定义\",\"t\":[\"数组的定义方式和变量类似。\",\"public class Main { public static void main(String[] args) { int[] a = new int[10], b; float[] f = new float[33]; double[] d = new double[123]; char[] c = new char[21]; } }\"]},\"253\":{\"h\":\"4.1.2 数组的初始化\",\"t\":[\"public class Main { public static void main(String[] args) { int[] a = {0, 1, 2}; // 含有3个元素的数组，元素分别是0, 1, 2 int[] b = new int[3]; // 含有3个元素的数组，元素的值均为0 char[] d = {'a', 'b', 'c'}; // 字符数组的初始化 } }\"]},\"254\":{\"h\":\"4.1.3 访问数组元素\",\"t\":[\"通过下标访问数组。\",\"public class Main { public static void main(String[] args) { int[] a = {0, 1, 2}; // 数组下标从0开始 System.out.printf(\\\"%d %d %d\\\\n\\\", a[0], a[1], a[2]); a[0] = 5; System.out.println(a[0]); } }\",\"练习题1： 使用数组实现求斐波那契数列的第 N 项。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] f = new int[n + 1]; f[0] = 0; f[1] = 1; for (int i = 2; i <= n; i ++ ) f[i] = f[i - 1] + f[i - 2]; System.out.println(f[n]); } }\",\"练习题2：输入一个 n，再输入 n 个整数。将这 n 个整数逆序输出。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i ++ ) a[i] = sc.nextInt(); for (int i = n - 1; i >= 0; i -- ) System.out.printf(\\\"%d \\\", a[i]); } }\",\"练习题3：输入 n 个数，将这 n 个数按从小到大的顺序输出。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i ++ ) a[i] = sc.nextInt(); for (int i = 0; i < n; i ++ ) for (int j = i + 1; j < n; j ++ ) if (a[i] > a[j]) { int t = a[i]; a[i] = a[j]; a[j] = t; } for (int i = 0; i < n; i ++ ) System.out.printf(\\\"%d \\\", a[i]); } }\"]},\"255\":{\"h\":\"4.2 多维数组\",\"t\":[\"多维数组就是数组的数组。\",\"public class Main { public static void main(String[] args) { int[][] a = new int[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组。 int[][][] b = new int[10][20][30]; // 将所有元素的初值为0 // 大小为10的数组，它的每个元素是含有20个数组的数组 // 这些数组的元素是含有30个整数的数组 } } public class Main { public static void main(String[] args) { int[][] a = { // 三个元素，每个元素都是大小为4的数组 {0, 1, 2, 3}, // 第1行的初始值 {4, 5, 6, 7}, // 第2行的初始值 {8, 9, 10, 11} // 第3行的初始值 }; for (int i = 0; i < 4; i ++ ) // 将第一行全部变成0 a[0][i] = 0; for (int i = 0; i < 3; i ++ ) { // 输出二维数组 for (int j = 0; j < 4; j ++ ) { System.out.printf(\\\"%d \\\", a[i][j]); } System.out.println(); } } }\"]},\"256\":{\"h\":\"4.3 数组的范围遍历\",\"t\":[\"import java.util.Scanner; public class Main { public static void main(String[] args) { int[][] a = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}, }; for (int[] row: a) { // 范围遍历 for (int x: row) // 范围遍历 System.out.printf(\\\"%d \\\", x); System.out.println(); } } }\"]},\"257\":{\"h\":\"4.3 常用API\",\"t\":[\"属性length：返回数组长度，注意不加小括号\",\"Arrays.sort()：数组排序\",\"Arrays.fill(int[] a, int val)：填充数组\",\"Arrays.toString()：将数组转化为字符串\",\"Arrays.deepToString()：将多维数组转化为字符串\",\"数组不可变长\",\"使用Arrays需要import java.util.Arrays\"]},\"258\":{\"h\":\"五、字符串\",\"t\":[\"字符串是计算机与人类沟通的重要手段。——闫学灿\"]},\"259\":{\"h\":\"5.1 字符与整数的联系——ASCII码\",\"t\":[\"每个常用字符都对应一个 -128 ~ 127 的数字，二者之间可以相互转化。\",\"注意：目前负数没有与之对应的字符。\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { char c = 'a'; System.out.println((int)c); int a = 66; System.out.println((char)a); } }\",\"常用ASCII值：'A'- 'Z'是65 ~ 90，'a' - 'z'是97 - 122，0 - 9是 48 - 57。 字符可以参与运算，运算时会将其当做整数：\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { int a = 'B' - 'A'; int b = 'A' * 'B'; char c = 'A' + 2; System.out.println(a); System.out.println(b); System.out.println(c); } }\"]},\"260\":{\"h\":\"5.2 String 类\",\"t\":[\"初始化：\",\"String a = \\\"Hello World\\\"; String b = \\\"My name is \\\"; String x = b; // 存储到了相同地址 String c = b + \\\"yxc\\\"; // String可以通过加号拼接 String d = \\\"My age is \\\" + 18; // int会被隐式转化成字符串\\\"18\\\" String str = String.format(\\\"My age is %d\\\", 18); // 格式化字符串，类似于C++中的sprintf String money_str = \\\"123.45\\\"; double money = Double.parseDouble(money_str); // String转double\",\"只读变量，不能修改，例如：\",\"String a = \\\"Hello \\\"; a += \\\"World\\\"; // 会构造一个新的字符串\",\"访问String中的字符：\",\"String str = \\\"Hello World\\\"; for (int i = 0; i < str.length(); i ++ ) { System.out.print(str.charAt(i)); // 只能读取，不能写入 }\",\"常用API：\",\"length()：返回长度\",\"charAt(i)：字符串的第i个位置的字符\",\"split(String regex)：分割字符串\",\"String[] strs = sc.nextLine().split(” “);\",\"indexOf(char c)、indexOf(String str)、lastIndexOf(char c)、lastIndexOf(String str)：查找，找不到返回-1\",\"equals()：判断两个字符串是否相等，注意不能直接用==\",\"compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于\",\"startsWith()：判断是否以某个前缀开头\",\"endsWith()：判断是否以某个后缀结尾\",\"trim()：去掉首尾的空白字符\",\"toLowerCase()：全部用小写字符\",\"toUpperCase()：全部用大写字符\",\"replace(char oldChar, char newChar)：替换字符\",\"replace(String oldRegex, String newRegex)：替换字符串\",\"substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串\",\"toCharArray()：将字符串转化成字符数组\",\"reverse()：翻转字符串\",\"范围遍历：\",\"String str = “Hello World”; for ( char c:str.toCharArray()) { System.out.print(c); }\"]},\"261\":{\"h\":\"5.3 输入与输出\",\"t\":[\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str1 = sc.next(); // 输入字符串，遇到空格、回车等空白字符时停止输入 String str2 = sc.nextLine(); // 输入一整行字符串，遇到空格不会停止输入，遇到回车才会停止 System.out.println(str1); // 可以直接输出 System.out.printf(\\\"%s\\\\n\\\", str2); // 也可以格式化输出，用 %s 表示字符串 } }\"]},\"262\":{\"h\":\"5.4 StringBuilder、StringBuffer\",\"t\":[\"String不能被修改，如果打算修改字符串，可以使用StringBuilder和StringBuffer。\",\"StringBuffer线程安全，速度较慢；StringBuilder线程不安全，速度较快。\",\"StringBuilder sb = new StringBuilder(\\\"Hello \\\"); // 初始化 sb.append(\\\"World\\\"); // 拼接字符串 System.out.println(sb); for (int i = 0; i < sb.length(); i ++ ) { sb.setCharAt(i, (char)(sb.charAt(i) + 1)); // 读取和写入字符 } System.out.println(sb);\"]},\"263\":{\"h\":\"六、函数\",\"t\":[\"理解函数，最重要的是理解代码的执行顺序。——闫学灿\"]},\"264\":{\"h\":\"6.1 函数基础\",\"t\":[\"一个典型的函数定义包括以下部分：修饰符、返回类型、函数名字、由0个或多个形参组成的列表以及函数体。\"]},\"265\":{\"h\":\"6.1.1 编写函数\",\"t\":[\"我们来编写一个求阶乘的程序。程序如下所示：\",\"private static int fact(int val) { int res = 1; for (int i = 1; i <= val; i ++ ) res *= i; return res; }\",\"函数名字是 fact，它作用于一个整型参数，返回一个整型值。return 语句负责结束 fact 并返回 res 的值。 修饰符包括 private、static 等，它们属于类相关的概念，会在下一章解释。\"]},\"266\":{\"h\":\"6.1.2 调用函数\",\"t\":[\"public class Main { private static int fact(int val) { int res = 1; for (int i = 1; i <= val; i ++ ) res *= i; return res; } public static void main(String[] args) { int res = fact(5); System.out.printf(\\\"5! is %d\\\\n\\\", res); } }\",\"函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。\"]},\"267\":{\"h\":\"6.1.3 形参和实参\",\"t\":[\"实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，依次类推。形参和实参的类型和个数必须匹配。\",\"fact(\\\"hello\\\"); // 错误：实参类型不正确 fact(); // 错误：实参数量不足 fact(42, 10, 0); // 错误：实参数量过多 fact(' '); // 正确：该实参能自动转换成int类型，' '的ASCII值为32，所以该操作等价于fact(32);\"]},\"268\":{\"h\":\"6.1.4 函数的形参列表\",\"t\":[\"函数的形参列表可以为空，但是不能省略。\",\"void f1() {/* …. */} // 空形参列表\",\"形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：\",\"int f3(int v1, v2) {/* … */} // 错误 int f4(int v1, int v2) {/* … */} // 正确\"]},\"269\":{\"h\":\"6.1.5 函数返回类型\",\"t\":[\"大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void，它表示函数不返回任何值。 函数的返回类型也可以是数组、字符串或者其他对象：\",\"import java.util.Arrays; public class Main { private static int[] newArray() { int[] a = {1, 2, 3}; return a; } private static String newString() { return \\\"Hello World\\\"; } public static void main(String[] args) { System.out.println(Arrays.toString(newArray())); System.out.println(newString()); } }\"]},\"270\":{\"h\":\"6.1.6 变量的作用域\",\"t\":[\"本章中我们只使用静态成员变量和静态成员函数，非静态成员变量/函数及其区别会在下一章中介绍。\",\"函数内定义的变量为局部变量，只能在函数内部使用。\",\"定义在类中的变量为成员变量，可以在类的所有成员函数中调用。\",\"当局部变量与全局变量重名时，会优先使用局部变量。\",\"public class Main { private static int x = 4; private static void f1() { int x = 3; System.out.println(x); } private static void f2() { System.out.println(x); } private static void f3() { System.out.println(x + 1); } public static void main(String[] args) { f1(); f2(); f3(); } }\"]},\"271\":{\"h\":\"6.2 参数传递\"},\"272\":{\"h\":\"6.2.1 值传递\",\"t\":[\"八大基本数据类型和 String 类型等采用值传递。\",\"将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。\",\"public class Main { private static void f(int x) { x = 5; } public static void main(String[] args) { int x = 10; f(x); System.out.println(x); } }\"]},\"273\":{\"h\":\"6.2.2 引用传递\",\"t\":[\"除 String 以外的数据类型的对象，例如 数组、StringBuilder 等采用引用传递。\",\"将实参的引用（地址）传给形参，通过引用找到变量的真正地址，然后对地址中的值修改。所以此时对形参的修改会影响实参的初始值。\",\"import java.util.Arrays; public class Main { private static void f1(int[] a) { for (int i = 0, j = a.length - 1; i < j; i ++, j -- ) { int t = a[i]; a[i] = a[j]; a[j] = t; } } private static void f2(StringBuilder sb) { sb.append(\\\"Hello World\\\"); } public static void main(String[] args) { int[] a = {1, 2, 3, 4, 5}; f1(a); System.out.println(Arrays.toString(a)); StringBuilder sb = new StringBuilder(\\\"\\\"); f2(sb); System.out.println(sb); } }\"]},\"274\":{\"h\":\"6.3 返回类型和 return 语句\",\"t\":[\"return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。\",\"return 语句有两种形式：\",\"return; return expression;\"]},\"275\":{\"h\":\"6.3.1 无返回值函数\",\"t\":[\"没有返回值的 return 语句只能用在返回类型是 void 的函数中。 返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式地执行 return。\",\"通常情况下，void 函数如果想在它的中间位置提前退出，可以使用 return 语句。return 的这种用法有点类似于我们用 break 语句退出循环。\",\"public class Main { private static void swap(int[] a) { // 交换a[0]和a[1] // 如果两个值相等，则不需要交换，直接退出 if (a[0] == a[1]) return; // 如果程序执行到了这里，说明还需要继续完成某些功能 int tmp = a[0]; a[0] = a[1]; a[1] = tmp; // 此处无须显示的return语句 } public static void main(String[] args) { int[] a = {3, 4}; swap(a); System.out.printf(\\\"%d %d\\\\n\\\", a[0], a[1]); } }\"]},\"276\":{\"h\":\"6.3.2 有返回值的函数\",\"t\":[\"只要函数的返回类型不是 void，则该函数内的每个分支都必须有 return 语句，且每条 return 语句都必须返回一个值。return 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换函数的返回类型。\",\"import java.util.Scanner; public class Main { private static int max(int a, int b) { if (a > b) return a; return b; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(), y = sc.nextInt(); System.out.println(max(x, y)); } }\"]},\"277\":{\"h\":\"6.4 函数重载\",\"t\":[\"函数重载 是指：在同一个类中存在多个函数，函数名称相同但参数列表不同。\",\"编译器会根据实参的类型选择最匹配的函数来执行。\",\"import java.util.Scanner; public class Main { private static int max(int a, int b) { System.out.println(\\\"int max\\\"); if (a > b) return a; return b; } private static double max(double a, double b) { System.out.println(\\\"double max\\\"); if (a > b) return a; return b; } public static void main(String[] args) { System.out.println(max(3, 4)); System.out.println(max(3.0, 4.0)); } }\"]},\"278\":{\"h\":\"6.5 函数递归\",\"t\":[\"在一个函数内部，也可以调用函数本身。\",\"import java.util.Scanner; public class Main { private static int fib(int n) { // 求斐波那切数列第n项 if (n <= 2) return 1; return fib(n - 1) + fib(n - 2); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(fib(n)); } }\"]},\"279\":{\"h\":\"七、类与接口\",\"t\":[\"类可以将变量、函数完美地打包在一起。——闫学灿\"]},\"280\":{\"h\":\"7.1 类与对象\",\"t\":[\"类定义一种全新的数据类型，包含一组变量和函数；对象是类这种类型对应的实例。\",\"例如在一间教室中，可以将 Student 定义成类，表示 “学生” 这个抽象的概念。那么每个同学就是 Student 类的一个对象（实例）。\"]},\"281\":{\"h\":\"7.1.1 源文件声明规则\",\"t\":[\"一个源文件中只能有一个 public 类。\",\"一个源文件可以有多个非 public 类。\",\"源文件的名称应该和 public 类的类名保持一致。\",\"每个源文件中，先写 package 语句，再写 import 语句，最后定义类。\"]},\"282\":{\"h\":\"7.1.2 类的定义\",\"t\":[\"public: 所有对象均可以访问\",\"private: 只有本类内部可以访问\",\"protected：同一个包或者子类中可以访问\",\"不添加修饰符：在同一个包中可以访问\",\"静态（带 static 修饰符）成员变量/函数与普通成员变量/函数的区别： \",\"所有 static 成员变量/函数在类中只有一份，被所有类的对象共享；\",\"所有普通成员变量/函数在类的每个对象中都有独立的一份；\",\"静态函数中只能调用静态函数/变量；访问静态变量最好通过类名；\",\"普通函数中既可以调用普通函数/变量，也可以调用静态函数/变量。\",\"class Point { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public int getX() { return x; } public int getY() { return y; } public String toString() { return String.format(\\\"(%d, %d)\\\", x, y); } }\"]},\"283\":{\"h\":\"7.1.3 类的继承\",\"t\":[\"每个类只能继承一个类。\",\"class ColorPoint extends Point { private String color; public ColorPoint(int x, int y, String color) { super(x, y); this.color = color; } public void setColor(String color) { this.color = color; } public String toString() { return String.format(\\\"(%d, %d, %s)\\\", super.getX(), super.getY(), this.color); } }\"]},\"284\":{\"h\":\"7.1.4 类的多态\",\"t\":[\"public class Main { public static void main(String[] args) { Point point = new Point(3, 4); Point colorPoint = new ColorPoint(1, 2, \\\"red\\\"); // 多态，同一个类的实例，调用相同的函数，运行结果不同 System.out.println(point.toString()); System.out.println(colorPoint.toString()); } }\"]},\"285\":{\"h\":\"7.2 接口\",\"t\":[\"interface 与 class 类似。主要用来定义类中所需包含的函数。\",\"接口也可以继承其他接口，一个类可以实现多个接口。\"]},\"286\":{\"h\":\"7.2.1 接口的定义\",\"t\":[\"接口中不添加修饰符时，默认为 public。\",\"interface Role { public void greet(); public void move(); public int getSpeed(); }\"]},\"287\":{\"h\":\"7.2.2 接口的继承\",\"t\":[\"每个接口可以继承多个接口\",\"interface Hero extends Role { public void attack(); }\"]},\"288\":{\"h\":\"7.2.3 接口的实现\",\"t\":[\"每个类可以实现多个接口\",\"class Zeus implements Hero { private final String name = \\\"Zeus\\\"; public void attack() { System.out.println(name + \\\": Attack!\\\"); } public void greet() { System.out.println(name + \\\": Hi!\\\"); } public void move() { System.out.println(name + \\\": Move!\\\"); } public int getSpeed() { return 10; } }\"]},\"289\":{\"h\":\"7.2.4 接口的多态\",\"t\":[\"class Athena implements Hero { private final String name = \\\"Athena\\\"; public void attack() { System.out.println(name + \\\": Attack!!!\\\"); } public void greet() { System.out.println(name + \\\": Hi!!!\\\"); } public void move() { System.out.println(name + \\\": Move!!!\\\"); } public int getSpeed() { return 10; } } public class Main { public static void main(String[] args) { Hero[] heros = {new Zeus(), new Athena()}; for (Hero hero: heros) { hero.greet(); } } }\"]},\"290\":{\"h\":\"八、常用容器\"},\"291\":{\"h\":\"8.1 List\",\"t\":[\"接口：java.util.List<>\",\"实现：\",\"java.util.ArrayList<>：变长数组\",\"java.util.LinkedList<>：双链表\",\"函数：\",\"add()：在末尾添加一个元素\",\"clear()：清空\",\"size()：返回长度\",\"isEmpty()：是否为空\",\"get(i)：获取第i个元素\",\"set(i, val)：将第i个元素设置为val\"]},\"292\":{\"h\":\"8.2 栈\",\"t\":[\"类：java.util.Stack<>\",\"函数：\",\"push()：压入元素\",\"pop()：弹出栈顶元素，并返回栈顶元素\",\"peek()：返回栈顶元素\",\"size()：返回长度\",\"empty()：栈是否为空\",\"clear()：清空\"]},\"293\":{\"h\":\"8.3 队列\",\"t\":[\"接口：java.util.Queue<>\",\"实现：\",\"java.util.LinkedList<>：双链表\",\"java.util.PriorityQueue<>：优先队列 \",\"默认是小根堆，大根堆写法：new PriorityQueue<>(Collections.reverseOrder())\",\"函数：\",\"add()：在队尾添加元素\",\"remove()：删除并返回队头\",\"isEmpty()：是否为空\",\"size()：返回长度\",\"peek()：返回队头\",\"clear()：清空\"]},\"294\":{\"h\":\"8.4 Set\",\"t\":[\"接口：java.util.Set<K>\",\"实现：\",\"java.util.HashSet<K>：哈希表\",\"java.util.TreeSet<K>：平衡树\",\"函数：\",\"add()：添加元素\",\"contains()：是否包含某个元素\",\"remove()：删除元素\",\"size()：返回元素数\",\"isEmpty()：是否为空\",\"clear()：清空\",\"java.util.TreeSet多的函数：\",\"ceiling(key)：返回大于等于key的最小元素，不存在则返回null\",\"floor(key)：返回小于等于key的最大元素，不存在则返回null\"]},\"295\":{\"h\":\"8.5 Map\",\"t\":[\"接口：java.util.Map<K, V>\",\"实现：\",\"java.util.HashMap<K, V>：哈希表\",\"java.util.TreeMap<K, V>：平衡树\",\"函数：\",\"put(key, value)：添加关键字和其对应的值\",\"get(key)：返回关键字对应的值\",\"containsKey(key)：是否包含关键字\",\"remove(key)：删除关键字\",\"size()：返回元素数\",\"isEmpty()：是否为空\",\"clear()：清空\",\"entrySet()：获取Map中的所有对象的集合\",\"Map.Entry<K, V>：Map中的对象类型 \",\"getKey()：获取关键字\",\"getValue()：获取值\",\"java.util.TreeMap<K, V>多的函数：\",\"ceilingEntry(key)：返回大于等于key的最小元素，不存在则返回null\",\"floorEntry(key)：返回小于等于key的最大元素，不存在则返回null\"]},\"296\":{\"h\":\"九、异常处理\",\"t\":[\"异常处理可以允许我们在程序运行时进行诊断和补救。—— 闫学灿\"]},\"297\":{\"h\":\"9.1 Error 与 Exception 的区别\",\"t\":[\"Error 是程序无法处理的错误，比如 OutOfMemoryError、ThreadDeath 等。这些异常发生时，Java 虚拟机 (JVM) 一般会选择线程终止。此类异常是程序的致命异常，是无法捕获处理的。\",\"Exception 是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。 程序中应当尽可能去处理这些异常。\"]},\"298\":{\"h\":\"9.2 Exception类的继承关系\",\"t\":[\"exception.png\"]},\"299\":{\"h\":\"9.3 运行时异常和非运行时异常的区别\",\"t\":[\"运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等， 这些异常是非检查型异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\",\"非运行时异常是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，这些是检查型异常。一般情况下不自定义检查型异常。\"]},\"300\":{\"h\":\"9.4 内置异常类\",\"t\":[\"非检查性异常：\",\"异常\",\"描述\",\"ArithmeticException\",\"当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。\",\"ArrayIndexOutOfBoundsException\",\"用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\",\"ArrayStoreException\",\"试图将错误类型的对象存储到一个对象数组时抛出的异常。\",\"ClassCastException\",\"当试图将对象强制转换为不是实例的子类时，抛出该异常。\",\"IllegalArgumentException\",\"抛出的异常表明向方法传递了一个不合法或不正确的参数。\",\"IllegalMonitorStateException\",\"抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\",\"IllegalStateException\",\"在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。\",\"IllegalThreadStateException\",\"线程没有处于请求操作所要求的适当状态时抛出的异常。\",\"IndexOutOfBoundsException\",\"指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\",\"NegativeArraySizeException\",\"如果应用程序试图创建大小为负的数组，则抛出该异常。\",\"NullPointerException\",\"当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\",\"NumberFormatException\",\"当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\",\"SecurityException\",\"由安全管理器抛出的异常，指示存在安全侵犯。\",\"StringIndexOutOfBoundsException\",\"此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。\",\"UnsupportedOperationException\",\"当不支持请求的操作时，抛出该异常\",\"检查性异常：\",\"异常\",\"描述\",\"ClassNotFoundException\",\"应用程序试图加载类时，找不到相应的类，抛出该异常。\",\"CloneNotSupportedException\",\"当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。\",\"IllegalAccessException\",\"拒绝访问一个类的时候，抛出该异常。\",\"InstantiationException\",\"当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\",\"InterruptedException\",\"一个线程被另一个线程中断，抛出该异常。\",\"NoSuchFieldException\",\"请求的变量不存在\",\"NoSuchMethodException\",\"请求的方法不存在\"]},\"301\":{\"h\":\"9.5 内置异常方法\",\"t\":[\"方法\",\"说明\",\"public String getMessage()\",\"返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。\",\"public Throwable getCause()\",\"返回一个 Throwable 对象代表异常原因。\",\"public String toString()\",\"返回此 Throwable 的简短描述。\",\"public void printStackTrace()\",\"将此 Throwable 及其回溯打印到标准错误流\",\"public StackTraceElement [] getStackTrace()\",\"返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\",\"public Throwable fillInStackTrace()\",\"用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。\"]},\"302\":{\"h\":\"9.6 捕获异常\",\"t\":[\"import java.util.Scanner; public class Main { private static void foo() { int[] array = new int[5]; for (int i = 0; i < 5; i ++ ) array[i] = i; Scanner sc = new Scanner(System.in); int k = sc.nextInt(); int x = sc.nextInt(); try { array[k] /= x; } catch (ArithmeticException e) { System.out.println(\\\"除零错误！\\\"); e.printStackTrace(); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\\\"数组越界！\\\"); e.printStackTrace(); } finally { for (int i = 0; i < 5; i ++ ) { System.out.println(array[i]); } } } public static void main(String[] args) { foo(); } }\"]},\"303\":{\"h\":\"9.7 抛出异常\",\"t\":[\"throw: 在函数内抛出一个异常。\",\"throws：在函数定义时抛出一些可能的异常。\",\"检查型异常必须被捕获或者抛出。\",\"import java.io.IOException; import java.util.Scanner; public class Main { private static void foo() throws IOException, NoSuchFieldException { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); if (x == 1) throw new IOException(\\\"找不到文件！！！\\\"); else throw new NoSuchFieldException(\\\"自定义异常\\\"); } public static void main(String[] args) { try { foo(); } catch (IOException e) { System.out.println(\\\"IOException!\\\"); e.printStackTrace(); } catch (NoSuchFieldException e) { System.out.println(\\\"NoSuchFieldException!\\\"); e.printStackTrace(); } } }\"]},\"304\":{\"h\":\"9.8 try-with-resources\",\"t\":[\"JDK7 之后，Java 新增的 try-with-resource 语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭 。\",\"try 用于声明和实例化资源，catch 用于处理关闭资源时可能引发的所有异常。\",\"import java.io.*; public class Main { public static void main(String[] args) { String line; try ( BufferedReader br = new BufferedReader(new FileReader(\\\"input.txt\\\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\\\"output.txt\\\")); ) { while ((line = br.readLine()) != null) { System.out.println(\\\"Line => \\\" + line); bw.write(\\\"copy: \\\" + line + \\\"\\\\n\\\"); } bw.flush(); } catch (IOException e) { System.out.println(\\\"IOException in try block =>\\\" + e.getMessage()); } } }\"]},\"305\":{\"h\":\"十、注解与反射\"},\"306\":{\"h\":\"10.1 注解\",\"t\":[\"(1) 注解（Annotation）也被称为元数据（Metadata），用于修饰包、方法、属性、构造器、局部变量等数据信息。\",\"(2) 注解不影响程序逻辑，但注解可以被编译或运行。\",\"(3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。\"]},\"307\":{\"h\":\"10.1.1 常用注解\",\"t\":[\"(1) @Override: 限定某个函数必须重写其他函数，该注解只能用于函数。函数名和参数列表必须相同。\",\"(2) @Overload: 限定某个函数必须重载其他函数，该注解只能用于函数。函数名必须相同，参数列表必须不同。\",\"(3) @Deprecated：用于表示某个程序元素（类、函数）已过时\",\"(4) @SuppressWarnings：抑制编译器警告\"]},\"308\":{\"h\":\"10.1.2 元注解\",\"t\":[\"修饰其他注解的注解，就被称为元注解。\",\"(1) Retention：指定注解的作用范围\",\"(2) Target：指定注解可以用在哪些地方\",\"(3) Document：注定注解是否出出现在 javadoc 中\",\"(4) Inherited：子类会继承父类的注解\"]},\"309\":{\"h\":\"10.2 反射\",\"t\":[\"反射：动态引入类、动态调用实例的成员函数、成员变量等。\"]},\"310\":{\"h\":\"10.2.1 常用API\",\"t\":[\"(1) java.lang.Class：获取类的实例对象\",\"(2) java.lang.reflect.Method：获取类或接口中的单个方法的信息\",\"(3) java.lang.reflect.Field：获取类或接口中的单个字段的信息\",\"(4) java.lang.reflect.Constructor：获取类中的单个构造函数的信息\",\"package org.yxc; public class Calculator { public String name; public Calculator() {} public Calculator(String name) { this.name = name; } public int add(int a, int b) { return a + b; } }\",\"package org.yxc; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class<?> cls = Class.forName(\\\"org.yxc.Calculator\\\"); Object o = cls.newInstance(); Method method = cls.getMethod(\\\"add\\\", int.class, int.class); int res = (int)method.invoke(o, 3, 4); System.out.println(res); Field field = cls.getField(\\\"name\\\"); field.set(o, \\\"My Calculator!\\\"); System.out.println(field.get(o)); Constructor<?> constructor = cls.getConstructor(String.class); Object new_o = constructor.newInstance(\\\"New Calculator!\\\"); System.out.println(new_o); } }\"]},\"311\":{\"h\":\"10.2.2 优缺点\",\"t\":[\"优点：可以动态创建和使用对象，使用灵活 缺点：执行速度慢\"]},\"312\":{\"h\":\"十一、多线程与锁\"},\"313\":{\"h\":\"11.1 多线程\"},\"314\":{\"h\":\"11.1.1 实现多线程\",\"t\":[\"写法1：继承 Thread 类\",\"class Worker extends Thread { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + this.getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) { Worker worker1 = new Worker(); Worker worker2 = new Worker(); worker1.setName(\\\"thread-1\\\"); worker2.setName(\\\"thread-2\\\"); worker1.start(); worker2.start(); } }\",\"写法2：实现 Runnable 接口\",\"class Worker1 implements Runnable { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + \\\"thread-1\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } class Worker2 implements Runnable { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + \\\"thread-2\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) { new Thread(new Worker1()).start(); new Thread(new Worker2()).start(); } }\"]},\"315\":{\"h\":\"11.1.2 常用API\",\"t\":[\"start()：开启一个线程\",\"Thread.sleep(): 休眠一个线程\",\"join()：等待线程执行结束\",\"interrupt()：从休眠中中断线程（不能中断任何线程）\",\"setDaemon()：将线程设置为守护线程。当只剩下守护线程时，程序自动退出\"]},\"316\":{\"h\":\"11.2 锁\",\"t\":[\"lock：获取锁，如果锁已经被其他线程获取，则阻塞\",\"unlock：释放锁，并唤醒被该锁阻塞的其他线程\",\"import java.util.concurrent.locks.ReentrantLock; class Worker extends Thread { public static int cnt = 0; private static final ReentrantLock lock = new ReentrantLock(); @Override public void run() { for (int i = 0; i < 100000; i ++ ) { lock.lock(); try { cnt ++ ; } finally { lock.unlock(); } } } } public class Main { public static void main(String[] args) throws InterruptedException { Worker worker1 = new Worker(); Worker worker2 = new Worker(); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(Worker.cnt); } }\"]},\"317\":{\"h\":\"11.3 同步（Synchronized）\",\"t\":[\"写法1：将 Synchronized 加到代码块上\",\"class Count { public int cnt = 0; } class Worker extends Thread { public final Count count; public Worker(Count count) { this.count = count; } @Override public void run() { synchronized (count) { for (int i = 0; i < 100000; i ++ ) { count.cnt ++ ; } } } } public class Main { public static void main(String[] args) throws InterruptedException { Count count = new Count(); Worker worker1 = new Worker(count); Worker worker2 = new Worker(count); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(count.cnt); } }\",\"写法2：将 Synchronized 加到函数上（锁加到了 this 对象上）\",\"class Worker implements Runnable { public static int cnt = 0; private synchronized void work() { for (int i = 0; i < 100000; i ++ ) { cnt ++ ; } } @Override public void run() { work(); } } public class Main { public static void main(String[] args) throws InterruptedException { Worker worker = new Worker(); Thread worker1 = new Thread(worker); Thread worker2 = new Thread(worker); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(Worker.cnt); } }\"]},\"318\":{\"h\":\"11.3.1 wait 与 notify\",\"t\":[\"package org.yxc; class Worker extends Thread { private final Object object; private final boolean needWait; public Worker(Object object, boolean needWait) { this.object = object; this.needWait = needWait; } @Override public void run() { synchronized (object) { try { if (needWait) { object.wait(); System.out.println(this.getName() + \\\": 被唤醒啦！\\\"); } else { object.notifyAll(); } } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) throws InterruptedException { Object object = new Object(); for (int i = 0; i < 5; i ++ ) { Worker worker = new Worker(object, true); worker.setName(\\\"thread-\\\" + i); worker.start(); } Worker worker = new Worker(object, false); worker.setName(\\\"thread-\\\" + 5); Thread.sleep(1000); worker.start(); } }\"]},\"319\":{\"c\":[\"Java\"]},\"320\":{\"c\":[\"基础\"]},\"321\":{\"h\":\"常用API\",\"t\":[\"整理 java 刷题过程中常用 API\"]},\"322\":{\"h\":\"数组\",\"t\":[\"toString(arr); // 返回一个字符串 copyOf(arr, begin, end); copyOfRange(arr, begin, end); // 返回与arr类型相同的一个数组，其长度为end或end-begin，并填入arr的值 // 如果end大于arr.length，结果会填充0或false值 sort(arr, begin, end); // 使用稳定的快排队数组进行排序 --- O(n logn) sort(arr, begin, end, Collections.reverseOrder()); // 数组降序排序排序 equals(arr1, arr2); // 如果两个数组长度相同，并且相同索引对应的元素都相同，则返回 true\"]},\"323\":{\"h\":\"字符串\",\"t\":[\"字符串分为两类：不可变字符串（String）和可变字符串（StringBuilder）。\",\"String 类用来表示那些创建后就不会再改变的字符串，而 StringBuilder 类用来表示内容可变的字符串，并提供了修改字符串的方法。\",\"表面上拼接字符串时，String 类使用 str1 + str2 这种形式拼接字符串，实际上是 JVM 帮助创建 StringBuilder 对象来拼接，StringBuilder 类却要调用一个 append() 方法来拼接，但其实 StringBuilder 类的效率更高。\"]},\"324\":{\"h\":\"String\",\"t\":[\"初始化有两种：\",\"String str = new String(\\\"XXX\\\"); // 参数可以是字符串常量，也可为字符数组 String str = \\\"XXX\\\"; // 参数可为字符串常量，可为String.valueOf()系列的返回值\",\"前者是 java 中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会创建一个新的对象； 后者则会在栈中创建一个对象引用变量 str ，然后查看字符串池中是否存在 \\\"XXX\\\"，如果没有，则将 \\\"XXX\\\" 存放字符串池，并令引用变量 str 指向它；如果已经有 \\\"XXX\\\"，则直接令 str 指向它。\",\"常用方法：\",\"equals(); // 字符串比较必须能用equals()，相同返回true，否则返回false equalsIgnoreCase(); // 忽略大小写进行比较 charAt(int index); // 返回index位置的字符char --- O(1) length(); // 返回字符串长度 --- O(1) substring(int begin, int end); // 返回字符片段[begin, end) --- O(n) substring(int begin); // 返回从begin开始后面所有的字符片段 ---- O(n) contains(String str); // 是否包含子串str --- O(1) indexOf(String str); // 返回str第一个出现的位置，没找到则返回-1 --- O(m * n) m为原串长度， n为str长度 indexOf(String str, int index); // 同上，但从index开始找 --- O(m * n) lastIndexOf(String str); // 返回str最后出现的位置，没找到则返回-1 --- O(m * n) m为原串长度， n为str长度 lastIndexOf(String str, int index); // 同上，但从index开始从后往前找 [0 <- Index] --- O(m * n) replace(char oldChar, char newChar); // 返回一个新字符串String，其全部oldChar都替换成newChar --- O(n) toLowerCase(); // 返回一个新的字符串全部转成小写 --- O(n) toUpperCase(); // 返回一个新的字符串全部转成大写 --- O(n) trim(); // 去除首尾空白字符，包括 \\\\t \\\\r \\\\n --- O(n) strip(); // 去除首尾空白字符，还包括中文的空格字符 \\\\u3000 也会被移除 isEmpty(); // 判断字符串是否为空 isBlank(); // 判断是否为空白字符串 split(String regex); // 传入正则表达式分隔字符串 ---- O(n) // String s = \\\"A,B,C,D\\\"; // String[] ss = s.split(\\\"\\\\\\\\,\\\"); // {\\\"A\\\", \\\"B\\\", \\\"C\\\", \\\"D\\\"} join(); // 拼接字符串，用指定的字符串连接字符串数组 // String[] arr = {\\\"A\\\", \\\"B\\\", \\\"C\\\"}; // String s = String.join(\\\"***\\\", arr); // \\\"A***B***C\\\" formatted(); // 格式化字符串，通过传入其他参数，替换占位符，生成新的字符串 format(); // 同上 // String s = \\\"Hi %s, your score is %d!\\\"; // System.out.println(s.formatted(\\\"Alice\\\", 80)); // System.out.println(String.format(\\\"Hi %s, your score is %.2f!\\\", \\\"Bob\\\", 59.5));\",\"类型转换：\",\"valueOf(); // 将任意基本类型或引用类型转换为字符串 parseInt(); // 将字符串转换为int类型 parseBoolean(); // 将字符串转换为boolean类型 getInteger(); // 将该字符串对应的系统变量转换为Integer toCharArray(); // 将字符串转换为char[]数组 // char[] cs = \\\"Hello\\\".toCharArray(); // String -> char[] // String s = new String(cs); // char[] -> String // 将char[]转byte[] byte[] b1 = \\\"Hello\\\".getBytes(); // 按系统默认编码转换，不推荐 byte[] b2 = \\\"Hello\\\".getBytes(\\\"UTF-8\\\"); // 按UTF-8编码转换 byte[] b2 = \\\"Hello\\\".getBytes(\\\"GBK\\\"); // 按GBK编码转换 byte[] b3 = \\\"Hello\\\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 // 将已知编码的byte[]转换为String byte[] b = ... String s1 = new String(b, \\\"GBK\\\"); // 按GBK转换 String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换\"]},\"325\":{\"h\":\"StringBuilder\",\"t\":[\"StringBuilder sb = new StringBuilder(); // 创建对象 charAt(int index); // 返回index位置的char --- O(1) length(); // 返回缓冲字符串长度 --- O(1) append(String str); // 拼接字符串 --- O(n) toString(); // 返回一个与构建起或缓冲器内容相同的字符串 --- O(n)\"]},\"326\":{\"h\":\"集合\"},\"327\":{\"h\":\"List 列表\",\"t\":[\"两个实现类：ArrayList、LinkedList\",\"ArrayList 底层是通过数组（动态扩容的数组）实现的，查询快\",\"LinkedList 底层是通过双向链表实现的，插入和删除快\",\"// E 表示泛型 List<E> array = new ArrayList<>(); // 顺序数组列表 List<E> array = new LinkedList<>(); // 顺序链表 ArrayList<E>(int initialCapacity); // 指定容量的空数组列表 // Set<Integer> a = new HashSet<Integer>(); List<Integer> b = new ArrayList<>(a); //接受一个集合容器 set(int index, E e); // 将元素e放在index位置，返回之前的内容 get(int index); // 返回元素位置在index的元素e --- 数组 O(1), 链表 O(n) add(E e); // 在尾部添加一个元素e --- O(1) add(int index, E e); // 后移元素，在index位置插一个元素e --- O(n) remove(int index); // 删除位于index的元素，并返回删除元素e --- 删除最后元素为O(1)， 其余为O(n) //删除最后元素 list.remove(list.size() - 1); size(); // 返回动态数组所存元素个数/链表长度 --- O(1) subList(int satrt, int end) // 相当于返回原数组的一个片段，但不要对其进行改动，改动会影响原数组 --- O(1) // List<Integer> list, 对原来的list和返回的list做的 \\\"非结构性修改\\\" // 都会影响到彼此对方. 如果你在调用了sublist返回了子list之后，如果修改了原list的大小，那么之前产生的子list将会失效，变得不可使用 trimToSize(); // 将数组列表的存储容量削减到其当前大小\"]},\"328\":{\"h\":\"Set 集合\",\"t\":[\"Set 是一种没有重复元素的集合，三个实现类：HashSet，LinkedHashSet，TreeSet。\",\"HashSet 元素乱序\",\"LinkedHashSet 保证元素添加顺序\",\"TreeSet 元素按自然顺序排序\",\"Set<E> set = new HashSet<>(); // 实例化 //List<E> list = new ArrayList<>(); Set<E> set = new HashSet<>(list); // 传参 add(E e); // 在集合中添加元素e，若成功添加则返回true，若集合中有元素e则返回false --- O(1) remove(E e); // 在集合中删除元素e，若删除成功返回true；若集合中没有元素e，返回false --- O(1) contains(E e); // 若存在元素e，则返回true，否则返回false --- O(1) isEmpty(); // 若集合为空返回true，否则返回false --- O(1) first()、last(); // 返回有序集合中第一个元素，最后一个元素，在TreeSet类中\"]},\"329\":{\"h\":\"Map 映射\",\"t\":[\"两个实现类：HashMap，TreeMap\",\"HashMap 键值对乱序\",\"TreeMap 键值对以 “键” 排序\",\"TreeSet 中的元素和 TreeMap 中键如果是基本数据类型（的包装类型）或者是字符串，那么就按照数值大小以及字典序排序即可，但是如果是自定义的实体类对象，就需要自己自定义排序方式。自定义排序时，需要用到 Comparable 接口或者是 Comparator 接口。\",\"自然排序 -- 使用 Comparable 接口\",\"定制排序 -- 使用 Comparator 接口\",\"Map<Characters, Integer> map = new HashMap<>(); // 实例化 put(K key, V value); // 在Map中加入键值对<key, value>，返回value值。如果Map中有key，则replace旧的value --- O(1) get(K key); // 返回Map中key对应的value。若Map中没有该key，则返回null --- O(1) getOrDefault(K key, V defaultValue); // 返回Map中key对应的value。若Map中没有该key，则返回defaultValue --- O(1) // For example: // Map<Character, Integer> map = new HashMap<>(); // if (...) // 如果发现k，则k在Map中的值加1。没一开始没有k，则从0开始加1。（相当于给了key在Map中的一个初试值） map.put('k', map.getOrDefault('k', 0) + 1); containsKey(Key key); // 在Map中若存在key，则返回true，否则返回false --- O(1) containsValue(Value value); // 在Map中若存在value，则返回true，否则返回false --- O(1) Set<Map.Entry<K, V>> entrySet(); // 返回Map.Entry对象的一个集视图，可以删除元素，但不能添加任何元素 Set<K> keySet(); // 返回一个Set,这个Set中包含Map中所有的Key --- O(1) // For example: // We want to get all keys in Map // Map<Character, Integer> map = new HashMap<>(); for (Character key : map.keySet()) { // Operate with each key } Collection<V> values(); // 返回一个Collection<V>，里面全是对应的每一个value --- O(1) // For example: // We want to get all values in Map // Map<Character, Integer> map = new HashMap<>(); for (Integer value : map.values()) { // Operate with each values } getKey(); // 返回这个映射的键 getValue(); // 返回这个映射的值 setValue(V newValue); // 将关联映射中的值改为新值，并返回原来的值 isEmpty() // 若Map为空返回true， 否则返回false --- O(1) size() // 返回Map中中键值对<K, V>的个数 --- O(1)\"]},\"330\":{\"h\":\"栈\",\"t\":[\"java 中 Stack 继承了 Vector 类，仅仅实现栈的操作。 另外，Deque 不仅有队列（双端队列，普通队列）的特性，也可以作为栈，用法同 Stack ，方法也相同。\",\"建议使用 Deque 用作堆栈而不是 Stack 类，因为 Stack 的方法是同步的，同步的过程会消耗时间。\",\"Deque 的实现类有 ArrayDeque 和 LinkedList，但最好使用 ArrayDeque 类在 Java 中实现堆栈数据结构。\",\"Stack<E> stack = new Stack<>(); // Stack类 Deque<E> stack = new ArrayDeque<>(); // Deque接口，ArrayDeque是Deque的一个实现类 push(E e); // 入栈元素e， 返回值为元素e --- O(1) pop(); // 出栈一个元素，返回出栈元素e --- O(1) peek(); // 查看栈顶元素， 返回值为栈顶元素e --- O(1) search(); // 从堆栈的顶部返回元素的位置 --- O(1) isEmpty() // 若栈空返回true，否则返回false --- O(1) size() // 返回栈中元素个数 --- O(1)\"]},\"331\":{\"h\":\"Queue 队列\",\"t\":[\"Queue 为接口，实现类是 LinkedList（既实现 List 接口，又实现 Queue 接口） ，特性是先进先出。\",\"Queue<E> q = new LinkedList<>(); //实例化 // 添加元素e到队尾 --- O(1) offer(E e); // 成功返回true，否则返回false add(E e); // 失败抛出异常 // 取队首元素并删除 --- O(1) poll(); // 成功返回队首元素，否则返回null remove(); // 失败抛出异常 // 不建议把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。 // 取队首元素但不删除 --- O(1) peek(); // 成功返回队首元素，否则返回null element(); // 失败抛出异常 isEmpty() // 若队空返回true，否则返回false --- O(1) size() // 返回队中元素个数 --- O(1)\"]},\"332\":{\"h\":\"Deque 双端队列\",\"t\":[\"Deque 接口实际上扩展自 Queue，Queue 中的方法在 Deque 中也可以使用，但不建议这么做。\",\"Deque<E> q = new LinkedList<>(); //实例化 offerFirst(E e); // 将元素添加到队首 --- O(1) offerLast(E e); // 将元素添加到队尾 --- O(1) pollFirst(); // 获取队首元素并删除 --- O(1) pollLast(); // 获取队尾元素并删除 --- O(1) peekFirst(); // 获取队首元素但不删除 --- O(1) peekLast(); // 获取队尾元素但不删除 --- O(1) isEmpty(); // 非空返回true，否则返回false size(); // 队列中元素个数\"]},\"333\":{\"h\":\"PriorityQueue 优先队列\",\"t\":[\"优先队列在添加元素的时候对元素的大小排序后再保存。PriorityQueue 对元素采用的是堆排序，头是按指定排序方式的最小元素。（堆排序只能保证根是最大/最小，整个堆并不是有序的）\",\"因此，放入 PriorityQueue 的元素，需要先定义好排序规则，才能够确保队列元素整体有序。\",\"PriorityQueue 默认按元素的排序规则排序（必须实现 Comparable 接口），也可以通过 Comparator 自定义排序算法（元素就不必实现 Comparable 接口）。\",\"// 默认实现小根堆。 PriorityQueue<E> minHeap = new PriorityQueue<>(); // 大根堆 PriorityQueue<E> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // 自定义实现最小/最大（e1-e2，升序 / e2-e1，降序） // 开始指定大小capacity = 100，当元素超过容量后会扩容 PriorityQueue<E> priorityQueue = new PriorityQueue<E>(100, new Comparator<E>(){ @Override public int compare(E e1, E e2) { return e2.val - e1.val; // 返回值大于0，表示两个元素需要更换位置，否则不需要更换 } }); offer(E e); // 在堆中加入元素，并调整堆。若成功入堆返回值true，否则返回false --- O(logN) poll(); // 获取堆顶元素并删除，重新调整堆 --- O(logN) peek(); // 获取堆顶元素但不删除 --- O(1) isEmpty(); // 判断队列是否为空 size(); // 队列中元素数量\"]},\"334\":{\"h\":\"工具类\"},\"335\":{\"h\":\"java.util.Math\",\"t\":[\"主要包含数学内的应用方法\",\"Math.abs(a); // 返回a的绝对值 Math.max(a, b); // 返回a和b的最大值 Math.min(a, b); // 返回a和b的最小值 Math.sqrt(a); // 开平方 Math.cbrt(b); // 开立方 Math.pow(a, b); // 返回a的b次方 Math.ceil(a); // 对浮点数向上取整 Math.floor(a); // 对浮点数向下取整 Math.round(a); // 对浮点数四舍五入 Math.log(a); // 以e为底取对数 Math.log10(a); // 以10为底取对数 Math.log(n) / Math.log(m); // 以m为底取n的对数 Math.random(); // 返回一个随机数，范围为[0,1)，返回类型为double\"]},\"336\":{\"h\":\"java.util.Collections\",\"t\":[\"主要对集合进行操作\",\"binarySearch(arr, start, end, v); // 使用二分查找算法在有序数组arr中查找值 v --- O(logn) // 如果找到 v，则返回相应的索引；否则返回一个负数值 r。-r-1 是 v 应插入的位置（为保持 a 有序） max(Collection<E> elements); // 返回集合中最大的元素 min(Collection<E> elements); // 返回集合中最小的元素 fill(Collection<E> c, V value); // 将集合的所有元素设置为 v addAll(Collection<E> c, V...values); // 将所有的值添加到给定的集合中 replaceAll(Collection<E> c, V oldvalue, V newvalue); // 用newValue替换所有等于oldValue的元素 indexOfSubList(List<E> list1, List<E> list2); // 返回list1中第一个等于list2的子列表的索引 lastIndexOfSubList(List<E> list1, List<E> list2); // 返回list1中最后一个等于list2的子列表的索引\"]},\"337\":{\"h\":\"javafx.util.Pair<K, V>\",\"t\":[\"Java 8 的 package.json 中新增了一个 Pair<K,V> 类，表示键值对，类似于 C++ 中的 pair 二元组，实现对 first 和 second 的操作。\",\"getKey(); // 返回该pair的key值 getValue(); // 返回该pair的value值 hashCode(); // 生成该pair的哈希值 equals(E e); // 判断该pair是否和对象元素e相等 toString(); // 返回该pair的字符串表示\"]},\"338\":{\"h\":\"基本类型的最大值和最小值\",\"t\":[\"数字类型包装类都支持两个常量：MAX_VALUE，MIN_VALUE，分别保存了对应基本类型的最大值与最小值。\",\"fmax = Float.MAX_VALUE; fmin = Float.MIN_VALUE; dmax = Double.MAX_VALUE; dmin = Double.MIN_VALUE; bmax = Byte.MAX_VALUE; bmin = Byte.MIN_VALUE; cmax = Character.MAX_VALUE; cmin = Character.MIN_VALUE; shmax = Short.MAX_VALUE; shmin = Short.MIN_VALUE; imax = Integer.MAX_VALUE; imin = Integer.MIN_VALUE; lmax = Long.MAX_VALUE; lmin = Long.MIN_VALUE;\"]},\"339\":{\"c\":[\"Java\"]},\"340\":{\"c\":[\"API\"]},\"341\":{\"h\":\"Singleton 单例模式 —— 只有一个实例\"},\"342\":{\"h\":\"单例模式的定义\",\"t\":[\"如果一个类只允许创建一个对象（或实例），那么，这个类就是一个单例类，这种设计模式就称为单例模式。\",\"从业务概念方面来讲，如果某个类包含的数据在系统中只应保存一份，那么这个类就应该被设计为单例类。\"]},\"343\":{\"c\":[\"设计模式\"]},\"344\":{\"c\":[\"创建型模式\"]},\"345\":{\"h\":\"并发的优缺点\"},\"346\":{\"h\":\"1. 为什么要用到并发\",\"t\":[\"一直以来，硬件的发展极其迅速，也有一个很著名的\\\"摩尔定律\\\"，可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展，这其中的关系应该是多核 CPU 的发展为并发编程提供的硬件基础。\",\"摩尔定律并不是一种自然法则或者是物理定律，它只是基于认为观测数据后，对未来的一种预测。按照所预测的速度，我们的计算能力会按照指数级别的速度增长，不久以后会拥有超强的计算能力。正是在畅想未来的时候，2004年，Intel 宣布 4GHz 芯片的计划推迟到2005年，然后在2004年秋季，Intel 宣布彻底取消 4GHz 的计划，也就是说摩尔定律的有效性超过了半个世纪戛然而止。\",\"但是，聪明的硬件工程师并没有停止研发的脚步，他们为了进一步提升计算速度，而不是再追求单独的计算单元，而是将多个计算单元整合到了一起，也就是形成了多核 CPU。短短十几年的时间，家用型 CPU，比如 Intel i7 就可以达到 4 核心甚至 8 核心。而专业服务器则通常可以达到几个独立的 CPU，每一个 CPU 甚至拥有多达 8 个以上的内核。因此，摩尔定律似乎在 CPU 核心扩展上继续得到体验。因此，多核的 CPU 的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。\",\"顶级计算机科学家 DonaldErvinKnuth 如此评价这种情况：在我看来，这种现象（并发）或多或少是由于硬件设计者无计可施了导致的，他们将摩尔定律的责任推给了软件开发者。\",\"另外，在特殊的业务场景下先天的就适合于并发编程。比如在图像处理领域，一张 1024×768 像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间，面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。正是因为这些优点，使得多线程技术能够得到重视，也是一名 CS 学习者应该掌握的：\",\"充分利用多核 CPU 的计算能力；\",\"方便进行业务拆分，提升应用性能\"]},\"347\":{\"h\":\"2. 并发编程有哪些缺点\",\"t\":[\"多线程技术有这么多的好处，难道就没有一点缺点么，就在任何场景下就一定适用么？很显然不是。\"]},\"348\":{\"h\":\"2.1 频繁的上下文切换\",\"t\":[\"时间片是 CPU 分配给各个线程的时间，因为时间非常短，所以 CPU 不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而这个切换时非常损耗性能，过于频繁反而无法发挥出多线程编程的优势。\",\"通常减少上下文切换可以采用无锁并发编程，CAS算法，使用最少的线程和使用协程。\",\"无锁并发编程：可以参照 ConcurrentHashMap 分段锁的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。\",\"CAS算法，利用 Atomic 下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换\",\"使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态\",\"协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换\",\"由于上下文切换也是个相对比较耗时的操作，所以在《java并发编程的艺术》一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用 Lmbench3 测量上下文切换的时长，vmstat 测量上下文切换次数。\"]},\"349\":{\"h\":\"2.2 线程安全\",\"t\":[\"多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。\",\"public class DeadLockDemo { private static String resource_a = \\\"A\\\"; private static String resource_b = \\\"B\\\"; public static void main(String[] args) { deadLock(); } public static void deadLock() { Thread threadA = new Thread(new Runnable() { @Override public void run() { synchronized (resource_a) { System.out.println(\\\"get resource a\\\"); try { Thread.sleep(3000); synchronized (resource_b) { System.out.println(\\\"get resource b\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } } }); Thread threadB = new Thread(new Runnable() { @Override public void run() { synchronized (resource_b) { System.out.println(\\\"get resource b\\\"); synchronized (resource_a) { System.out.println(\\\"get resource a\\\"); } } } }); threadA.start(); threadB.start(); } }\",\"在上面的这个 demo 中，开启了两个线程 threadA，threadB，其中 threadA 占用了 resource_a，并等待被 threadB 释放的 resource _b。threadB 占用了 resource _b 正在等待被 threadA 释放的resource _a。因此 threadA，threadB 出现线程安全的问题，形成死锁。同样可以通过 jps，jstack 证明这种推论：\",\"\\\"Thread-1\\\": waiting to lock monitor 0x000000000b695360 (object 0x00000007d5ff53a8, a java.lang.String), which is held by \\\"Thread-0\\\" \\\"Thread-0\\\": waiting to lock monitor 0x000000000b697c10 (object 0x00000007d5ff53d8, a java.lang.String), which is held by \\\"Thread-1\\\" Java stack information for the threads listed above: =================================================== \\\"Thread-1\\\": at learn.DeadLockDemo$2.run(DeadLockDemo.java:34) - waiting to lock <0x00000007d5ff53a8(a java.lang.String) - locked <0x00000007d5ff53d8(a java.lang.String) at java.lang.Thread.run(Thread.java:722) \\\"Thread-0\\\": at learn.DeadLockDemo$1.run(DeadLockDemo.java:20) - waiting to lock <0x00000007d5ff53d8(a java.lang.String) - locked <0x00000007d5ff53a8(a java.lang.String) at java.lang.Thread.run(Thread.java:722) Found 1 deadlock.\",\"如上所述，完全可以看出当前死锁的情况。\",\"那么，通常可以用如下方式避免死锁的情况：\",\"避免一个线程同时获得多个锁；\",\"避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；\",\"尝试使用定时锁，使用 lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞；\",\"对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况\",\"所以，如何正确的使用多线程编程技术有很大的学问，比如如何保证线程安全，如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题，比如数据脏读，DCL等这些问题（在后续篇幅会讲述）。而在学习多线程编程技术的过程中也会让你收获颇丰。\"]},\"350\":{\"h\":\"3. 应该了解的概念\"},\"351\":{\"h\":\"3.1 同步VS异步\",\"t\":[\"同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。\"]},\"352\":{\"h\":\"3.2 并发与并行\",\"t\":[\"并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的 “同时进行”。实际上，如果系统内只有一个 CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个 CPU 的系统中。\"]},\"353\":{\"h\":\"3.3 阻塞和非阻塞\",\"t\":[\"阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。\"]},\"354\":{\"h\":\"3.4 临界区\",\"t\":[\"临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。\"]},\"355\":{\"c\":[\"并发编程\"]},\"356\":{\"c\":[\"JUC\"]},\"357\":{\"h\":\"彻底理解 ReentrantLock\"},\"358\":{\"h\":\"1. 基本介绍\",\"t\":[\"ReentrantLock 重入锁，是实现 Lock 接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。\",\"在 Java 关键字中， synchronized 隐式支持重入性，synchronized 通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock 不仅支持重入性，还支持公平锁和非公平锁两种方式。\",\"那么，要想完完全全的弄懂 ReentrantLock 的话，主要也就是 ReentrantLock 同步语义的学习：\",\"重入性的实现原理\",\"公平锁和非公平锁\"]},\"359\":{\"h\":\"2. 重入性的实现原理\",\"t\":[\"要想支持重入性，就要解决两个问题：\",\"在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功\",\"由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功\",\"首先，同步组件主要是通过重写 AQS 的几个 protected 方法来表达自己的同步语义。\",\"针对第一个问题，我们来看看 ReentrantLock 是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为 nonfairTryAcquire：\",\"final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); // 1. 如果该锁未被任何线程占有，该锁能被当前线程获取 if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 2.若被占有，检查占有线程是否是当前线程 else if (current == getExclusiveOwnerThread()) { // 3. 再次获取，计数加一 int nextc = c + acquires; if (nextc < 0) // overflow throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; }\",\"这段代码的逻辑也很简单，具体请看注释。\",\"为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为 tryRelease：\",\"protected final boolean tryRelease(int releases) { // 1. 同步状态减1 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { // 2. 只有当同步状态为0时，锁成功被释放，返回true free = true; setExclusiveOwnerThread(null); } // 3. 锁未被完全释放，返回false setState(c); return free; }\",\"代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为 0 时锁才算成功释放，否则锁仍未释放。如果锁被获取 n 次，释放了 n−1 次，该锁未完全释放返回 false，只有被释放 n 次才算成功释放，返回 true。\",\"通过分析，我们可以理清 ReentrantLock 重入性的实现了，也就是理解了同步语义的第一条。\"]},\"360\":{\"h\":\"3. 公平锁与公平锁\",\"t\":[\"ReentrantLock 支持两种锁：公平锁和非公平锁。\",\"公平性\",\"何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足 FIFO。\",\"ReentrantLock 的构造方法无参时是构造非公平锁，源码为：\",\"public ReentrantLock() { sync = new NonfairSync(); }\",\"另外还提供了另外一种方式，可传入一个 boolean 值，true 时为公平锁，false 时为非公平锁，源码为：\",\"public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); }\",\"在上面非公平锁获取时（nonfairTryAcquire 方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：\",\"protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; }\",\"这段代码的逻辑与 nonfairTryAcquire 基本上一致，唯一的不同在于增加了 hasQueuedPredecessors 的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。\",\"公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。\",\"公平锁 VS 非公平锁\",\"公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成 “饥饿” 现象。\",\"公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock 默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。\"]},\"361\":{\"c\":[\"并发编程\"]},\"362\":{\"c\":[\"JUC\"]},\"363\":{\"h\":\"深入理解读写锁 ReentrantReadWriteLock\"},\"364\":{\"h\":\"1. 读写锁介绍\",\"t\":[\"在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用 Java 提供的关键字 synchronized 或者 concurrent 包中实现了 Lock 接口的 ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。\",\"而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（即出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。\",\"针对这种读多写少的情况，Java 还提供了另外一个实现 Lock 接口的 ReentrantReadWriteLock（读写锁）。读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。在分析 WirteLock 和 ReadLock 的互斥性时可以按照 WriteLock 与 WriteLock 之间，WriteLock 与 ReadLock 之间以及 ReadLock 与 ReadLock 之间进行分析。\",\"关于读写锁的特性，这里简单做个小结：\",\"公平性选择：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；\",\"重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；\",\"锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁\",\"要想能够彻底的理解读写锁必须能够理解这样几个问题：\",\"读写锁是怎样实现分别记录读写状态的？\",\"写锁是怎样获取和释放的？\",\"读锁是怎样获取和释放的？\",\"下面我们带着这三个问题，去深入了解下读写锁。\"]},\"365\":{\"h\":\"2. 写锁详解\"},\"366\":{\"h\":\"2.1 写锁的获取\",\"t\":[\"同步组件的实现聚合了同步器（AQS），并通过重写同步器（AQS）中的方法实现同步组件的同步语义（关于同步组件的实现层级结构可以看这篇文章，AQS的底层实现分析可以看这篇文章）。\",\"因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写 AQS 中的 tryAcquire 方法实现的。源码为:\",\"protected final boolean tryAcquire(int acquires) { /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); // 1. 获取写锁当前的同步状态 int c = getState(); // 2. 获取写锁获取的次数 int w = exclusiveCount(c); if (c != 0) { // (Note: if c != 0 and w == 0 then shared count != 0) // 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话 // 当前线程获取写锁失败 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) > MAX_COUNT) throw new Error(\\\"Maximum lock count exceeded\\\"); // Reentrant acquire // 3.2 当前线程获取写锁，支持可重复加锁 setState(c + acquires); return true; } // 3.3 写锁未被任何线程获取，当前线程可获取写锁 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true; }\",\"这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusiveCount(c) 方法，该方法源码为：\",\"static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\",\"其中 EXCLUSIVE_MASK 为:\",\"static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\",\"EXCLUSIVE _MASK 为 1 左移 16 位然后减 1 ，即为 0x0000FFFF。而 exclusiveCount 方法是将同步状态（state 为 int 类型）与 0x0000FFFF 相与，即取同步状态的低 16 位。那么低 16 位代表什么呢？根据 exclusiveCount 方法的注释为独占式锁获取的次数即写锁被获取的次数，现在就可以得出来一个结论，即 同步状态的低 16 位用来表示写锁的获取次数。\",\"同时还有一个方法值得我们注意：\",\"static int sharedCount(int c) { return c >>> SHARED_SHIFT; }\",\"该方法是获取读锁被获取的次数，是将同步状态（int c）右移 16 次，即取同步状态的高 16 位，现在我们可以得出另外一个结论，即 同步状态的高 16 位用来表示读锁被获取的次数。\",\"于是我们开篇的第一个问题 —— 读写锁是怎样实现分别记录读锁和写锁的状态的？现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示：\",\"现在我们回过头来看写锁获取方法 tryAcquire，其主要逻辑为：\",\"当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。\"]},\"367\":{\"h\":\"2.2 写锁的释放\",\"t\":[\"写锁释放通过重写 AQS 的 tryRelease 方法，源码为：\",\"protected final boolean tryRelease(int releases) { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 1. 同步状态减去写状态 int nextc = getState() - releases; // 2. 当前写状态是否为0，为0则释放写锁 boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); // 3. 不为0则更新同步状态 setState(nextc); return free; }\",\"源码的实现逻辑请看注释，不难理解与 ReentrantLock 基本一致，这里需要注意的是：\",\"减少写状态 int nextc = getState() - releases; 只需要 用当前同步状态直接减去写状态。\",\"其原因正是我们刚才所说的：写状态由同步状态的低 16 位表示。\"]},\"368\":{\"h\":\"3. 读锁详解\"},\"369\":{\"h\":\"3.1.读锁的获取\",\"t\":[\"看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对 AQS 介绍，实现共享式同步组件的同步语义需要通过重写 AQS 的 tryAcquireShared 方法和 tryReleaseShared 方法。读锁的获取实现方法为：\",\"protected final int tryAcquireShared(int unused) { /* * Walkthrough: * 1. If write lock held by another thread, fail. * 2. Otherwise, this thread is eligible for * lock wrt state, so ask if it should block * because of queue policy. If not, try * to grant by CASing state and updating count. * Note that step does not check for reentrant * acquires, which is postponed to full version * to avoid having to check hold count in * the more typical non-reentrant case. * 3. If step 2 fails either because thread * apparently not eligible or CAS fails or count * saturated, chain to version with full retry loop. */ Thread current = Thread.currentThread(); int c = getState(); // 1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前线程获取读锁失败返回-1 if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) return -1; int r = sharedCount(c); if (!readerShouldBlock() && r < MAX_COUNT && // 2. 当前线程获取读锁 compareAndSetState(c, c + SHARED_UNIT)) { // 3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法 // 返回当前获取读锁的次数 if (r == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; } return 1; } // 4. 处理在第二步中CAS操作失败的自旋已经实现重入性 return fullTryAcquireShared(current); }\",\"代码的逻辑请看注释，需要注意的是 当写锁被其他线程获取后，读锁获取失败，否则获取成功利用 CAS 更新同步状态。另外，当前同步状态需要加上 SHARED_UNIT（(1 << SHARED_SHIFT) 即 0x00010000）的原因正是我们在上面说的，同步状态的高 16 位用来表示读锁被获取的次数。如果 CAS 失败或者已经获取读锁的线程再次获取读锁时，是靠 fullTryAcquireShared 方法实现的，这段代码就不展开说了，有兴趣可以看看。\"]},\"370\":{\"h\":\"3.2 读锁的释放\",\"t\":[\"读锁释放的实现主要通过方法 tryReleaseShared，源码如下，主要逻辑请看注释：\",\"protected final boolean tryReleaseShared(int unused) { Thread current = Thread.currentThread(); // 前面还是为了实现getReadHoldCount等新功能 if (firstReader == current) { // assert firstReaderHoldCount > 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; if (count <= 1) { readHolds.remove(); if (count <= 0) throw unmatchedUnlockException(); } --rh.count; } for (;;) { int c = getState(); // 读锁释放 将同步状态减去读状态即可 int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; } }\"]},\"371\":{\"h\":\"4. 锁降级\",\"t\":[\"读写锁支持锁降级，遵循获取写锁，获取读锁再释放写锁的次序。\",\"写锁能够降级成为读锁，不支持锁升级。\",\"关于锁降级下面的示例代码摘自 ReentrantWriteReadLock源码中：\",\"void processCachedData() { rwl.readLock().lock(); if (!cacheValid) { // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try { // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) { data = ... cacheValid = true; } // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); } finally { rwl.writeLock().unlock(); // Unlock write, still hold read } } try { use(data); } finally { rwl.readLock().unlock(); } }\"]},\"372\":{\"c\":[\"并发编程\"]},\"373\":{\"c\":[\"JUC\"]},\"374\":{\"h\":\"详解 Condition 的 await 和 signal 等待通知机制\"},\"375\":{\"h\":\"1. Condition 简介\",\"t\":[\"任何一个 Java 对象都天然继承于 Object 类，在线程间实现通信的往往会应用到 Object 的几个方法，比如 wait()，wait(long timeout)，wait(long timeout, int nanos) 与 notify()，notifyAll() 几个方法实现等待/通知机制。\",\"同样的，在 Java Lock 体系下依然会有同样的方法实现等待/通知机制。从整体上来看 Object 的 wait 和 notify/notifyAll 是与对象监视器配合完成线程间的等待/通知机制，而 Condition 与 Lock 配合完成等待通知机制，前者是 Java 底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。\",\"两者除了在使用方式上不同外，在功能特性上还是有很多的不同：\",\"Condition 能够支持不响应中断，而通过使用 Object 方式不支持；\",\"Condition 能够支持多个等待队列（new 多个 Condition 对象），而 Object 方式只能支持一个；\",\"Condition 能够支持超时时间的设置，而 Object 不支持\",\"参照 Object 的 wait 和 notify/notifyAll 方法，Condition 也提供了同样的方法：\",\"针对 Object 的 wait 方法\",\"void await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用 Condition 的 signal/signalAll 方法并且当前线程获取 Lock 从 await 方法返回，如果在等待状态中被中断会抛出被中断异常\",\"long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时\",\"boolean await(long time, TimeUnit unit) throws InterruptedException：同第二种，支持自定义时间单位\",\"boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间\",\"针对 Object 的 notify/notifyAll 方法\",\"void signal()：唤醒一个等待在 Condition 上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到 Lock 则可以从等待方法中返回\",\"void signalAll()：与第一种的区别在于能够唤醒所有等待在 Condition 上的线程\"]},\"376\":{\"h\":\"2. Condition 实现原理分析\"},\"377\":{\"h\":\"2.1 等待队列\",\"t\":[\"要想能够深入的掌握 Condition 还是应该知道它的实现原理。\",\"通过分析 Condiiton 的源码，我们会发现，创建一个 Condition 对象是通过 lock.newCondition()，而这个方法实际上是会 new 出一个 ConditionObject 对象，该类是 AQS 的一个内部类。前面我们说过，condition 是要和 lock 配合使用，也就是 Condition 和 Lock 是绑定在一起的，而 lock 的实现原理又依赖于 AQS，自然而然 ConditionObject 作为 AQS 的一个内部类无可厚非。\",\"我们知道在锁机制的实现上，AQS 内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，Condition 内部也是使用同样的方式，内部维护了一个等待队列，所有调用 condition.await 方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到 ConditionObject 中有两个成员变量：\",\"/** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter;\",\"可以发现 ConditionObject 通过持有等待队列的头尾指针来管理等待队列。需要注意的是 Node 类复用了在 AQS 中的 Node 类，其节点状态和相关属性可以去看 AQS的实现原理。\",\"Node 类有这样一个属性：\",\"//后继节点 Node nextWaiter;\",\"进一步说明，等待队列是一个单向队列，而在之前说 AQS 时知道同步队列是一个双向队列。接下来我们用一个 demo，通过 debug 进去看是不是符合我们的猜想：\",\"public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(() -> { lock.lock(); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } }); thread.start(); } }\",\"这段代码没有任何实际意义，甚至很臭，只是想说明下我们刚才所想的。\",\"新建了 10 个线程，没有线程先获取锁，然后调用 condition.await 方法释放锁将当前线程加入到等待队列中，通过 debug 控制当走到第 10 个线程的时候查看 firstWaiter，即等待队列中的头结点，debug 模式下情景图如下：\",\"从这个图我们可以很清楚的看到这样几点：\",\"调用 condition.await 方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为 Thread-0，Thread-1，Thread-2....Thread-8\",\"等待队列是一个单向队列。\",\"通过我们的猜想然后进行实验验证，我们可以得出等待队列的示意图如下图所示：\",\"同时还有一点需要注意的是：我们可以多次调用 lock.newCondition() 方法创建多个 Condition 对象，也就是一个 lock 可以持有多个等待队列。而在之前利用 Object 的方式实际上是指在对象 Object 对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的 Lock 拥有一个同步队列和多个等待队列。\",\"示意图如下：\",\"AQS 持有多个 Condition\",\"如图所示，ConditionObject 是 AQS 的内部类，因此每个 ConditionObject 能够访问到 AQS 提供的方法，相当于每个 Condition 都拥有所属同步器的引用。\"]},\"378\":{\"h\":\"2.2 await 实现原理\",\"t\":[\"当调用 condition.await() 方法后会使得当前获取 lock 的线程进入到等待队列，如果该线程能够从 await() 方法返回的话一定是该线程获取了与 condition 相关联的 lock。\",\"接下来，我们还是从源码的角度去看，只有熟悉了源码的逻辑我们的理解才是最深的。\",\"await() 方法源码为：\",\"public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 1. 将当前线程包装成Node，尾插入到等待队列中 Node node = addConditionWaiter(); // 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) { // 3. 当前线程进入到等待状态 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } // 4. 自旋等待获取到同步状态（即获取到lock） if (acquireQueued(node, savedState) && interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 5. 处理被中断的情况 if (interruptMode != 0) reportInterruptAfterWait(interruptMode); }\",\"代码的主要逻辑请看注释，我们都知道当当前线程调用 condition.await() 方法后，会使得当前线程释放 lock 然后加入到等待队列中，直至被 signal/signalAll 后会使得当前线程从等待队列中移至到同步队列中去，直到获得了 lock 后才会从 await 方法返回，或者在等待时被中断会做中断处理。\",\"那么关于这个实现过程，有这样几个问题：\",\"是怎样将当前线程添加到等待队列中去的？\",\"释放锁的过程？\",\"怎样才能从 await 方法退出？\",\"而这段代码的逻辑就是告诉我们这三个问题的答案。\",\"具体请看注释，在第 1 步中调用 addConditionWaiter() 将当前线程添加到等待队列中，该方法源码为：\",\"private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null && t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } // 将当前线程包装成Node Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else // 尾插入 t.nextWaiter = node; // 更新lastWaiter lastWaiter = node; return node; }\",\"这段代码就很容易理解了，将当前节点包装成 Node，如果等待队列的 firstWaiter 为 null 的话（等待队列为空队列），则将 firstWaiter 指向当前的 Node，否则，更新 lastWaiter(尾节点)即可。\",\"就是通过尾插入的方式将当前线程封装的 Node 插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前学习过 AQS，就知道同步队列是一个带头结点的链式队列，这是两者的一个区别。\",\"将当前节点插入到等待对列之后，会使当前线程释放 lock，由 fullyRelease() 方法实现，fullyRelease 的源码为：\",\"final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); if (release(savedState)) { //成功释放同步状态 failed = false; return savedState; } else { //不成功释放同步状态抛出异常 throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } }\",\"这段代码调用 AQS 的模板方法 release 方法释放 AQS 的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。\",\"到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题 —— 怎样从 await 方法退出？\",\"现在回过头再来看 await 方法有这样一段逻辑：\",\"while (!isOnSyncQueue(node)) { // 3. 当前线程进入到等待状态 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; }\",\"很显然，当线程第一次调用 condition.await()方法时，会进入到这个 while() 循环中，然后通过 LockSupport.park(this) 方法使得当前线程进入等待状态，那么要想退出这个 await 方法第一个前提条件自然而然的是要先退出这个 while 循环，出口就只剩下两个地方：\",\"逻辑走到 break 退出 while 循环\",\"while 循环中的逻辑判断为 false\",\"再看代码出现第 1 种情况的条件是当前等待的线程被中断后代码会走到 break 退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的 condition 的 signal/signalAll 方法），while 中逻辑判断为 false 后结束 while 循环。\",\"总结下，就是当前线程被中断或者调用 condition.signal/condition.signalAll 方法当前节点移动到了同步队列后，这是当前线程退出 await 方法的前提条件。当退出 while 循环后就会调用 acquireQueued(node, savedState)，这个方法在介绍 AQS 的底层实现时说过，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到 lock）。这样也说明了退出 await 方法必须是已经获得了 condition 引用（关联）的 lock。\",\"到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对 await 方法的理解加深。await 方法示意图如下图：\",\"如图，调用 condition.await 方法的线程必须是已经获得了 lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的 Node 尾插入到等待队列中。\",\"超时机制的支持\",\"Condition 还额外支持了超时机制，使用者可调用方法 awaitNanos，awaitUtil。这两个方法的实现原理，基本上与 AQS 中的 tryAcquire 方法如出一辙。\",\"不响应中断的支持\",\"要想不响应中断可以调用 condition.awaitUninterruptibly() 方法，该方法的源码为：\",\"public final void awaitUninterruptibly() { Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean interrupted = false; while (!isOnSyncQueue(node)) { LockSupport.park(this); if (Thread.interrupted()) interrupted = true; } if (acquireQueued(node, savedState) || interrupted) selfInterrupt(); }\",\"这段方法与上面的 await 方法基本一致，只不过减少了对中断的处理，并省略了 reportInterruptAfterWait 方法抛被中断的异常。\"]},\"379\":{\"h\":\"2.3 signal/signalAll 实现原理\",\"t\":[\"调用 condition 的 signal/signalAll 方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得 lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用 condition 的 signal 方法是将头节点移动到同步队列中。\",\"我们来通过看源码的方式来看这样的猜想是不是对的，signal 方法源码为：\",\"public final void signal() { // 1. 先检测当前线程是否已经获取lock if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 2. 获取等待队列中第一个节点，之后的操作都是针对这个节点 Node first = firstWaiter; if (first != null) doSignal(first); }\",\"signal 方法首先会检测当前线程是否已经获取 lock，如果没有获取 lock 会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的 doSignal 方法也是基于该节点。\",\"下面我们来看看 doSignal 方法做了些什么事情，该方法源码为：\",\"private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; // 1. 将头结点从等待队列中移除 first.nextWaiter = null; // 2. while中transferForSignal方法对头结点做真正的处理 } while (!transferForSignal(first) && (first = firstWaiter) != null); }\",\"具体逻辑请看注释，真正对头节点做处理的逻辑在 transferForSignal 处，该方法源码为：\",\"final boolean transferForSignal(Node node) { /* * If cannot change waitStatus, the node has been cancelled. */ // 1. 更新状态为0 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ // 2.将该节点移入到同步队列中去 Node p = enq(node); int ws = p.waitStatus; if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; }\",\"关键逻辑请看注释，这段代码主要做了两件事情：\",\"将头结点的状态更改为 CONDITION\",\"调用 enq 方法，将该节点尾插入到同步队列中（关于 enq方法请看 AQS的底层实现）\",\"现在我们可以得出结论：调用 condition 的 signal 的前提条件是当前线程已经获取了 lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从 await 方法中的 LockSupport.park(this) 方法中返回，从而才有机会使得调用 await 方法的线程成功退出。\",\"signal 执行示意图如下图：\",\"signalAll\",\"signalAll 与 signal 方法的区别体现在 doSignalAll 方法上，前面我们已经知道 doSignal 方法只会对等待队列的头节点进行操作，而 doSignalAll 的源码为：\",\"private void doSignalAll(Node first) { lastWaiter = firstWaiter = null; do { Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; } while (first != null); }\",\"该方法只不过是将等待队列中的每一个节点都移入到同步队列中，即 “通知” 当前调用 condition.await() 方法的每一个线程。\"]},\"380\":{\"h\":\"3. await 与 signal/signalAll 的结合思考\",\"t\":[\"文章开篇提到等待/通知机制，通过使用 Condition 提供的 await 和 signal/signalAll 方法就可以实现这种机制，而这种机制能够解决最经典的问题就是 “生产者与消费者问题”，关于 “生产者消费者问题”之后后面也会用单独的一篇文章进行解析。await 和 signal/signalAll 方法就像一个开关控制着线程 A（等待方）和线程B（通知方）。\",\"它们之间的关系可以用下面一个图来表现得更加贴切：\",\"Condition 下的等待通知机制\",\"如上图。\",\"线程 awaitThread 先通过 lock.lock() 方法获取锁成功后调用了 condition.await 方法进入等待队列，而另一个线程 signalThread 通过 lock.lock() 方法获取锁成功后调用了 condition.signal 或者 signalAll 方法，使得线程 awaitThread 能够有机会移入到同步队列中，\",\"当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock，从而使得线程 awaitThread 能够从 await 方法中退出执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。\"]},\"381\":{\"h\":\"4. 一个例子\",\"t\":[\"我们用一个很简单的例子说说 condition 的用法：\",\"public class AwaitSignal { private static ReentrantLock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); private static volatile boolean flag = false; public static void main(String[] args) { Thread waiter = new Thread(new waiter()); waiter.start(); Thread signaler = new Thread(new signaler()); signaler.start(); } static class waiter implements Runnable { @Override public void run() { lock.lock(); try { while (!flag) { System.out.println(Thread.currentThread().getName() + \\\"当前条件不满足等待\\\"); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + \\\"接收到通知条件满足\\\"); } finally { lock.unlock(); } } } static class signaler implements Runnable { @Override public void run() { lock.lock(); try { flag = true; condition.signalAll(); } finally { lock.unlock(); } } } }\",\"输出结果为：\",\"Thread-0当前条件不满足等待 Thread-0接收到通知，条件满足\",\"开启了两个线程 waiter 和 signaler，waiter 线程开始执行的时候由于条件不满足，执行 condition.await 方法使该线程进入等待状态同时释放锁，signaler 线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。\",\"这时，waiter 线程获取到锁，并由于 signaler 线程更改了条件此时相对于 waiter 来说条件满足，继续执行。\"]},\"382\":{\"c\":[\"并发编程\"]},\"383\":{\"c\":[\"JUC\"]},\"384\":{\"h\":\"LockSupport 工具\"},\"385\":{\"h\":\"1. LockSupport 简介\",\"t\":[\"在之前介绍 AQS 的底层实现，以及在 ReentrantLock 和 ReentReadWriteLocks 中，介绍过线程间等待/通知机制使用 Condition 时都会调用 LockSupport.park() 方法和 LockSupport.unpark() 方法。关于这个在同步组件的实现中被频繁使用的 LockSupport 究竟为何方神圣，现在来看看。\",\"LockSupport 位于 java.util.concurrent.locks 包下，有兴趣的可以直接去看源码，该类的方法并不是很多。LockSupprot 是线程的阻塞原语，用来阻塞线程和唤醒线程。\",\"每个使用 LockSupport 的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用 park() 将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark() 使其可用。但是注意许可不可重入，也就是说只能调用一次 park() 方法，否则会一直阻塞。\"]},\"386\":{\"h\":\"2. LockSupport方法介绍\",\"t\":[\"LockSupport 中的方法不多，这里将这些方法做一个总结：\",\"阻塞线程\",\"void park()：阻塞当前线程，如果调用 unpark 方法或者当前线程被中断，能从 park() 方法中返回\",\"void park(Object blocker)：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\",\"void parkNanos(long nanos)：阻塞当前线程，最长不超过 nanos 纳秒，增加了超时返回的特性；\",\"void parkNanos(Object blocker, long nanos)：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\",\"void parkUntil(long deadline)：阻塞当前线程，直到 deadline；\",\"void parkUntil(Object blocker, long deadline)：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\",\"唤醒线程\",\"void unpark(Thread thread)：唤醒处于阻塞状态的指定线程\",\"实际上 LockSupport 阻塞和唤醒线程的功能是依赖于 sun.misc.Unsafe，这是一个很底层的类，有兴趣的可以去查阅资料。\",\"比如 park() 方法的功能实现则是靠 unsafe.park() 方法。另外在阻塞线程这一系列方法中还有一个很有意思的现象就是，每个方法都会新增一个带有 Object 的阻塞对象的重载方法。那么增加了一个 Object 对象的入参会有什么不同的地方了？示例代码很简单就不说了，直接看 dump 线程的信息。\",\"调用 park() 方法 dump 线程：\",\"\\\"main\\\" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304) at learn.LockSupportDemo.main(LockSupportDemo.java:7)\",\"调用 park(Object blocker) 方法 dump 线程：\",\"\\\"main\\\" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for <0x048c2d18> (a java.lang.String) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at learn.LockSupportDemo.main(LockSupportDemo.java:7)\",\"通过分别调用这两个方法然后 dump 线程信息可以看出：带 Object 的 park 方法相较于无参的 park 方法会增加 parking to wait for <0x048c2d18> (a java.lang.String） 的信息，这种信息就类似于记录 “案发现场”，有助于工程人员能够迅速发现问题解决问题。\",\"有意思的是，我们都知道如果使用 synchronzed 阻塞了线程，dump 线程时都会有阻塞对象的描述，在 Java 5 推出 LockSupport 时遗漏了这一点，在 Java 6 时进行了补充。\",\"还有一点需要注意的是：synchronzed 致使线程阻塞，线程会进入到 BLOCKED 状态；而调用 LockSupprt 方法阻塞线程会致使线程进入到 WAITING 状态。\"]},\"387\":{\"h\":\"3. 一个例子\",\"t\":[\"用一个很简单的例子说说这些方法怎么用。\",\"public class LockSupportDemo { public static void main(String[] args) { Thread thread = new Thread(() -> { LockSupport.park(); System.out.println(Thread.currentThread().getName() + \\\"被唤醒\\\"); }); thread.start(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } LockSupport.unpark(thread); } }\",\"thread 线程调用 LockSupport.park() 致使 thread 阻塞，当 main 线程睡眠 3 秒结束后通过 LockSupport.unpark(thread) 方法唤醒 thread 线程，thread 线程被唤醒执行后续操作。\",\"另外，还有一点值得关注的是，LockSupport.unpark(thread) 可以指定线程对象唤醒指定的线程。\"]},\"388\":{\"c\":[\"并发编程\"]},\"389\":{\"c\":[\"JUC\"]},\"390\":{\"h\":\"并发容器之 ConcurrentHashMap\"},\"391\":{\"h\":\"1. ConcurrentHashMap 简介\",\"t\":[\"在使用 HashMap 时在多线程情况下扩容会出现 CPU 接近 100% 的情况，因为 hashmap 并不是线程安全的，通常我们可以使用在 Java 体系中古老的 hashtable 类，该类基本上所有的方法都采用 synchronized 进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过 Collections 的 Map<K,V> synchronizedMap(Map<K,V> m) 将 hashmap 包装成一个线程安全的 map。比如 SynchronzedMap 的 put 方法源码为：\",\"public V put(K key, V value) { synchronized (mutex) { return m.put(key, value); } }\",\"实际上 SynchronizedMap 实现依然是采用 synchronized 独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，DougLea 大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个 Java 开发人员倍感幸福。\",\"相对于 hashMap 来说，ConcurrentHashMap 就是线程安全的 Map，其中利用了锁分段的思想提高了并发度。\",\"ConcurrentHashMap 在 JDK1.6 的版本网上资料很多，有兴趣的可以去看看。\",\"JDK 1.6版本关键要素：\",\"segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；\",\"segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。\",\"而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化，光是代码量就足足增加了很多。\",\"1.8 版本舍弃了 segment，并且大量使用了 synchronized，以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级。因此，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。\"]},\"392\":{\"h\":\"2. ConcurrentHashMap 关键属性及类\",\"t\":[\"ConcurrentHashMap 中有几个关键的属性和类，需要先进行了解。\"]},\"393\":{\"h\":\"2.1 关键属性\",\"t\":[\"1. table\",\"volatile Node<K,V>[] table：装载 Node 的数组，作为 ConcurrentHashMap 的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为 2 的幂次方。\",\"2. nextTable\",\"volatile Node<K,V>[] nextTable：扩容时使用，平时为 null，只有在扩容的时候才为非 null\",\"3. sizeCtl\",\"volatile int sizeCtl：该属性用来控制 table 数组的大小，根据是否初始化和是否正在扩容有几种情况：\",\"当值为负数时：如果为 −1 表示正在初始化，如果为 −N 则表示当前正有 N−1 个线程进行扩容操作\",\"当值为正数时： \",\"如果当前数组为 null 的话表示 table 在初始化过程中，sizeCtl 表示为需要新建数组的长度；\",\"若已经初始化了，表示当前数据容器（table 数组）可用容量，也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体为 数组的长度(n) × 加载因子(loadFactor)\",\"当值为 0 时，即数组长度为默认初始值。\",\"4. sun.misc.Unsafe U\",\"在 ConcurrentHashMapde 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 CAS 算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层 CMPXCHG 指令实现。\",\"CAS(V,O,N) 核心思想为：若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，再进行重试。\",\"而在大量的同步组件和并发容器的实现中使用 CAS 是通过 sun.misc.Unsafe 类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 Java 中的 “指针”。该成员变量的获取是在静态代码块中：\",\"static { try { U = sun.misc.Unsafe.getUnsafe(); ....... } catch (Exception e) { throw new Error(e); } }\"]},\"394\":{\"h\":\"2.2 关键内部类\",\"t\":[\"1. Node\",\"Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域。\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; volatile V val; volatile Node<K,V> next; ...... }\",\"另外可以看出很多属性都是用 volatile 进行修饰的，也就是为了保证内存可见性。\",\"2. TreeNode\",\"TreeNode 树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，TreeBin 会将 TreeNode 进行再一次封装。\",\"/** * Nodes for use in TreeBins */ static final class TreeNode<K,V> extends Node<K,V> { TreeNode<K,V> parent; // red-black tree links TreeNode<K,V> left; TreeNode<K,V> right; TreeNode<K,V> prev; // needed to unlink next upon deletion boolean red; ...... }\",\"3. TreeBin\",\"TreeBin 这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap “数组” 中，存放的是 TreeBin 对象，而不是 TreeNode 对象。\",\"static final class TreeBin<K,V> extends Node<K,V> { TreeNode<K,V> root; volatile TreeNode<K,V> first; volatile Thread waiter; volatile int lockState; // values for lockState static final int WRITER = 1; // set while holding write lock static final int WAITER = 2; // set when waiting for write lock static final int READER = 4; // increment value for setting read lock ...... }\",\"4. ForwardingNode\",\"ForwardingNode 在扩容时才会出现的特殊节点，其 key，value，hash 全部为 null，并拥有 nextTable 指针引用新的 table 数组。\",\"static final class ForwardingNode<K,V> extends Node<K,V> { final Node<K,V>[] nextTable; ForwardingNode(Node<K,V>[] tab) { super(MOVED, null, null, null); this.nextTable = tab; } ..... }\"]},\"395\":{\"h\":\"2.3 CAS 关键操作\",\"t\":[\"在上面我们提及到在 ConcurrentHashMap 中会大量使用 CAS 修改它的属性和一些操作。因此，在理解 ConcurrentHashMap 的方法前我们需要了解下面几个常用的利用 CAS 算法来保障线程安全的操作。\",\"1. tabAt\",\"static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) { return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE); }\",\"该方法用来获取 table 数组中索引为 i 的 Node 元素。\",\"2. casTabAt\",\"static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v) { return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v); }\",\"利用 CAS 操作设置 table 数组中索引为 i 的元素。\",\"3. setTabAt\",\"static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) { U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v); }\",\"该方法用来设置 table 数组中索引为 i 的元素。\"]},\"396\":{\"h\":\"3. 重点方法讲解\",\"t\":[\"在熟悉上面的这核心信息之后，我们接下来就来依次看看几个常用的方法是怎样实现的。\"]},\"397\":{\"h\":\"3.1 实例构造器方法\",\"t\":[\"在使用 ConcurrentHashMap 第一件事自然而然就是 new 出来一个 ConcurrentHashMap 对象，一共提供了如下几个构造器方法：\",\"// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16 ConcurrentHashMap() // 2. 给定map的大小 ConcurrentHashMap(int initialCapacity) // 3. 给定一个map ConcurrentHashMap(Map<? extends K, ? extends V> m) // 4. 给定map的大小以及加载因子 ConcurrentHashMap(int initialCapacity, float loadFactor) // 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程） ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)\",\"ConcurrentHashMap 一共给我们提供了 5 种构造器方法，具体使用请看注释，我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为：\",\"public ConcurrentHashMap(int initialCapacity) { // 1. 小于0直接抛异常 if (initialCapacity < 0) throw new IllegalArgumentException(); // 2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理 int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1)); // 3. 赋值给sizeCtl this.sizeCtl = cap; }\",\"这段代码的逻辑请看注释，很容易理解，如果小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 cap 赋值给 sizeCtl（关于 sizeCtl 的说明请看上面的说明）。\",\"当调用构造器方法之后，sizeCtl 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度。\",\"tableSizeFor 做了哪些事情呢？源码为：\",\"/** * Returns a power of two table size for the given desired capacity. * See Hackers Delight, sec 3.2 */ private static final int tableSizeFor(int c) { int n = c - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }\",\"通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方。比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 ConcurrentHashMap 的大小为 2 的 5 次方（即32）。\",\"另外，需要注意的是，调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作。\"]},\"398\":{\"h\":\"3.2 initTable 方法\",\"t\":[\"直接上源码：\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { if ((sc = sizeCtl) < 0) { // 1. 保证只有一个线程正在进行初始化操作 Thread.yield(); // lost initialization race; just spin } else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if ((tab = table) == null || tab.length == 0) { // 2. 得出数组的大小 int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") // 3. 这里才真正的初始化数组 Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; // 4. 计算数组中可用的大小：实际大小n*0.75（加载因子） sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; }\",\"代码的逻辑见注释。有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第 1 步中会先通过 if 进行判断，若当前已经有一个线程正在初始化即 sizeCtl 值变为 −1，这个时候其他线程在 If 判断为 true 从而调用 Thread.yield() 让出 CPU 时间片。正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为 −1 即正在初始化的状态。\",\"另外还需要注意的是，在第 4 步中会进一步计算数组中可用的大小，即为数组实际大小 n 乘以加载因子 0.75，可以看下这里乘以 0.75 是怎么算的：\",\"0.75 为四分之三，这里 n - (n >>> 2) 是不是刚好是 n−41​n=43​n，挺有意思的吧。\",\"如果选择是无参的构造器的话，这里在 new Node 数组的时候会使用默认大小为 DEFAULT_CAPACITY（16），然后乘以加载因子 0.75 为 12，也就是说数组的可用大小为 12。\"]},\"399\":{\"h\":\"3.3 put 方法\",\"t\":[\"使用 ConcurrentHashMap 最常用的也应该是 put 和 get 方法了吧，我们先来看看 put 方法是怎样实现的。\",\"调用 put 方法时实际具体实现是 putVal 方法，源码如下：\",\"/** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // 1. 计算key的hash值 int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { Node<K,V> f; int n, i, fh; // 2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // 4. 当前正在扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { // 5. 当前为链表，在链表中插入新的键值对 if (fh >= 0) { binCount = 1; for (Node<K,V> e = f;; ++binCount) { K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; if ((e = e.next) == null) { pred.next = new Node<K,V>(hash, key, value, null); break; } } } // 6. 当前为红黑树，将新的键值对插入到红黑树中 else if (f instanceof TreeBin) { Node<K,V> p; binCount = 2; if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 7. 插入完键值对后再根据实际大小看是否需要转换成红黑树 if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 addCount(1L, binCount); return null; }\",\"put 方法的代码量有点长，我们按照上面的分解的步骤一步步来看。从整体而言，为了解决线程安全的问题，ConcurrentHashMap 使用了 synchronzied 和 CAS 的方式。\",\"在之前了解过 HashMap 以及 1.8 版本之前的 ConcurrenHashMap 应该都知道 ConcurrentHashMap 结构图，为了方面下面的讲解这里先直接给出，如果对这有疑问的话，可以在网上随便搜搜即可。\",\"ConcurrentHashMap散列桶数组结构示意图\",\"如上图，ConcurrentHashMap 是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是标准的链地址的解决方式，将 hash 值相同的节点构成链表的形式，称为 “拉链法”。另外，在 1.8 版本中为了防止拉链过长，当链表的长度大于 8 的时候会将链表转换成红黑树。\",\"table 数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入 table 数组的索引 i 处。那么，怎样计算得出索引 i 呢？当然是根据 key 的 hashCode 值。\",\"1. spread() 重哈希，以减小 Hash 冲突\",\"我们知道对于一个 hash 表来说，hash 值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到 hash 表的性能。因此通过 spread 方法进行了一次重 hash 从而大大减小哈希冲突的可能性。spread 方法为：\",\"static final int spread(int h) { return (h ^ (h >>> 16)) & HASH_BITS; }\",\"该方法主要是将 key 的 hashCode 的低 16 位与高 16 位进行异或运算，这样不仅能够使得 hash 值能够分散能够均匀减小 hash 冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的 trade-off。\",\"2. 初始化 table\",\"紧接着到第 2 步，会判断当前 table 数组是否初始化了，没有的话就调用 initTable 进行初始化，该方法在上面已经讲过了。\",\"3. 能否直接将新值插入到 table 数组中\",\"从上面的结构示意图就可以看出存在这样一种情况，如果插入值待插入的位置刚好所在的 table 数组为 null 的话就可以直接将值插入即可。那么怎样根据 hash 确定在 table 中待插入的索引 i 呢？很显然可以通过 hash 值与数组的长度取模操作，从而确定新值插入到数组的哪个位置。\",\"而之前我们提过 ConcurrentHashMap 的大小总是 2 的幂次方，(n - 1) & hash 运算等价于对长度 n 取模，也就是 hash % n，但是位运算比取模运算的效率要高很多。\",\"确定好数组的索引 i 后，就可以通过 tabAt() 方法获取该位置上的元素，如果当前 Node f 为 null 的话，就可以直接用 casTabAt() 方法将新值插入即可。\",\"4. 当前是否正在扩容\",\"如果当前节点不为 null，且该节点为特殊节点（forwardingNode）的话，就说明当前 ConcurrentHashMap 正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。\",\"那么怎样确定当前的这个 Node 是不是特殊的节点呢？是通过判断该节点的 hash 值是不是等于 −1（MOVED），代码为 (fh = f.hash) == MOVED，对 MOVED 的解释在源码上也写的很清楚了：\",\"static final int MOVED = -1; // hash for forwarding nodes\",\"5. 当 table[i] 为链表的头结点，在链表中插入新值\",\"在 table[i] 不为 null 并且不为 forwardingNode 时，并且当前 Node f 的 hash 值大于 0（fh >= 0） 的话说明当前节点 f 为当前桶的所有的节点组成的链表的头结点。\",\"那么接下来，要想向 ConcurrentHashMap 插入新值的话就是向这个链表插入新值。通过 synchronized (f) 的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：\",\"if (fh >= 0) { binCount = 1; for (Node<K,V> e = f;; ++binCount) { K ek; // 找到hash值相同的key,覆盖旧值即可 if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; if ((e = e.next) == null) { // 如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可 pred.next = new Node<K,V>(hash, key, value, null); break; } } }\",\"这部分代码很好理解，就是两种情况：\",\"在链表中如果找到了与待插入的键值对的 key 相同的节点，就直接覆盖即可\",\"如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可\",\"6. 当 table[i] 为红黑树的根节点，在红黑树中插入新值\",\"按照之前的 数组+链表 的设计方案，这里存在一个问题，即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为 O(n) 的情况，则会严重影响 ConcurrentHashMap 的性能。\",\"于是，在 JDK1.8 版本中，对数据结构做了进一步的优化，引入了红黑树。当链表长度太长（默认超过 8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 ConcurrentHashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。\",\"当 table[i] 为红黑树的树节点时的操作为：\",\"if (f instanceof TreeBin) { Node<K,V> p; binCount = 2; if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } }\",\"首先在 if 中通过 f instanceof TreeBin 判断当前 table[i] 是否是树节点，这下也正好验证了我们在最上面介绍时说的 TreeBin 会对 TreeNode 做进一步封装，对红黑树进行操作的时候针对的是 TreeBin 而不是 TreeNode。接着调用 putTreeVal 方法完成向红黑树插入新节点，如果在红黑树中存在与待插入键值对的 Key 相同（hash 值相等并且 equals 方法判断为 true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点。\",\"7. 根据当前节点个数进行调整\",\"当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：\",\"if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; }\",\"很容易理解，如果当前链表节点个数大于等于 8（TREEIFY_THRESHOLD）的时候，就会调用 treeifyBin 方法将 tabel[i]（第 i 个散列桶）拉链转换成红黑树。\",\"至此，关于 put 方法的逻辑就基本说的差不多了，现在来做一些总结：\",\"put 方法整体流程\",\"首先对于每一个放入的值，首先利用 spread 方法对 key 的 hashcode 进行一次 hash 计算，由此来确定这个值在 table 中的位置\",\"如果当前 table 数组还未初始化，先将 table 数组进行初始化操作\",\"如果这个位置是 null 的，那么使用 CAS 操作直接放入\",\"如果这个位置存在结点，说明发生了 hash 碰撞，首先判断这个节点的类型： \",\"如果该节点 fh == MOVED（代表 forwardingNode，数组正在进行扩容），说明正在进行扩容；\",\"如果是链表节点（fh > 0），则得到的结点就是 hash 值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到 key 相同的节点，则只需要覆盖该结点的 value 值即可。否则依次向后遍历，直到链表尾插入这个结点；\",\"如果这个节点的类型是 TreeBin，直接调用红黑树的插入方法进行插入新的节点。\",\"插入完节点之后再次检查链表长度，如果长度大于 8，就把这个链表转换成红黑树\",\"对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。\"]},\"400\":{\"h\":\"3.4 get 方法\",\"t\":[\"看完了 put 方法再来看 get 方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了。get 方法源码为：\",\"public V get(Object key) { Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek; // 1. 重hash int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { // 2. table[i]桶节点的key与查找的key相同，则直接返回 if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) return e.val; } // 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可 else if (eh < 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) { //4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可 if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; } } return null; }\",\"代码的逻辑请看注释，首先先看当前的 hash 桶数组节点即 table[i] 是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的 hash 值是否为小于 0，如果小于 0 则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若找到则返回节点的 value，若没有找到就返回 null。\"]},\"401\":{\"h\":\"3.5 transfer 方法\",\"t\":[\"当 ConcurrentHashMap 容量不足的时候，需要对 table 进行扩容。这个方法的基本思想跟 HashMap 是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足 concurrent 的要求，而是希望利用并发处理去减少扩容带来的时间影响。transfer方法源码为：\",\"private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) { int n = tab.length, stride; if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range // 1. 新建Node数组，容量为之前的两倍 if (nextTab == null) { // initiating try { @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } int nextn = nextTab.length; // 2. 新建forwardingNode引用，在之后会用到 ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) { Node<K,V> f; int fh; // 3. 确定遍历中的索引i while (advance) { int nextIndex, nextBound; if (--i >= bound || finishing) advance = false; else if ((nextIndex = transferIndex) <= 0) { i = -1; advance = false; } else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex > stride ? nextIndex - stride : 0))) { bound = nextBound; i = nextIndex - 1; advance = false; } } // 4. 将原数组中的元素复制到新数组中去 // 4.5 for循环退出，扩容结束修改sizeCtl属性 if (i < 0 || i >= n || i + n >= nextn) { int sc; if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n << 1) - (n >>> 1); return; } if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } // 4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符) else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); // 4.2 如果遍历到ForwardingNode节点 说明这个点已经被处理过了 直接跳过 这里是控制并发扩容的核心 else if ((fh = f.hash) == MOVED) advance = true; // already processed else { synchronized (f) { if (tabAt(tab, i) == f) { Node<K,V> ln, hn; if (fh >= 0) { // 4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表 另一个是原链表的反序排列 int runBit = fh & n; Node<K,V> lastRun = f; for (Node<K,V> p = f.next; p != null; p = p.next) { int b = p.hash & n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } for (Node<K,V> p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph & n) == 0) ln = new Node<K,V>(ph, pk, pv, ln); else hn = new Node<K,V>(ph, pk, pv, hn); } // 在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); // 在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); // 在table的i位置上插入forwardNode节点 表示已经处理过该节点 setTabAt(tab, i, fwd); // 设置advance为true 返回到上面的while循环中 就可以执行i--操作 advance = true; } // 4.4 处理当前节点是TreeBin时的情况，操作和上面的类似 else if (f instanceof TreeBin) { TreeBin<K,V> t = (TreeBin<K,V>)f; TreeNode<K,V> lo = null, loTail = null; TreeNode<K,V> hi = null, hiTail = null; int lc = 0, hc = 0; for (Node<K,V> e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode<K,V> p = new TreeNode<K,V> (h, e.key, e.val, null, null); if ((h & n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin<K,V>(lo) : t; hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin<K,V>(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } } } } } }\",\"代码逻辑请看注释，整个扩容操作分为两个部分：\",\"第一部分是构建一个 nextTable，它的容量是原来的两倍，这个操作是单线程完成的。新建 table数组的代码为：\",\"Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1]\",\"在原容量大小的基础上右移一位。\",\"第二部分就是将原来 table 中的元素复制到 nextTable 中，主要是遍历复制的过程。根据运算得到当前遍历的数组的位置 i，然后利用 tabAt 方法获得 i 位置的元素再进行判断：\",\"如果这个位置为空，就在原 table 中的 i 位置放入 forwardNode 节点，这个也是触发并发扩容的关键点；\",\"如果这个位置是 Node 节点（fh >= 0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在 nextTable 的 i 和 i+n 的位置上\",\"如果这个位置是 TreeBin 节点（fh < 0），也做一个反序处理，并且判断是否需要 untreefi，把处理的结果分别放在 nextTable 的 i 和 i+n 的位置上\",\"遍历过所有的节点以后就完成了复制工作，这时让 nextTable 作为新的 table，并且更新 sizeCtl 为新容量的 0.75 倍，完成扩容。\",\"设置为新容量的 0.75 倍代码为 sizeCtl = (n << 1) - (n >>> 1)，仔细体会下会发现很巧妙。n << 1 相当于 n 右移一位表示 n 的两倍即 2n，n >>> 1 右移一位相当于 2n​ 即 0.5n，然后两者相减为 2n−0.5n=1.5n，刚好等于新容量的 0.75 倍即 2n∗0.75=1.5n。\",\"最后用一个示意图来进行总结（图片摘自网络）：\",\"ConcurrentHashMap扩容示意图\"]},\"402\":{\"h\":\"3.6 与 size 相关的一些方法\",\"t\":[\"对于 ConcurrentHashMap 来说，这个 table 里到底装了多少东西其实是个不确定的数量，因为不可能在调用 size() 方法的时候像 GC 的 “stop the world” 一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap 也是大费周章才计算出来的。\",\"为了统计元素个数，ConcurrentHashMap 定义了一些变量和一个内部类：\",\"/** * A padded cell for distributing counts. Adapted from LongAdder * and Striped64. See their internal docs for explanation. */ @sun.misc.Contended static final class CounterCell { volatile long value; CounterCell(long x) { value = x; } } /******************************************/ /** * 实际上保存的是hashmap中的元素个数 利用CAS锁进行更新 * 但它并不用返回当前hashmap的元素个数 */ private transient volatile long baseCount; /** * Spinlock (locked via CAS) used when resizing and/or creating CounterCells. */ private transient volatile int cellsBusy; /** * Table of counter cells. When non-null, size is a power of 2. */ private transient volatile CounterCell[] counterCells;\",\"1. mappingCount 与 size 方法\",\"mappingCount 与 size 方法类似，从给出的注释来看，应该使用 mappingCount 代替 size 方法。两个方法都没有直接返回 basecount，而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。\",\"public int size() { long n = sumCount(); return ((n < 0L) ? 0 : (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } /** * Returns the number of mappings. This method should be used * instead of {@link #size} because a ConcurrentHashMap may * contain more mappings than can be represented as an int. The * value returned is an estimate; the actual count may differ if * there are concurrent insertions or removals. * * @return the number of mappings * @since 1.8 */ public long mappingCount() { long n = sumCount(); return (n < 0L) ? 0L : n; // ignore transient negative values } final long sumCount() { CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) { for (int i = 0; i < as.length; ++i) { if ((a = as[i]) != null) sum += a.value; // 所有counter的值求和 } } return sum; }\",\"2. addCount 方法\",\"在 put 方法结尾处调用了 addCount 方法，把当前 ConcurrentHashMap 的元素个数 +1。这个方法一共做了两件事，更新 baseCount 的值，检测是否进行扩容。\",\"private final void addCount(long x, int check) { CounterCell[] as; long b, s; // 利用CAS方法更新baseCount的值 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { fullAddCount(x, uncontended); return; } if (check <= 1) return; s = sumCount(); } // 如果check值大于等于0 则需要检验是否需要进行扩容操作 if (check >= 0) { Node<K,V>[] tab, nt; int n, sc; while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) { int rs = resizeStamp(n); // 当前线程不是唯一的或不是第一个发起扩容的线程 if (sc < 0) { if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0) break; // 如果已经有其他线程在执行扩容操作 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } // 当前线程是唯一的或是第一个发起扩容的线程 此时nextTable=null else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } }\"]},\"403\":{\"h\":\"4. 总结\",\"t\":[\"JDK6,7 中的 ConcurrentHashMap 主要使用 Segment 来实现减小锁粒度，分割成若干个 Segment，在 put 的时候需要锁住 Segment，get 时候不加锁，使用 volatile 来保证可见性，当要统计全局时（比如 size），首先会尝试多次计算 modcount 来确定，这几次尝试中，判断是否有其他线程进行了修改操作，如果没有，则直接返回 size。如果有，则需要依次锁住所有的 Segment 来计算。\",\"1.8 之前 put 定位节点时要先定位到具体的 segment，然后再在 segment 中定位到具体的桶。而在 1.8 的时候摒弃了 segment 臃肿的设计，直接针对的是 Node[] tale 数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于 8 的时候采用红黑树的设计。\",\"主要设计上的变化有以下几点:\",\"不采用 segment 而采用 node，锁住 node 来实现减小锁粒度。\",\"设计了 MOVED 状态，当 resize 的过程中，线程 2 还在 put 数据，线程 2 会帮助 resize。\",\"使用 3 个 CAS 操作来确保 node 的一些操作的原子性，这种方式代替了锁。\",\"sizeCtl 的不同值来代表不同含义，起到了控制的作用。\",\"采用 synchronized 而不是 ReentrantLock\",\"更多关于 1.7 版本与 1.8 版本的 ConcurrentHashMap 的实现对比，可以参考这篇 —— 谈谈ConcurrentHashMap1.7和1.8的不同实现。\",\"参考文章：深入浅出ConcurrentHashMap1.8\"]},\"404\":{\"c\":[\"并发编程\"]},\"405\":{\"c\":[\"JUC\"]},\"406\":{\"h\":\"并发容器之 ConcurrentLinkedQueue\"},\"407\":{\"h\":\"1. ConcurrentLinkedQueue 简介\",\"t\":[\"在单线程编程中我们会经常用到一些集合类，比如 ArrayList，HashMap 等，但是这些类都不是线程安全的类。在面试中也经常会有一些考点，比如 ArrayList 不是线程安全的，Vector 是线程安全。而保障 Vector 线程安全的方式，是非常粗暴的在方法上用 synchronized 独占锁，将多线程执行变成串行化。要想将 ArrayList 变成线程安全的也可以使用 Collections.synchronizedList(List<T> list) 方法将 ArrayList 转换成线程安全的，但这种转换方式依然是通过 synchronized 修饰方法实现的，很显然这不是一种高效的方式。\",\"同时，队列也是我们常用的一种数据结构。为了解决线程安全的问题，DougLea 大师为我们准备了 ConcurrentLinkedQueue 这个线程安全的队列。从类名就可以看的出来实现队列的数据结构是链式。\"]},\"408\":{\"h\":\"1.1 Node\",\"t\":[\"要想先学习 ConcurrentLinkedQueue 自然而然得先从它的节点类看起，明白它的底层数据结构。Node 类的源码为：\",\"private static class Node<E> { volatile E item; volatile Node<E> next; ....... }\",\"Node 节点主要包含了两个域：一个是数据域 item，另一个是 next 指针，用于指向下一个节点从而构成链式队列。并且都是用volatile进行修饰的，以保证内存可见性（关于 volatile 可以看这篇文章）。\",\"另外 ConcurrentLinkedQueue 含有这样两个成员变量：\",\"private transient volatile Node<E> head; private transient volatile Node<E> tail;\",\"说明 ConcurrentLinkedQueue 通过持有头尾指针进行管理队列。当我们调用无参构造器时，其源码为：\",\"public ConcurrentLinkedQueue() { head = tail = new Node<E>(null); }\",\"head 和 tail 指针会指向一个 item 域为 null 的节点，此时 ConcurrentLinkedQueue 状态如下图所示：\",\"ConcurrentLinkedQueue初始化状态\",\"如图，head 和 tail 指向同一个节点 Node0，该节点 item 域为 null，next域为 null。\"]},\"409\":{\"h\":\"1.2 操作 Node 的几个 CAS 操作\",\"t\":[\"在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。可以看出在处理器指令集能够支持 CMPXCHG 指令后，在 Java 源码中涉及到并发处理都会使用 CAS 操作，那么在 ConcurrentLinkedQueue 中对 Node 的 CAS 操作有这样几个：\",\"// 更改Node中的数据域item boolean casItem(E cmp, E val) { return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); } // 更改Node中的指针域next void lazySetNext(Node<E> val) { UNSAFE.putOrderedObject(this, nextOffset, val); } // 更改Node中的指针域next boolean casNext(Node<E> cmp, Node<E> val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); }\",\"可以看出这些方法实际上是通过调用 UNSAFE 实例的方法，UNSAFE 为 sun.misc.Unsafe 类，该类是 hotspot 底层方法，目前为止了解即可，知道 CAS 的操作归根结底是由该类提供就好。\"]},\"410\":{\"c\":[\"并发编程\"]},\"411\":{\"c\":[\"JUC\"]},\"412\":{\"h\":\"线程状态及其属性\",\"t\":[\"线程的 6 种状态:\",\"New（新建）\",\"Runable（可运行）\",\"Blocked（阻塞）\",\"Waiting（等待）\",\"Timed Waiting（计时等待）\",\"Terminates（终止）\",\"要确定一个线程的当前状态，只需要调用 getState() 方法。\"]},\"413\":{\"h\":\"1. 新建线程\",\"t\":[\"一个 java 程序从 main() 方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上 java 程序天生就是一个多线程程序，包含了：\",\"（1）分发处理发送给给 JVM 信号的线程；\",\"（2）调用对象的 finalize 方法的线程；\",\"（3）清除 Reference 的线程；\",\"（4）main 线程，用户程序的入口。\",\"在用户程序中新建一个线程，一般有四种方式：\",\"通过继承 Thread 类，重写 run 方法；\",\"通过实现 runable 接口；\",\"通过实现 callable 接口；\",\"通过线程池创建。\",\"创建线程池Demo：\",\"public class CreateThreadDemo { public static void main(String[] args) { // 1.继承Thread Thread thread = new Thread() { @Override public void run() { System.out.println(\\\"继承Thread\\\"); super.run(); } }; thread.start(); // 2.实现runable接口 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(\\\"实现runable接口\\\"); } }); thread1.start(); // 3.实现callable接口 ExecutorService service = Executors.newSingleThreadExecutor(); Future<String> future = service.submit(new Callable() { @Override public String call() throws Exception { return \\\"通过实现Callable接口\\\"; } }); try { String result = future.get(); System.out.println(result); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } }\",\"第四种通过线程池新建线程后面单拎出来。\",\"以上三种新建线程的方式需要注意的是：\",\"由于 java 不能多继承可以实现多个接口，因此，在创建线程的时候尽量多考虑采用实现接口的形式；\",\"实现 callable 接口，提交给 ExecutorService 返回的是异步执行的结果，另外，通常也可以利用 FutureTask(Callable callable) 将 callable 进行包装然后 FeatureTask 提交给 ExecutorsService。如下图所示：\",\"另外由于 FeatureTask 也实现了 Runable 接口，也可以利用上面第二种方式（实现 Runable 接口）来新建线程；\",\"可以通过 Executors 将 Runable 转换成 Callable，具体方法是：\",\"Callable callable(Runnable task, T result); Callable callable(Runnable task);\",\"注意\",\"不要调用 Thread 类或 Runnable 对象的 run 方法。直接调用 run 方法只会在同一个线程中执行这个任务，而没有启动新的线程。\",\"实际上，应当调用 Thread.start() 方法，这会创建一个新线程来执行 run 方法。\"]},\"414\":{\"h\":\"2. 可运行线程\",\"t\":[\"一旦调用 start 方法，线程就处于可运行状态。一个可运行的线程可能正在运行，也可能没有运行，要由操作系统为线程提供具体的运行时间。\",\"一旦一个线程开始运行，它不一定始终保持运行。事实上，运行中的线程有时需要暂停，让其他线程有机会运行。线程调度的细节依赖于操作系统提供的服务。\",\"抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完时，操作系统会剥夺该线程的运行权，并给另一个线程一个机会来运行。当选择下一个线程时，操作系统会考虑线程的优先级。\",\"所有现代桌面和服务器操作系统都是用抢占式调度。但是，对于像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法或者像被阻塞或等待时才失去控制权。\",\"在有多个处理器的机器上，每个处理器可以运行一个线程，而且可以有多个线程并行运行。但如果线程数多于处理器的数目，调度器仍然需要分配时间片。\"]},\"415\":{\"h\":\"3. 阻塞和等待线程\",\"t\":[\"当线程处于阻塞或等待状态时，它是暂时不活动的，不执行任何代码，且消耗最少的资源。要由线程调度器重新激活这个线程。\",\"当一个线程试图获取一个内部的对象锁，而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态。\",\"当线程等待另一个线程通知调度器出现某个条件时，这个线程会进入等待状态。\"]},\"416\":{\"h\":\"4. 终止线程\",\"t\":[\"线程会由于以下两个原因之一而终止：\",\"由于 run 方法正常退出，线程自然终于。\",\"由于一个没有捕获到的异常终止了 run 方法，使线程意外终止。\"]},\"417\":{\"h\":\"5. 线程状态转换\",\"t\":[\"此图来源于《JAVA并发编程的艺术》一书中，线程是会在不同的状态间进行转换的，java 线程线程转换图如上图所示。\",\"线程创建之后调用 start() 方法开始运行，当调用 wait()，join()，LockSupport.lock() 方法线程会进入到 WAITING 状态；\",\"而同样的 wait(long timeout)，sleep(long)，join(long)，LockSupport.parkNanos()，LockSupport.parkUtil() 增加了超时等待的功能，也就是调用这些方法后线程会进入 TIMED_WAITING 状态；\",\"当超时等待时间到达后，线程会切换到 Runable 的状态，另外当 WAITING 和 TIMED _WAITING 状态时可以通过 Object.notify()，Object.notifyAll() 方法使线程转换到 Runable 状态；\",\"当线程出现资源竞争时，即等待获取锁的时候，线程会进入到 BLOCKED 阻塞状态；\",\"当线程获取锁时，线程进入到 Runable 状态；\",\"线程运行结束后，线程进入到 TERMINATED 状态。\",\"状态转换可以说是线程的生命周期。另外需要注意的是：\",\"当一个线程被重新激活，调度器会先检查它是否具有比当前允许线程更高的优先级。如果是，则调度器会剥夺某个当前允许线程的运行权，选择运行该新线程。\",\"当线程进入到 synchronized 方法或者 synchronized 代码块时，线程切换到的是 BLOCKED 状态，而使用 java.util.concurrent.locks 下 lock 进行加锁的时候线程切换的是 WAITING 或者 TIMED_WAITING 状态，因为 lock 会调用 LockSupport 的方法。\",\"用一个表格将上面六种状态进行一个总结归纳。\"]},\"418\":{\"h\":\"6. 线程的基本操作\"},\"419\":{\"h\":\"6.1 interrupted\",\"t\":[\"中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的 interrupt() 方法对其进行中断操作，同时该线程可以调用 isInterrupted() 来感知其他线程对其自身的中断操作，从而做出响应。另外，同样可以调用 Thread 的静态方法 interrupted() 对当前线程进行中断操作，该方法会清除中断标志位。\",\"注意\",\"当抛出 InterruptedException 时候，会清除中断标志位，也就是说在调用 isInterrupted() 会返回 false。\",\"结合具体的实例看一看：\",\"public class InterruptDemo { public static void main(String[] args) throws InterruptedException { // sleepThread睡眠1000ms final Thread sleepThread = new Thread() { @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } super.run(); } }; // busyThread一直执行死循环 Thread busyThread = new Thread() { @Override public void run() { while (true) ; } }; sleepThread.start(); busyThread.start(); sleepThread.interrupt(); busyThread.interrupt(); while (sleepThread.isInterrupted()); System.out.println(\\\"sleepThread isInterrupted: \\\" + sleepThread.isInterrupted()); System.out.println(\\\"busyThread isInterrupted: \\\" + busyThread.isInterrupted()); } }\",\"输出结果：\",\"sleepThread isInterrupted: false busyThread isInterrupted: true\",\"开启了两个线程分别为 sleepThread 和 BusyThread，sleepThread 睡眠 1s，BusyThread 执行死循环。然后分别对着两个线程进行中断操作，可以看出 sleepThread 抛出 InterruptedException 后清除标志位，而 busyThread 就不会清除标志位。\",\"另外，同样可以通过中断的方式实现线程间的简单交互，while (sleepThread.isInterrupted()) 表示在 Main 中会持续监测 sleepThread，一旦 sleepThread 的中断标志位清零，即 sleepThread.isInterrupted() 返回为 false 时才会继续，Main 线程才会继续往下执行。因此，中断操作可以看做线程间一种简便的交互方式。\",\"一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。\"]},\"420\":{\"h\":\"6.2 join\",\"t\":[\"join 方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出，这就像两个好基友，一个基友先走在前面突然看见另一个基友落在后面了，这个时候他就会在原处等一等这个基友，等基友赶上来后，就两人携手并进。其实线程间的这种协作方式也符合现实生活。在软件开发的过程中，从客户那里获取需求后，需要经过需求分析师进行需求分解后，这个时候产品，开发才会继续跟进。\",\"如果一个线程实例 A 执行了 threadB.join()，其含义是：当前线程 A 会等待 threadB 线程终止后 threadA 才会继续执行。\",\"关于 join 方法一共提供如下这些方法:\",\"public final synchronized void join(long millis); public final synchronized void join(long millis, int nanos); public final void join() throws InterruptedException;\",\"Thread 类除了提供 join() 方法外，另外还提供了超时等待的方法，如果线程 threadB 在等待的时间内还没有结束的话，threadA 会在超时之后继续执行。\",\"join方法源码关键是：\",\"while (isAlive()) { wait(0); }\",\"可以看出来当前等待对象 threadA 会一直阻塞，直到被等待对象 threadB 结束后即 isAlive() 返回 false 的时候才会结束 while 循环，当 threadB 退出时会调用 notifyAll() 方法通知所有的等待线程。\",\"下面用一个具体的例子来说说 join 方法的使用：\",\"public class JoinDemo { public static void main(String[] args) { Thread previousThread = Thread.currentThread(); for (int i = 1; i <= 10; i++) { Thread curThread = new JoinThread(previousThread); curThread.start(); previousThread = curThread; } } static class JoinThread extends Thread { private Thread thread; public JoinThread(Thread thread) { this.thread = thread; } @Override public void run() { try { thread.join(); System.out.println(thread.getName() + \\\" terminated.\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }\",\"输出结果为：\",\"main terminated. Thread-0 terminated. Thread-1 terminated. Thread-2 terminated. Thread-3 terminated. Thread-4 terminated. Thread-5 terminated. Thread-6 terminated. Thread-7 terminated. Thread-8 terminated.\",\"在上面的例子中一个创建了 10 个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程......\"]},\"421\":{\"h\":\"6.3 sleep\",\"t\":[\"public static native void sleep(long millis)\",\"这个方法显然是 Thread 的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。\",\"需要注意的是如果当前线程获得了锁，sleep 方法并不会失去锁。\",\"sleep() 方法经常拿来与 Object.wait() 方法进行比价，这也是面试经常被问的地方。\",\"sleep() VS wait()\",\"两者主要的区别：\",\"sleep() 方法是 Thread 的静态方法，而 wait() 是 Object 实例方法。\",\"wait() 方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而 sleep() 方法没有这个限制可以在任何地方种使用。另外，wait() 方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源，而 sleep() 方法只是会让出CPU并不会释放掉对象锁。\",\"sleep() 方法在休眠时间达到后如果再次获得 CPU 时间片就会继续执行，而 wait() 方法必须等待 Object.notift/Object.notifyAll 通知后，才会离开等待池，并且再次获得 CPU 时间片才会继续执行。\"]},\"422\":{\"h\":\"6.4 yield\",\"t\":[\"public static native void yield();\",\"这是一个静态方法，一旦执行，它会使当前线程让出 CPU，但是，需要注意的是，让出的 CPU 并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了 CPU 时间片当前线程依然会继续运行。另外，让出的时间片只会分配给当前线程相同优先级的线程。\",\"什么是线程优先级呢？⬇️\",\"线程优先级\",\"现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。\",\"在 Java 程序中，每个线程都有一个优先级。默认情况下，一个线程会继承构造它的那个线程的优先级。通过一个整型成员变量 Priority 来控制优先级，优先级的范围从 1 ~ 10。在构建线程的时候可以通过 setPriority(int) 方法进行设置，默认优先级为 5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同 JVM 以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。\",\"另外需要注意的是，sleep() 和 yield() 方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep() 交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而 yield() 方法只允许与当前线程具有相同优先级的线程能够获得释放出来的 CPU 时间片。\"]},\"423\":{\"h\":\"7. 守护线程 Daemon\",\"t\":[\"守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT 线程就可以理解守护线程。\",\"与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退出。\",\"当一个 Java 应用，只有守护线程的时候，虚拟机就会自然退出。\",\"下面以一个简单的例子来表述 Daemon 线程的使用。\",\"public class DaemonDemo { public static void main(String[] args) { Thread daemonThread = new Thread(new Runnable() { @Override public void run() { while (true) { try { System.out.println(\\\"i am alive\\\"); Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\\\"finally block\\\"); } } } }); daemonThread.setDaemon(true); daemonThread.start(); //确保main线程结束前能给daemonThread能够分到时间片 try { Thread.sleep(800); } catch (InterruptedException e) { e.printStackTrace(); } } }\",\"输出结果为：\",\"i am alive finally block i am alive\",\"上面的例子中，daemodThread 的 run 方法中是一个 while 死循环，会一直打印，但是当 main 线程结束后 daemonThread 就会退出所以不会出现死循环的情况。main 线程先睡眠 800ms 保证 daemonThread 能够拥有一次时间片的机会，也就是说可以正常执行一次打印 “i am alive” 操作和一次 finally 块中 “finally block” 操作。紧接着 main 线程结束后，daemonThread 退出，这个时候只打印了 “i am alive” 并没有打印 finally 块中的语句。\",\"因此，这里需要注意的是守护线程在退出的时候并不会执行 finnaly 块中的代码，所以将释放资源等操作不要放在 finnaly 块中执行，这种操作是不安全的。\",\"线程可以通过 setDaemon(true) 的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于 start() 方法，否则会报\",\"Exception in thread \\\"main\\\" java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1365) at learn.DaemonDemo.main(DaemonDemo.java:19)\",\"这样的异常，但是该线程还是会执行，只不过会当做正常的用户线程执行。\"]},\"424\":{\"c\":[\"并发编程\"]},\"425\":{\"c\":[\"JUC\"]},\"426\":{\"h\":\"Java 内存模型及 happens-before\"},\"427\":{\"h\":\"1. JMM 介绍\",\"t\":[\"什么是线程安全？\",\"关于线程安全问题，《深入理解Java虚拟机》中给出的定义如下：\",\"当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象就是线程安全的。\",\"出现线程安全的问题一般是因为主内存和工作内存数据不一致性和重排序导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，其核心在于理解 java 内存模型（JMM）。\",\"在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等，另外，为了性能优化，还会涉及到编译器指令重排序和处理器指令重排序。\"]},\"428\":{\"h\":\"2. 线程通信\",\"t\":[\"线程间协作通信可以类比人与人之间的协作的方式。\",\"在现实生活中，网上有个流行语 “你妈喊你回家吃饭了”，就以这个生活场景为例，小明在外面玩耍，小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：\",\"一种方式是：小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条 “饭做好了，放在...”。小明回家后看到纸条如愿吃到妈妈做的饭菜，那么，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写共享变量实现两个线程间协作；\",\"另一种方式是：妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是通知机制来完成协作。同样，可以引申到线程间通信机制。\",\"通过上面的例子，大概有个了解。在并发编程中主要需要解决两个问题：\",\"线程之间如何通信；\",\"线程之间如何完成同步（这里的线程指的是并发执行的活动实体）。\",\"通信是指线程之间以何种机制来交换信息，主要有两种：共享内存和消息传递。\",\"java 内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量来完成隐式通信。\",\"哪些是共享变量\",\"在java程序中所有实例域，静态域和数组元素都是放在堆内存中（所有线程均可访问到，是可以共享的）；\",\"而局部变量，方法定义参数和异常处理器参数不会在线程间共享。\",\"共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。\"]},\"429\":{\"h\":\"3. JMM 抽象结构模型\",\"t\":[\"我们知道 CPU 的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个 CPU 都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM 就从抽象层次定义了这种方式，并且 JMM 决定了一个线程对共享变量的写入何时对其他线程是可见的。\",\"如上图为 JMM 抽象示意图，线程 A 和线程 B 之间要完成通信的话，要经历如下两步：\",\"线程 A 从主内存中将共享变量读入线程 A 的工作内存后并进行操作，之后将数据重新写回到主内存中\",\"线程 B 从主存中读取最新的共享变量\",\"从横向上看，线程 A 和线程 B 就好像通过共享变量在进行隐式通信。\",\"这其中有一个问题，如果线程 A 更新后数据并没有及时写回到主存，而此时线程 B 读到的是过期的数据，这就出现了 “脏读” 现象。针对这种情况，可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过 volatile 关键字使得每次 volatile 变量都能够强制刷新到主存，从而对每个线程都是可见的。\"]},\"430\":{\"h\":\"4. 重排序\",\"t\":[\"一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。JMM 对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\",\"编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序\",\"指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序\",\"内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。\",\"如图，1 属于编译器重排序，而 2 和 3 统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是 DCL 问题。\",\"针对编译器重排序，JMM 的编译器重排序规则会禁止一些特定类型的编译器重排序；\",\"针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序。\",\"那么什么情况下，不能进行重排序？比如数据依赖性。有如下代码：\",\"double pi = 3.14 //A double r = 1.0 //B double area = pi * r * r //C\",\"这是一个计算圆面积的代码，由于 A，B 之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是 A->B->C 或者 B->A->C，执行最终结果都是 3.14，即 A 和 B 之间没有数据依赖性。具体的定义为：\",\"**如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性。**这里就存在三种情况：\",\"读后写；\",\"写后写；\",\"写后读。\",\"这三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。\",\"另外，还有一个比较有意思的就是 as-if-serial 语义。\",\"as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上 A，B 两行不存在数据依赖性可能会进行重排序，即 A，B 不是顺序执行的。as-if-serial 语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。\"]},\"431\":{\"h\":\"5. happens-before 规则\",\"t\":[\"上面的重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM 为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。下面以两个方面来说。\"]},\"432\":{\"h\":\"5.1 happens-before 定义\",\"t\":[\"happens-before 的概念最初由 Leslie Lamport 提出。JSR-133 使用 happens-before 的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证（如果 A 线程的写操作 a 与 B 线程的读操作 b 之间存在 happens-before 关系，尽管 a 操作和 b 操作在不同的线程中执行，但 JMM 向程序员保证 a 操作将对 b 操作可见）。具体的定义为：\",\"如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\",\"两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）。\",\"上面的第 1 点是 JMM 对程序员的承诺。从程序员的角度来说，可以这样理解 happens-before 关系：如果A happens-before B，那么 Java 内存模型将向程序员保证 —— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。注意，这只是 Java 内存模型向程序员做出的保证！\",\"上面的第 2 点是 JMM 对编译器和处理器重排序的约束原则。正如前面所言，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM 这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before 关系本质上和 as-if-serial 语义是一回事。\",\"as-if-serial VS happens-before\",\"as-if-serial 语义保证单线程内程序的执行结果不被改变，happens-before 关系保证正确同步的多线程程序的执行结果不被改变。\",\"as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。\",\"as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\"]},\"433\":{\"h\":\"5.2 具体规则\",\"t\":[\"具体的一共有六项规则：\",\"程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。\",\"监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\",\"volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\",\"传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。\",\"start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。\",\"join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。\",\"程序中断规则：对线程 interrupted() 方法的调用先行于被中断线程的代码检测到中断时间的发生。\",\"对象 finalize 规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的 finalize() 方法的开始。\",\"下面以一个具体的例子来讲下如何使用这些规则进行推论：\",\"依旧以上面计算圆面积的进行描述。利用程序顺序规则（规则1）存在三个 happens-before 关系：\",\"A happens-before B；\",\"B happens-before C；\",\"A happens-before C。\",\"这里的第三个关系是利用传递性进行推论的。A happens-before B，定义 1 要求 A 执行结果对 B 可见，并且 A 操作的执行顺序在 B 操作之前，但与此同时利用定义中的第二条，A，B 操作彼此不存在数据依赖性，两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许 A，B 两个操作重排序，即 happens-before 关系并不代表了最终的执行顺序。\"]},\"434\":{\"h\":\"6. 总结\",\"t\":[\"我们从三个方面做个总结。\",\"如果让我们设计 JMM 应该从哪些方面考虑，也就是说 JMM 承担哪些功能\",\"happens-before 与 JMM 的关系\",\"由于 JMM，多线程情况下可能会出现哪些问题？\"]},\"435\":{\"h\":\"6.1 JMM 的设计\",\"t\":[\"JMM 是语言级的内存模型，在我的理解中 JMM 处于中间层，包含了两个方面： （1）内存模型；（2）重排序以及 happens-before 规则。\",\"同时，为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制。而上层会有基于 JMM 的关键字和 J.U.C 包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程。站在 JMM 设计者的角度，在设计 JMM 时需要考虑两个关键因素:\",\"程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。\",\"编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。\",\"另外还要一个特别有意思的事情就是关于重排序问题，更简单的说，重排序可以分为两类：\",\"会改变程序执行结果的重排序。\",\"不会改变程序执行结果的重排序。\",\"JMM 对这两种不同性质的重排序，采取了不同的策略，如下。\",\"对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。\",\"对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不做要求（JMM 允许这种重排序）\",\"JMM的设计图为：\",\"从上图中可以看出：\",\"JMM 向程序员提供的 happens-before 规则能满足程序员的需求。 JMM 的 happens-before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens-before B）。\",\"JMM 对编译器和处理器的束缚已经尽可能少。 从上面的分析可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个 volatile 变量只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。\"]},\"436\":{\"h\":\"6.2 happens-before 与 JMM 的关系\",\"t\":[\"一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。对于 Java 程序员来说，happens-before 规则简单易懂，它避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。\"]},\"437\":{\"h\":\"6.3 今后可能需要关注的问题\",\"t\":[\"从上面内存抽象结构来说，可能出在数据 “脏读” 的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是 DCL（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如 i++ 不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。\"]},\"438\":{\"c\":[\"并发编程\"]},\"439\":{\"c\":[\"JUC\"]},\"440\":{\"h\":\"彻底理解 synchronized\"},\"441\":{\"h\":\"1. synchronized 简介\",\"t\":[\"先看一个现象：\",\"public class SynchronizedDemo implements Runnable { private static int count = 0; public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(new SynchronizedDemo()); thread.start(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"result: \\\" + count); } @Override public void run() { for (int i = 0; i < 1000000; i++) count++; } }\",\"开启 10 个线程，每个线程都累加了 1000000 次，如果结果正确的话自然而然总数就应该是 10∗1000000=10000000。可无论运行多少次，结果都不是这个数，而且每次运行结果都不一样。这是为什么？有什么解决方案？\",\"在上一篇中我们已经了解了 java 内存模型的一些知识，并且已经知道出现线程安全的主要来源于 JMM 的设计，主要集中在主内存和线程的工作内存而导致的内存可见性问题，以及重排序导致的问题，进一步知道了 happens-before 规则。线程运行时拥有自己的栈空间，会在自己的栈空间运行，如果多线程间没有共享的数据也就是说多线程间并没有协作完成一件事情，那么，多线程就不能发挥优势，不能带来巨大的价值。那么共享数据的线程安全问题怎样处理？很自然而然的想法就是每一个线程依次去读写这个共享变量，这样就不会有任何数据安全的问题，因为每个线程所操作的都是当前最新的版本数据。\",\"那么，在 java 中关键字 synchronized 就具有使每个线程依次排队操作共享变量的功能。很显然，这种同步机制效率很低，但 synchronized 是其他并发容器实现的基础。\"]},\"442\":{\"h\":\"2. synchronized 实现原理\",\"t\":[\"在 java 代码中 synchronized 可使用在代码块和方法中，根据 Synchronized 用的位置可以有这些使用场景：\",\"如图，synchronized 可以用在方法上也可以使用在代码块中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：如果锁的是类对象的话，尽管 new 多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。\"]},\"443\":{\"h\":\"2.1 对象锁（monitor）机制\",\"t\":[\"用一个简单的 demo 来看看 synchronized 的具体底层实现：\",\"public class SynchronizedDemo { public static void main(String[] args) { synchronized (SynchronizedDemo.class) { } method(); } private static void method() { } }\",\"上面的代码中有一个同步代码块，锁住的是类对象，并且还有一个同步静态方法，锁住的依然是该类的类对象。编译之后，切换到 SynchronizedDemo.class 的同级目录之后，然后用 javap -v SynchronizedDemo.class 查看字节码文件：\",\"SynchronizedDemo.class\",\"如图，上面用黄色高亮的部分就是需要注意的部分了，这也是添加 Synchronized 关键字之后独有的。执行同步代码块后首先要先执行 monitorenter 指令，退出的时候 monitorexit 指令。\",\"通过分析之后可以看出，使用 Synchronized 进行同步，其关键就是必须要对对象的监视器 monitor 进行获取，当线程获取 monitor 后才能继续往下执行，否则就只能等待。而这个获取的过程是互斥的，即同一时刻只有一个线程能够获取到 monitor。上面的 demo 中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条 monitorexit 指令，并没有 monitorenter 获取锁的指令。\",\"这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。\",\"任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到 BLOCKED 状态。\",\"下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：\",\"该图可以看出，任意线程对 Object 的访问，首先要获得 Object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为 BLOCKED，当 Object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。\"]},\"444\":{\"h\":\"2.2 synchronized 的 happens-before 关系\",\"t\":[\"在上一篇讨论过 happens-before 规则，现在来看一看 Synchronized 的 happens-before 规则，即监视器锁规则：对同一个监视器的解锁，happens-before 于对该监视器的加锁。继续来看代码：\",\"public class MonitorDemo { private int a = 0; public synchronized void writer() { // 1 a++; // 2 } // 3 public synchronized void reader() { // 4 int i = a; // 5 } // 6 }\",\"该代码的 happens-before 关系如图所示：\",\"在图中每一个箭头连接的两个节点就代表之间的 happens-before 关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程 A 释放锁 happens-before 线程 B 加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来 happens-befor 关系，通过传递性规则进一步推导的 happens-before 关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么？\",\"根据 happens-before 的定义中的一条：如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B。线程 A 先对共享变量 A 进行加一，由 2 happens-before 5 关系可知线程 A 的执行结果对线程 B 可见即线程 B 所读取到的 a 的值为 1。\"]},\"445\":{\"h\":\"2.3 锁获取和锁释放的内存语义\",\"t\":[\"在上一篇提到过 JMM 核心为两个部分：happens-before 规则以及内存抽象模型。我们分析完 Synchronized 的 happens-before 关系后，还是不太完整的，我们接下来看看基于 java 内存抽象模型的 Synchronized 的内存语义。\",\"继续先看图：\",\"从上图可以看出，线程 A 会首先先从主内存中读取共享变量 a = 0 的值然后将该变量拷贝到自己的本地内存，进行加一操作后，再将该值刷新到主内存，整个过程即为 线程 A 加锁 --> 执行临界区代码 --> 释放锁相对应的内存语义。\",\"线程 B 获取锁的时候同样会从主内存中共享变量 a 的值，这个时候就是最新的值 1，然后将该值拷贝到线程 B 的工作内存中去，释放锁的时候同样会重写到主内存中。\",\"从整体上来看，线程 A 的执行结果（a = 1）对线程 B 是可见的，实现原理为：释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。另外也验证了 2 happens-before 5，2 的执行结果对 5 是可见的。\",\"从横向来看，这就像线程 A 通过主内存中的共享变量和线程 B 进行通信，A 告诉 B 我们俩的共享数据现在为 1 啦，这种线程间的通信机制正好吻合 java 的内存模型正好是共享内存的并发模型结构。\"]},\"446\":{\"h\":\"3. synchronized优化\",\"t\":[\"通过上面的讨论大概能了解 Synchronized了，它最大的特征就是在同一时刻只有一个线程能够获得对象的监视器（monitor），从而进入到同步代码块或者同步方法之中，即表现为互斥性（排它性）。\",\"这种方式肯定效率低下，每次只能通过一个线程，既然每次只能通过一个，这种形式不能改变的话，那么我们能不能让每次通过的速度变快一点了。打个比方，去收银台付款，之前的方式是，大家都去排队，然后去纸币付款收银员找零，有的时候付款的时候在包里拿出钱包再去拿出钱，这个过程是比较耗时的，然后，支付宝解放了大家去钱包找钱的过程，现在只需要扫描下就可以完成付款了，也省去了收银员跟你找零的时间了。同样是需要排队，但整个付款的时间大大缩短，是不是整体的效率变高速率变快了？这种优化方式同样可以引申到锁优化上，缩短获取锁的时间，伟大的科学家们也是这样做的，令人钦佩，毕竟 java 是这么优秀的语言😀。\",\"在聊到锁的优化也就是锁的几种状态前，有两个知识点需要先关注：（1）CAS操作 （2）Java对象头，这是理解下面知识的前提条件。\"]},\"447\":{\"h\":\"3.1 CAS 操作\"},\"448\":{\"h\":\"3.1.1 什么是 CAS？\",\"t\":[\"使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而 CAS 操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用 CAS(compare and swap)，又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\"]},\"449\":{\"h\":\"3.1.2 CAS 的操作过程\",\"t\":[\"CAS 比较交换的过程可以通俗的理解为 CAS(V, O, N)，包含三个值分别为：\",\"V 内存地址存放的实际值\",\"O 预期的值（旧值）\",\"N 更新的新值\",\"当 V 和 O 相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值 O 就是目前来说最新的值了，自然而然可以将新值 N 赋值给 V。反之，V 和 O 不相同，表明该值已经被其他线程改过了则该旧值 O 不是最新版本的值了，所以不能将新值 N 赋给 V，返回 V 即可。当多个线程使用 CAS 操作一个变量时，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。\",\"CAS 的实现需要硬件指令集的支撑，在 JDK1.5 后虚拟机才可以使用处理器提供的 CMPXCHG 指令实现。\",\"Synchronized VS CAS\",\"元老级的 Synchronized(未优化前) 最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。\",\"而 CAS 并不是武断的间线程挂起，当 CAS 操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\"]},\"450\":{\"h\":\"3.1.3 CAS 的应用场景\",\"t\":[\"在 J.U.C 包中利用 CAS 实现类有很多，可以说是支撑起整个 concurrency 包的实现，在 Lock 实现中会有 CAS 改变 state 变量，在 atomic 包中的实现类也几乎都是用 CAS 实现。\"]},\"451\":{\"h\":\"3.1.4 CAS 的问题\",\"t\":[\"ABA 问题\",\"因为 CAS 会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值 A 变为了成 B，然后再变成 A，刚好在做 CAS 时检查发现旧值并没有变化依然为 A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径 A->B->A 就变成了 1A->2B->3C。java 这么优秀的语言，当然在 java 1.5 后的 atomic 包中提供了 AtomicStampedReference 来解决 ABA 问题了。\",\"自旋时间过长\",\"使用 CAS 时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果 JVM 能支持处理器提供的 pause 指令，那么在效率上会有一定的提升。\",\"只能保证一个共享变量的原子操作\",\"当对一个共享变量执行操作时 CAS 能保证其原子性，如果对多个共享变量进行操作，CAS 就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做 CAS 操作就可以保证其原子性。atomic 中提供了 AtomicReference 来保证引用对象之间的原子性。\"]},\"452\":{\"h\":\"3.2 Java 对象头\",\"t\":[\"在同步的时候是获取对象的 monitor，即获取到对象的锁。\",\"那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在 Java 对象的对象头。\",\"Java 对象头里的 Mark Word 里默认的存放的对象的 Hashcode，分代年龄和锁标记位。32 位 JVM Mark Word 默认存储结构为：\",\"Mark Word 存储结构\",\"如图在 Mark Word 会默认存放 hasdcode，年龄值以及锁标志位等信息。\",\"JavaSE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。\",\"锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：\",\"Mark Word 状态变化\"]},\"453\":{\"h\":\"3.3 偏向锁\",\"t\":[\"HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。\"]},\"454\":{\"h\":\"3.3.1 偏向锁的获取\",\"t\":[\"当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。\"]},\"455\":{\"h\":\"3.3.2 偏向锁的撤销\",\"t\":[\"偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。\",\"偏向锁撤销流程\",\"如上图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。\",\"下图线程 1 展示了偏向锁获取的过程，线程 2 展示了偏向锁撤销的过程。\"]},\"456\":{\"h\":\"3.3.3 如何关闭偏向锁\",\"t\":[\"偏向锁在 Java 6 和 Java 7 里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用 JVM 参数来关闭延迟：-XX:BiasedLockingStartupDelay = 0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking = false，那么程序默认会进入轻量级锁状态。\"]},\"457\":{\"h\":\"3.4 轻量级锁\"},\"458\":{\"h\":\"3.4.1 加锁\",\"t\":[\"线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\"]},\"459\":{\"h\":\"3.4.2 解锁\",\"t\":[\"轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。\",\"下图是两个线程同时争夺锁，导致锁膨胀的流程图。\",\"因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。\"]},\"460\":{\"h\":\"3.5 各种锁的比较\"},\"461\":{\"h\":\"4. 一个例子\",\"t\":[\"经过上面的理解，对于文章开头的现象，就知道如何解决了：\",\"public class SynchronizedDemo implements Runnable { private static int count = 0; public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(new SynchronizedDemo()); thread.start(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"result: \\\" + count); } @Override public void run() { synchronized (SynchronizedDemo.class) { for (int i = 0; i < 1000000; i++) count++; } } }\",\"开启 10 个线程，每个线程在原值上累加 1000000 次，最终正确的结果为 10∗1000000=10000000，这里能够计算出正确的结果是因为在做累加操作时使用了同步代码块，这样就能保证每个线程所获得共享变量的值都是当前最新的值，如果不使用同步的话，就可能会出现 A 线程累加后，而 B 线程做累加操作有可能是使用原来的就值，即“脏值”。这样，就导致最终的计算结果不是正确的。\",\"而使用 Syncnized 就可以保证内存可见性，保证每个线程都是操作的最新值。\"]},\"462\":{\"c\":[\"并发编程\"]},\"463\":{\"c\":[\"JUC\"]},\"464\":{\"h\":\"彻底理解 volatile\"},\"465\":{\"h\":\"1. volatile 简介\",\"t\":[\"在上一篇文章中我们了解到 synchronized 是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而 volatile 就可以说是 java 虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用 synchronized。\",\"Java 内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对 volatile 修饰的变量给 java 虚拟机特殊的约定，线程对 volatile 变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的 “可见性”。\",\"现在大概的理解就是：被 volatile 修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。\"]},\"466\":{\"h\":\"2. volatile 实现原理\",\"t\":[\"volatile 是怎样实现了？比如一个很简单的 Java 代码：\",\"instance = new Instancce(); //instance是volatile变量\",\"在生成汇编代码时会在 volatile 修饰的共享变量进行写操作的时候会多出 Lock 前缀的指令（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个 Lock 指令肯定有神奇的地方，那么 Lock 前缀的指令在多核处理器下会发现什么事情了？主要有这两个方面的影响：\",\"将当前处理器缓存行的数据写回系统内存\",\"这个写回内存的操作会使得其他 CPU 里缓存了该内存地址的数据无效\",\"为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。\",\"所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：\",\"Lock 前缀的指令会引起处理器缓存写回内存；\",\"一个处理器的缓存回写到内存会导致其他处理器的缓存失效；\",\"当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\",\"这样针对 volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\"]},\"467\":{\"h\":\"3. volatile 的 happens-before 关系\",\"t\":[\"经过上面的分析，我们已经知道了 volatile 变量可以通过缓存一致性协议保证每个线程都能获得最新值，即满足数据的 “可见性”。\",\"对并发分析的切入点可以分为 两个核心，三大性质。\",\"两个核心：JMM 内存模型（主内存和工作内存）以及 happens-before；\",\"三条性质：原子性，可见性，有序性。\",\"先来看两个核心之一：volatile 的 happens-before 关系。\",\"在六条 happens-before 规则中有一条是：volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个volatile域的读。\",\"下面我们结合具体的代码，我们利用这条规则推导下：\",\"public class VolatileExample { private int a = 0; private volatile boolean flag = false; public void writer(){ a = 1; //1 flag = true; //2 } public void reader(){ if (flag){ //3 int i = a; //4 } } }\",\"上面的实例代码对应的 happens-before 关系如下图所示：\",\"加锁线程 A 先执行 writer 方法，然后线程 B 执行 reader 方法，图中每一个箭头两个节点就代码一个 happens-before 关系，黑色的代表根据程序顺序规则推导出来，红色的是根据 volatile 变量的写 happens-before 于任意后续对 volatile 变量的读，而蓝色的就是根据传递性规则推导出来的。\",\"这里的2 happen-before 3，同样根据 happens-before 规则定义：如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B 的执行顺序，我们可以知道操作 2 执行结果对操作 3 来说是可见的，也就是说当线程 A 将 volatile 变量 flag 更改为 true 后线程 B 就能够迅速感知。\"]},\"468\":{\"h\":\"4. volatile 的内存语义\",\"t\":[\"分析完 happens-before 关系后我们现在就来进一步分析 volatile 的内存语义。\",\"还是以上面的代码为例，假设线程 A 先执行 writer 方法，线程 B 随后执行 reader 方法，初始时线程的本地内存中 flag 和 a 都是初始状态，下图是线程 A 执行 volatile 写后的状态图：\",\"当 volatile 变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程 B 再需要读取从主内存中去读取该变量的最新值。下图就展示了线程 B 读取同一个 volatile 变量的内存变化示意图：\",\"从横向上看，线程 A 和线程 B 之间进行了一次通信，线程 A 在写 volatile 变量时，实际上就像是给 B 发送了一个消息告诉线程 B 你现在的值都是旧的了，然后线程 B 读这个 volatile 变量时就像是接收了线程 A 刚刚发送的消息。既然是旧的了，那线程 B 该怎么办了？自然而然就只能去主内存去取了。\"]},\"469\":{\"h\":\"5. volatile 的内存语义实现\",\"t\":[\"在前面的学习中，我们知道，为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。\",\"JMM 内存屏障分为四类见下图：\",\"内存屏障分类表\",\"java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM 会针对编译器制定 volatile 重排序规则表：\",\"\\\"NO\\\" 表示禁止重排序。为了实现 volatile 内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守策略：\",\"在每个 volatile 写操作的前面插入一个 StoreStore 屏障；\",\"在每个 volatile 写操作的后面插入一个 StoreLoad 屏障；\",\"在每个 volatile 读操作的后面插入一个 LoadLoad 屏障；\",\"在每个 volatile 读操作的后面插入一个 LoadStore 屏障。\",\"需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障\",\"StoreStore 屏障：禁止上面的普通写和下面的 volatile 写重排序；\",\"StoreLoad 屏障：防止上面的 volatile 写与下面可能有的 volatile 读/写重排序\",\"LoadLoad 屏障：禁止下面所有的普通读操作和上面的 volatile 读重排序\",\"LoadStore 屏障：禁止下面所有的普通写操作和上面的 volatile 读重排序\",\"以《Java并发编程的艺术》中的两个示意图帮助理解：\"]},\"470\":{\"h\":\"6. 一个例子\",\"t\":[\"现在对于文章开头的问题，通过 volatile 给出答案：\",\"public class VolatileDemo { private static volatile boolean isOver = false; public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { while (!isOver) ; } }); thread.start(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } isOver = true; } }\",\"注意不同点，现在已经 将 isOver 设置成了 volatile 变量，这样在 main 线程中将 isOver 改为了 true 后，thread 的工作内存该变量值就会失效，从而需要再次从主内存中读取该值，现在能够读出 isOver 最新值为 true 从而能够结束在 thread 里的死循环，从而能够顺利停止掉 thread 线程。\"]},\"471\":{\"c\":[\"并发编程\"]},\"472\":{\"c\":[\"JUC\"]},\"473\":{\"h\":\"你真的了解 final 吗\"},\"474\":{\"h\":\"1. final 简介\",\"t\":[\"final 可以修饰变量，方法和类，用于表示所修饰的内容一旦赋值之后就不会再被改变。\",\"比如 String 类就是一个 final 类型的类，它是一个不可变类。\"]},\"475\":{\"h\":\"2. final 的具体使用场景\"},\"476\":{\"h\":\"2.1 变量\",\"t\":[\"在 java 中变量，可以分为成员变量以及方法局部变量。\"]},\"477\":{\"h\":\"2.1.1 final 成员变量\",\"t\":[\"通常每个类中的成员变量可以分为类变量（static修饰的变量）以及实例变量。\",\"针对这两种类型的变量赋初值的时机是不同的：类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值；而实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。\",\"类变量有两个时机赋初值，而实例变量则可以有三个时机赋初值。当 final 变量未初始化时系统不会进行隐式初始化，会出现报错。下面用具体的代码来演示：\",\"看上面的图片已经将每种情况整理出来了，现在将这几种情况归纳整理一下：\",\"类变量：必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值，而且只能在这两个地方之一进行指定\",\"实例变量：必要要在非静态初始化块，声明该实例变量或者在构造器中指定初始值，而且只能在这三个地方进行指定\"]},\"478\":{\"h\":\"2.1.2 final 局部变量\",\"t\":[\"final 局部变量由程序员进行显式初始化，如果 final 局部变量已经进行了初始化则后面就不能再次进行更改，如果 final 变量未进行初始化，可以进行赋值，当且仅有一次赋值，一旦赋值之后再次赋值就会出错。\",\"下面用具体的代码演示 final 局部变量的情况：\",\"现在我们来换一个角度进行考虑，final 修饰的是基本数据类型和引用类型有区别吗？\"]},\"479\":{\"h\":\"2.1.2 final 基本数据类型 VS final 引用数据类型\",\"t\":[\"通过上面的例子我们能够看出，如果 final 修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果 final 是引用数据类型呢？这个引用的对象能够改变吗？\",\"同样来看一段代码：\",\"public class FinalExample { //在声明final实例成员变量时进行赋值 private final static Person person = new Person(24, 170); public static void main(String[] args) { //对final引用数据类型person进行更改 person.age = 22; System.out.println(person.toString()); } static class Person { private int age; private int height; public Person(int age, int height) { this.age = age; this.height = height; } @Override public String toString() { return \\\"Person{\\\" + \\\"age=\\\" + age + \\\", height=\\\" + height + '}'; } } }\",\"当我们对 final 修饰的引用数据类型变量 person 的属性改成 22，是可以成功操作的。\",\"通过这个实验我们就可以看出来当 final 修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final 只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的。\",\"宏变量\",\"利用 final 变量的不可更改性，在满足一下三个条件时，该变量就会成为一个 “宏变量”，即是一个常量。\",\"使用 final 修饰符修饰\",\"在定义该 final 变量时就指定了初始值\",\"该初始值在编译时就能够唯一指定\",\"注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值\"]},\"480\":{\"h\":\"2.2 方法\"},\"481\":{\"h\":\"2.2.1 重写？\",\"t\":[\"当父类的方法被 final 修饰的时候，子类不能重写父类的该方法，比如在 Object 中，getClass() 方法就是 final 的，我们就不能重写该方法，但是 hashCode() 方法就不是被 final 所修饰的，我们就可以重写 hashCode() 方法。\",\"写一个例子来加深理解：先定义一个父类，里面有 final 修饰的方法 test();\",\"public class FinalExampleParent { public final void test() {} }\",\"然后 FinalExample 继承该父类，当重写 test() 方法时出现报错，如下图：\",\"通过这个现象我们就可以看出来被 final 修饰的方法不能够被子类所重写。\"]},\"482\":{\"h\":\"2.2.2 重载？\",\"t\":[\"public class FinalExampleParent { public final void test() {} public final void test(String str) {} }\",\"可以看出被 final 修饰的方法是可以重载的。\",\"经过我们的分析可以得出如下结论：\",\"父类的 final 方法是不能够被子类重写的\",\"final 方法是可以被重载的\"]},\"483\":{\"h\":\"2.3 类\",\"t\":[\"当一个类被 final 修饰时，表明该类是不能被子类继承的。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用 final 修饰。\",\"举一个小例子：\",\"public final class FinalExampleParent { public final void test() {} }\",\"父类被 final 修饰，当子类继承该父类的时候，就会报错，如下图：\"]},\"484\":{\"h\":\"3. final 的例子\",\"t\":[\"final 经常会被用作不变类上，利用 final 的不可更改性。我们先来看看什么是不可变类。\",\"不可变类\",\"不可变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。\",\"满足以下条件则可以成为不可变类：\",\"使用 private 和 final 修饰符来修饰该类的成员变量\",\"提供带参的构造器用于初始化类的成员变量\",\"仅为该类的成员变量提供 getter 方法，不提供 setter 方法，因为普通方法无法修改 final 修饰的成员变量\",\"如果有必要就重写 Object 类的 hashCode() 和 equals() 方法，应该保证用 equals() 判断相同的两个对象其 Hashcode 值也是相等的\",\"JDK 中提供的八个包装类和 String 类都是不可变类，我们来看看 String 的实现：\",\"/** The value is used for character storage. */ private final char value[];\",\"可以看出 String 的 value 就是 final 修饰的，上述其他几条性质也是吻合的。\"]},\"485\":{\"h\":\"4. 多线程中你真的了解 final 吗？\",\"t\":[\"在 java 内存模型中我们知道，java 内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说，对于底层而言，java 内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下，final 会进行怎样的重排序？会导致线程安全的问题吗？\"]},\"486\":{\"h\":\"4.1 final 域重排序规则\"},\"487\":{\"h\":\"4.1.1 final 域为基本类型\",\"t\":[\"先看一段示例代码：\",\"public class FinalDemo { private int a; //普通域 private final int b; //final域 private static FinalDemo finalDemo; public FinalDemo() { a = 1; // 1. 写普通域 b = 2; // 2. 写final域 } public static void writer() { finalDemo = new FinalDemo(); } public static void reader() { FinalDemo demo = finalDemo; // 3.读对象引用 int a = demo.a; //4.读普通域 int b = demo.b; //5.读final域 } }\",\"假设线程 A 在执行 writer() 方法，线程 B 执行 reader() 方法。\",\"写 final 域重排序规则\",\"写 final 域的重排序规则为：禁止对final域的写重排序到构造函数之外。\",\"这个规则的实现主要包含了两个方面：\",\"JMM 禁止编译器把 final 域的写重排序到构造函数之外\",\"编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障，这个屏障可以禁止处理器把 final 域的写重排序到构造函数之外。\",\"我们再来分析 writer 方法，虽然只有一行代码，但实际上做了两件事情：\",\"构造了一个 FinalDemo 对象；\",\"把这个对象赋值给成员变量 finalDemo。\",\"我们来画下存在的一种可能执行时序图，如下：\",\"由于 a，b 之间没有数据依赖性，普通域（普通变量）a 可能会被重排序到构造函数之外，线程 B 就有可能读到的是普通变量 a 初始化之前的值（零值），这样就可能出现错误。\",\"而 final 域变量 b，根据重排序规则，会禁止 final 修饰的变量 b 重排序到构造函数之外，从而 b 能够正确赋值，线程 B 就能够读到 final 变量初始化后的值。\",\"因此，写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程 B 有可能就是一个未正确初始化的对象 finalDemo。\",\"读 final 域重排序规则\",\"读 final 域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的 final 域，JMM 会禁止这两个操作的重排序。\",\"注意，这个规则仅仅是针对处理器。\",\"处理器会在读 final 域操作的前面插入一个 LoadLoad 屏障。实际上，读对象的引用和读该对象的 final 域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\",\"read() 方法主要包含了三个操作：\",\"初次读引用变量 finalDemo;\",\"初次读引用变量 finalDemo 的普通域 a;\",\"初次读引用变量 finalDemo 的 final 与 b;\",\"假设线程 A 写过程没有重排序，那么线程 A 和线程 B 有一种的可能执行时序为下图：\",\"读对象的普通域被重排序到了读对象引用的前面就会出现线程 B 还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而 final 域的读操作就 “限定” 了在读 final 域变量前已经读到了该对象的引用，从而就可以避免这种情况。\",\"读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读这个包含这个 final 域的对象的引用。\"]},\"488\":{\"h\":\"4.1.2 final 域为引用类型\",\"t\":[\"对 final 修饰的对象的成员域写操作\",\"针对引用数据类型，final 域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个 final 修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。\",\"注意这里的是 “增加” 也就说前面对 final 基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看：\",\"public class FinalReferenceDemo { final int[] arrays; private FinalReferenceDemo finalReferenceDemo; public FinalReferenceDemo() { arrays = new int[1]; //1 arrays[0] = 1; //2 } public void writerOne() { finalReferenceDemo = new FinalReferenceDemo(); //3 } public void writerTwo() { arrays[0] = 2; //4 } public void reader() { if (finalReferenceDemo != null) { //5 int temp = finalReferenceDemo.arrays[0]; //6 } } }\",\"针对上面的实例程序，线程线程 A 执行 wirterOne 方法，执行完后线程 B 执行 writerTwo 方法，然后线程 C 执行 reader 方法。下图就以这种执行时序出现的一种情况来讨论：\",\"由于对 final 域的写禁止重排序到构造方法外，因此 1 和 3 不能被重排序。由于一个 final 域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此 2 和 3 不能重排序。\",\"对 final 修饰的对象的成员域读操作\",\"JMM 可以确保线程 C 至少能看到写线程 A 对 final 引用的对象的成员域的写入，即能看到 arrays[0] = 1，而写线程 B 对数组元素的写入可能看到也可能看不到。JMM 不保证线程 B 的写入对线程 C 可见，线程 B 和线程 C 之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者 volatile。\",\"关于 final 重排序的总结\",\"按照 final 修饰的数据类型分类：\",\"基本数据类型: \",\"final 域写：禁止 final 域写与构造方法重排序，即禁止 final 域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的 final 域全部已经初始化过。\",\"final 域读：禁止初次读对象的引用与读该对象包含的 final 域的重排序。\",\"引用数据类型： \",\"额外增加约束：禁止在构造函数对一个 final 修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序\"]},\"489\":{\"h\":\"5. final 的实现原理\",\"t\":[\"上面我们提到过，写 final 域会要求编译器在 final 域写之后，构造函数返回前插入一个 StoreStore 屏障。读 final 域的重排序规则会要求编译器在读 final 域的操作前插入一个 LoadLoad 屏障。\",\"有意思的是，如果以 X86 处理为例，X86 不会对写-写重排序，所以 StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在 X86 处理器中，读 final 域需要的 LoadLoad屏障也会被省略掉。也就是说，以 X86 为例的话，对 final 域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器。\"]},\"490\":{\"h\":\"6. 为什么 final 引用不能从构造函数中 “溢出”\",\"t\":[\"上面对 final 域写重排序规则可以确保我们在使用一个对象引用的时候，该对象的 final 域已经在构造函数被初始化过了。\",\"但是这里其实是有一个前提条件的，即：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中 “溢出”。\",\"以下面的例子来说：\",\"public class FinalReferenceEscapeDemo { private final int a; private FinalReferenceEscapeDemo referenceDemo; public FinalReferenceEscapeDemo() { a = 1; //1 referenceDemo = this; //2 } public void writer() { new FinalReferenceEscapeDemo(); } public void reader() { if (referenceDemo != null) { //3 int temp = referenceDemo.a; //4 } } }\",\"可能的执行时序如图所示：\",\"假设一个线程 A 执行 writer 方法另一个线程执行 reader 方法。因为构造函数中操作 1 和 2 之间没有数据依赖性，1 和 2 可以重排序，先执行了 2，这个时候引用对象 referenceDemo 是个没有完全初始化的对象，而当线程 B 去读取该对象时就会出错。\",\"尽管依然满足了 final 域写重排序规则：在引用对象对所有线程可见时，其 final 域已经完全初始化成功。但是，引用对象 “this” 溢出，该代码依然存在线程安全的问题。\"]},\"491\":{\"c\":[\"并发编程\"]},\"492\":{\"c\":[\"JUC\"]},\"493\":{\"h\":\"三大性质总结：原子性、可见性、有序性\"},\"494\":{\"h\":\"1. 原子性\",\"t\":[\"原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。\",\"先看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：\",\"int a = 10; //1 a++; //2 int b = a; //3 a = a + 1; //4\",\"上面这四个语句中只有第 1 个语句是原子操作，将 10 赋值给线程工作内存的变量 a，而语句 2（a++），实际上包含了三个操作：\",\"读取变量 a 的值；\",\"对 a 进行加一的操作；\",\"将计算后的值再赋值给变量a\",\"而这三个操作无法构成原子操作。\",\"对语句 3，4 的分析同理可得这两条语句不具备原子性。\",\"在 java 内存模型中定义了 8 种操作都是原子的，不可再分的。\",\"lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；\",\"unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；\",\"read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的 load 动作使用；\",\"load（载入）：作用于工作内存中的变量，它把 read 操作从主内存中得到的变量值放入工作内存中的变量副本；\",\"use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；\",\"assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；\",\"store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的 write操作使用；\",\"write（操作）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。\",\"上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。\",\"那么如何理解这些指令了？\",\"比如，把一个变量从主内存中复制到工作内存中就需要执行 read，load 操作，将工作内存同步到主内存中就需要执行 store，write操作。\",\"注意\",\"java 内存模型只是要求上述两个操作是顺序执行的并不是连续执行的。\",\"也就是说 read 和 load 之间可以插入其他指令，store 和 writer 也可以插入其他指令。\",\"比如对主内存中的 a,b 进行访问就可以出现这样的操作顺序：read a, read b, load b, load a。\",\"由原子性变量操作 read,load,use,assign,store,write，可以大致认为基本数据类型的访问读写具备原子性（例外就是 long 和 double 的非原子性协定）\",\"synchronized\",\"上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下 lock 和 unlock 两条原子操作。如果我们需要更大范围的原子性操作就可以使用 lock 和 unlock 原子操作。\",\"尽管 jvm 没有把 lock 和 unlock 开放给我们使用，但 jvm 以更高层次的指令 monitorenter 和 monitorexit 指令开放给我们使用，反应到 java 代码中就是 synchronized 关键字，也就是说 synchronized 满足原子性。\",\"我们先来看这样一个例子：\",\"public class VolatileExample { private static volatile int counter = 0; public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10000; i++) counter++; } }); thread.start(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(counter); } }\",\"开启 10 个线程，每个线程都自加 10000 次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000。可实际上，不管运行多少次都是小于 100000 的结果，问题在于 volatile 并不能保证原子性，在前面说过 counter++ 这并不是一个原子操作，包含了三个步骤：\",\"读取变量 counter 的值；\",\"对 counter 加一；\",\"将新值赋值给变量 counter。\",\"如果线程 A 读取 counter 到工作内存后，其他线程对这个值已经做了自增操作后，那么线程 A 的这个值自然而然就是一个过期的值，因此，总结果必然会是小于 100000 的。\",\"如果让 volatile 保证原子性，必须符合以下两条规则：\",\"运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；\",\"变量不需要与其他的状态变量共同参与不变约束。\"]},\"495\":{\"h\":\"2. 有序性\"},\"496\":{\"h\":\"2.1 synchronized\",\"t\":[\"synchronized 语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。\",\"因此，synchronized 语义就要求线程在访问读写共享变量时只能 “串行” 执行，故 synchronized 具有有序性。\"]},\"497\":{\"h\":\"2.2 volatile\",\"t\":[\"在 java 内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说 java 程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。\",\"在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking）。代码如下：\",\"public class Singleton { private Singleton() {}; private volatile static Singleton instance; public Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } }\",\"这里为什么要加 volatile 了？我们先来分析一下不加 volatile 的情况，有问题的语句是这条：\",\"instance = new Singleton();\",\"这条语句实际上包含了三个操作：\",\"分配对象的内存空间；\",\"初始化对象；\",\"设置 instance 指向刚分配的内存地址。\",\"但由于存在重排序的问题，可能有以下的执行顺序：\",\"如果 2 和 3 进行了重排序的话，线程 B 进行判断 if(instance == null) 时就会为 true，而实际上这个 instance 并没有初始化成功，显而易见对线程 B 来说之后的操作就会是错的。而用 volatile 修饰的话就可以禁止 2 和 3 操作重排序，从而避免这种情况。\",\"volatile包含禁止指令重排序的语义，故其具有有序性。\"]},\"498\":{\"h\":\"3. 可见性\",\"t\":[\"可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。\",\"通过之前对 synchronzed 内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，synchronized 具有可见性。\",\"同样的在 volatile 分析中，会通过在指令中添加 lock 指令，以实现内存可见性。因此，volatile 具有可见性。\"]},\"499\":{\"h\":\"4. 总结\",\"t\":[\"综上分析：\",\"synchronized: 具有原子性，有序性和可见性\",\"volatile：具有有序性和可见性\"]},\"500\":{\"c\":[\"并发编程\"]},\"501\":{\"c\":[\"JUC\"]},\"502\":{\"h\":\"初识 Lock 与 AQS\"},\"503\":{\"h\":\"1. concurrent 包的结构层次\",\"t\":[\"在针对并发编程中，Doug Lea 大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在 java.util.concurrent 包下。如下图所示。\",\"其中包含了两个子包：atomic 以及 lock，另外在 concurrent 下的阻塞队列以及 executors，这些就是 concurrent 包中的精华。而这些类的实现主要是依赖于 volatile 以及 CAS，从整体上来看 concurrent 包的整体实现图如下图所示：\"]},\"504\":{\"h\":\"2. lock 简介\",\"t\":[\"锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在 Lock 接口出现之前，java 程序主要是靠 synchronized 关键字实现锁功能的，而 java SE5 之后，并发包中增加了 lock 接口，它提供了与 synchronized 一样的锁功能。虽然它失去了像 synchronize 关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。\",\"通常显示使用 lock 的形式如下：\",\"Lock lock = new ReentrantLock(); lock.lock(); try { ....... } finally { lock.unlock(); }\",\"需要注意的是 synchronized 同步块执行完成或者遇到异常是锁会自动释放，而 lock 必须调用 unlock() 方法释放锁，为保证能够释放，需要在 finally 块中释放锁。\"]},\"505\":{\"h\":\"2.1 Lock 接口 API\",\"t\":[\"lock 接口中定义的方法：\",\"//获取锁 void lock(); //获取锁的过程能够响应中断 void lockInterruptibly() throws InterruptedException; //非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle boolean tryLock(); //超时获取锁，在超时内或者未中断的情况下能够获取锁 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回 Condition newCondition();\",\"在上述五个接口中，最熟悉的 ReentrantLock 类实现如下:\",\"public class ReentrantLock implements Lock, java.io.Serializable\",\"如果去查看源码的实现，会发现 ReentrantLock 中并没有多少代码。其实是因为，基本上所有方法的实现，实际上都是调用了其静态内存类 Sync 中的方法，而 Sync 类继承了 AbstractQueuedSynchronizer（AQS）。可以看出要想理解 ReentrantLock 关键核心在于对队列同步器 AbstractQueuedSynchronizer（简称同步器）的理解。\"]},\"506\":{\"h\":\"2.2 初识 AQS\",\"t\":[\"同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个 int 成员变量来表示同步状态以及通过一个 FIFO 队列构成等待队列。它的子类必须重写 AQS 的几个 protected 修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用 getState，setState 以及 compareAndSetState 这三个方法。\",\"子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。\",\"同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：\",\"锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；\",\"同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。\",\"锁和同步器很好的隔离了使用者和实现者所需关注的领域。\"]},\"507\":{\"h\":\"2.3 AQS 的模板方法设计模式\",\"t\":[\"AQS 的设计是使用模板方法设计模式，它将一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法。\",\"举个例子，AQS 中需要重写的方法 tryAcquire：\",\"protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); }\",\"ReentrantLock 中 NonfairSync（继承AQS）会重写该方法为：\",\"protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); }\",\"而 AQS 中的模板方法 acquire():\",\"public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); }\",\"会调用 tryAcquire 方法，而此时当继承 AQS 的 NonfairSync 调用模板方法 acquire 时就会调用已经被 NonfairSync 重写的 tryAcquire 方法。这就是使用 AQS 的方式，在弄懂这点后会lock的实现理解有很大的提升。可以归纳总结为这么几点：\",\"同步组件（这里不仅仅值锁，还包括 CountDownLatch 等）的实现依赖于同步器 AQS，在同步组件实现中，使用 AQS 的方式被推荐定义继承 AQS 的静态内存类；\",\"AQS 采用模板方法进行设计，AQS 的 protected 修饰的方法需要由继承 AQS 的子类进行重写实现，当调用 AQS 的子类的方法时就会调用被重写的方法；\",\"AQS 负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而 Lock 等同步组件主要专注于实现同步语义；\",\"在重写 AQS 的方式时，使用 AQS 提供的 getState()，setState()，compareAndSetState() 方法进行修改同步状态。\",\"AQS可重写的方法如下图（摘自《java并发编程的艺术》一书）所示：\",\"在实现同步组件时 AQS 提供的模板方法如下图：\",\"AQS 提供的模板方法可以分为 3 类：\",\"独占式获取与释放同步状态；\",\"共享式获取与释放同步状态；\",\"查询同步队列中等待线程情况；\",\"同步组件通过 AQS 提供的模板方法实现自己的同步语义。\"]},\"508\":{\"h\":\"3. 一个例子\",\"t\":[\"下面使用一个例子来进一步理解下 AQS 的使用。这个例子也是来源于 AQS 源码中的 example。\",\"class Mutex implements Lock, java.io.Serializable { // Our internal helper class // 继承AQS的静态内存类 // 重写方法 private static class Sync extends AbstractQueuedSynchronizer { // Reports whether in locked state protected boolean isHeldExclusively() { return getState() == 1; } // Acquires the lock if state is zero public boolean tryAcquire(int acquires) { assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // Releases the lock by setting state to zero protected boolean tryRelease(int releases) { assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; } // Provides a Condition Condition newCondition() { return new ConditionObject(); } // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state } } // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); //使用同步器的模板方法实现自己的同步语义 public void lock() { sync.acquire(1); } public boolean tryLock() { return sync.tryAcquire(1); } public void unlock() { sync.release(1); } public Condition newCondition() { return sync.newCondition(); } public boolean isLocked() { return sync.isHeldExclusively(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } }\",\"MutexDemo：\",\"public class MutextDemo { private static Mutex mutex = new Mutex(); public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(() -> { mutex.lock(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } finally { mutex.unlock(); } }); thread.start(); } } }\",\"执行情况：\",\"上面的这个例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。\",\"MutexDemo 新建了 10 个线程，分别睡眠 3s。从执行情况也可以看出来当前 Thread-6 正在执行占有锁而其他Thread-7，Thread-8 等线程处于 WAIT 状态。按照推荐的方式，Mutex 定义了一个继承 AQS 的静态内部类 Sync，并且重写了 AQS 的 tryAcquire 等方法，而对 state 的更新也是利用了 setState()，getState()，compareAndSetState() 这三个方法。在实现实现 lock 接口中的方法也只是调用了 AQS 提供的模板方法（因为 Sync 继承 AQS）。\",\"从这个例子就可以很清楚的看出来，在同步组件的实现上主要是利用了 AQS，而 AQS “屏蔽”了同步状态的修改，线程排队等底层实现，通过 AQS 的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可。\",\"同时在新建一个同步组件时需要把握的两个关键点是：\",\"实现同步组件时推荐定义继承 AQS 的静态内存类，并重写需要的 protected 修饰的方法；\",\"同步组件语义的实现依赖于 AQS 的模板方法，而 AQS 模板方法又依赖于被 AQS 的子类所重写的方法。\",\"通俗点说，因为 AQS 整体设计思路采用模板方法设计模式，同步组件以及 AQS 的功能实际上别切分成各自的两部分：\",\"同步组件实现者的角度：\",\"通过可重写的方法：\",\"独占式： \",\"tryAcquire()(独占式获取同步状态)\",\"tryRelease()(独占式释放同步状态)\",\"共享式 ： \",\"tryAcquireShared()(共享式获取同步状态)\",\"tryReleaseShared()(共享式释放同步状态)\",\"告诉 AQS 怎样判断当前同步状态是否成功获取或者是否成功释放。\",\"**同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。**这句话比较抽象，举例来说，上面的 Mutex 例子中通过 tryAcquire 方法实现自己的同步语义，在该方法中如果当前同步状态为 0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为 1 返回 true，否则，该组件已经被线程占用返回 false。很显然，该同步组件只能在同一时刻被线程占用，Mutex 专注于获取释放的逻辑来实现自己想要表达的同步语义。\",\"AQS的角度：\",\"而对 AQS 来说，只需要同步组件返回的 true 和 false 即可，因为 AQS 会对 true 和 false 会有不同的操作，true 会认为当前线程获取同步组件成功直接返回，而 false 的话就 AQS 也会将当前线程插入同步队列等一系列的方法。\",\"总的来说，同步组件通过重写 AQS 的方法实现自己想要表达的同步语义，而 AQS 只需要同步组件表达的 true 和 false 即可，AQS 会针对 true 和 false 不同的情况做不同的处理。\",\"而关于底层实现，可以看这篇文章。\"]},\"509\":{\"c\":[\"并发编程\"]},\"510\":{\"c\":[\"JUC\"]},\"511\":{\"h\":\"深入理解 AQS\"},\"512\":{\"h\":\"1. AQS 简介\",\"t\":[\"在同步组件的实现中，AQS 是核心部分，同步组件的实现者通过使用 AQS 提供的模板方法实现同步组件语义，AQS 则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理。AQS 的核心也包括了这些方面：同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现，而这些实际上则是 AQS 提供出来的模板方法。\",\"整理如下：\",\"独占式锁\",\"void acquire(int arg)：独占式获取同步状态，如果获取失败则插入同步队列进行等待\",\"void acquireInterruptibly(int arg)：与 acquire 方法相同，但在同步队列中进行等待的时候可以检测中断\",\"boolean tryAcquireNanos(int arg, long nanosTimeout)：在 acquireInterruptibly 基础上增加了超时等待功能，在超时时间内没有获得同步状态返回 false\",\"boolean release(int arg)：释放同步状态，该方法会唤醒在同步队列中的下一个节点\",\"共享式锁\",\"void acquireShared(int arg)：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态\",\"void acquireSharedInterruptibly(int arg)：在 acquireShared 方法基础上增加了能响应中断的功能\",\"boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：在 acquireSharedInterruptibly 基础上增加了超时等待的功能\",\"boolean releaseShared(int arg)：共享式释放同步状态\",\"接下来要对这些模板方法的逻辑进行学习，而在此之前，首先得了解下 AQS 中的同步队列是一种什么样的数据结构，因为同步队列是 AQS 对同步状态的管理的基石。\"]},\"513\":{\"h\":\"2. 同步队列\",\"t\":[\"当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。\",\"就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。\",\"AQS 中的同步队列则是通过链式方式进行实现。\",\"接下来，我们需要解决三个问题：\",\"节点的数据结构是什么样的？\",\"是单向还是双向？\",\"是带头结点的还是不带头节点的？\",\"我们依旧先是通过看源码的方式。\",\"在 AQS 有一个静态内部类 Node，其中的属性有：\",\"volatile int waitStatus; // 节点状态 volatile Node prev; // 当前节点/线程的前驱节点 volatile Node next; // 当前节点/线程的后继节点 volatile Thread thread; // 加入同步队列的线程引用 Node nextWaiter; // 等待队列中的下一个节点\",\"节点的状态有：\",\"int INITIAL = 0; // 初始状态 int CANCELLED = 1; // 节点从同步队列中取消 int SIGNAL = -1; // 后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行 int CONDITION = -2; // 当前节点进入等待队列中 int PROPAGATE = -3; // 表示下一次共享式同步状态获取将会无条件传播下去\",\"也就是说，每个节点拥有其前驱和后继节点，并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息。\",\"所以 AQS 实际上通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：\",\"可以清楚地知道两点：\",\"节点的数据结构，即 AQS 的静态内部类 Node，节点的等待状态等信息\",\"同步队列是一个双向队列，AQS 通过持有头尾指针管理同步队列\",\"那么，节点如何进行入队和出队是怎样做的呢？\",\"实际上这对应着锁的获取和释放两个操作：（1）获取锁失败进行入队操作；（2）获取锁成功进行出队操作。\"]},\"514\":{\"h\":\"3. 独占锁\"},\"515\":{\"h\":\"3.1 独占锁的获取（acquire）\",\"t\":[\"调用 lock() 方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而 lock() 方法实际上会调用 AQS 的 acquire()方法，源码如下：\",\"public final void acquire(int arg) { // 先看同步状态是否获取成功，如果成功则方法结束返回 // 若失败则先调用 addWaiter()方法再调用 acquireQueued()方法 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); }\",\"acquire 根据当前获得同步状态成功与否做了两件事情：\",\"成功，则方法结束返回；\",\"失败，则先调用 addWaiter() 然后在调用 acquireQueued()方法。\"]},\"516\":{\"h\":\"3.1.1 获取同步状态失败，入队操作\",\"t\":[\"当线程获取独占式锁失败后就会将当前线程加入同步队列，接下来就去研究一下加入队列的方式，即 addWaiter() 和 acquireQueued()。\",\"addWaiter() 源码如下：\",\"private Node addWaiter(Node mode) { // 1. 将当前线程构建成Node类型 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 2. 当前尾节点是否为null? Node pred = tail; if (pred != null) { // 2.2 将当前节点尾插入的方式插入同步队列中 node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } // 2.1 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程 enq(node); return node; }\",\"可以看到，程序的逻辑主要分为两个部分：\",\"当前同步队列的尾节点为 null，调用方法enq()插入；\",\"当前队列的尾节点不为 null，则采用尾插入（compareAndSetTail（）方法）的方式入队。\",\"另外还会有另外一个问题：如果 if (compareAndSetTail(pred, node)) = false 怎么办？\",\"会继续执行到 enq() 方法，同时很明显 compareAndSetTail 是一个 CAS 操作，通常来说如果 CAS 操作失败会继续自旋（死循环）进行重试。\",\"因此，经过我们这样的分析，enq() 方法可能承担两个任务：\",\"处理当前同步队列尾节点为 null 时进行入队操作；\",\"如果 CAS 尾插入节点失败后负责自旋进行尝试。\",\"那么是不是真的就像我们分析的一样了？只有源码会告诉我们答案。enq() 源码如下：\",\"private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize // 1. 构造头结点 if (compareAndSetHead(new Node())) tail = head; } else { // 2. 尾插入，CAS操作失败自旋尝试 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } }\",\"在上面的源码中我们可以看出在第1步中会先创建头结点，说明同步队列是带头结点的链式存储结构。带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。\",\"那么带头节点的队列初始化时机是什么？自然而然是在 tail 为 null 时，即当前线程是第一次插入同步队列。compareAndSetTail(t, node) 方法会利用 CAS 操作设置尾节点，如果 CAS 操作失败会在 for (;;) 死循环中不断尝试，直至成功 return 返回为止。因此，对 enq() 方法可以做这样的总结：\",\"在当前线程是第一个加入同步队列时，调用 compareAndSetHead(new Node()) 方法，完成链式队列的头结点的初始化；\",\"自旋不断尝试CAS尾插入节点直至成功为止。\",\"现在我们已经很清楚获取独占式锁失败的线程包装成 Node 然后插入同步队列的过程了。那么紧接着会有下一个问题 —— 在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？\",\"带着这样的问题我们就来看看 acquireQueued() 方法，从方法名就可以很清楚，这个方法的作用就是排队获取锁的过程，源码如下：\",\"final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { // 1. 获得当前节点的先驱节点 final Node p = node.predecessor(); // 2. 当前节点能否获取独占式锁 // 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁 if (p == head && tryAcquire(arg)) { // 队列头指针用指向当前节点 setHead(node); // 释放前驱节点 p.next = null; // help GC failed = false; return interrupted; } // 2.2 获取锁失败，线程进入等待状态等待获取独占式锁 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }\",\"程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;;)），代码首先获取当前节点的先驱节点，如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head && tryAcquire(arg))），当前节点所指向的线程能够获取锁。反之，获取锁失败进入等待状态。整体示意图为下图：\"]},\"517\":{\"h\":\"3.1.2 获取锁成功，出队操作\",\"t\":[\"获取锁的节点出队的逻辑是：\",\"// 队列头结点引用指向当前节点 setHead(node); // 释放前驱节点 p.next = null; // help GC failed = false; return interrupted;\",\"setHead() 方法为：\",\"private void setHead(Node node) { head = node; node.thread = null; node.prev = null; }\",\"将当前节点通过 setHead() 方法设置为队列的头结点，然后将之前的头结点的 next 域设置为 null 并且 pre 域也为 null，即与队列断开，无任何引用方便 GC 时能够将内存进行回收。示意图如下：\",\"那么当获取锁失败的时候会调用 shouldParkAfterFailedAcquire() 方法和 parkAndCheckInterrupt() 方法，看看他们做了什么事情。\",\"shouldParkAfterFailedAcquire() 方法源码为：\",\"private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws > 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; }\",\"shouldParkAfterFailedAcquire() 方法主要逻辑是使用 compareAndSetWaitStatus(pred, ws, Node.SIGNAL)，使用 CAS 将节点状态由 INITIAL 设置成 SIGNAL，表示当前线程阻塞。\",\"当 compareAndSetWaitStatus 设置失败则说明 shouldParkAfterFailedAcquire() 方法返回 false，然后会在 acquireQueued() 方法中 for (;;) 死循环中会继续重试，直至 compareAndSetWaitStatus 设置节点状态位为 SIGNAL 时，shouldParkAfterFailedAcquire 返回 true 时才会执行方法 parkAndCheckInterrupt() 方法，该方法的源码为：\",\"private final boolean parkAndCheckInterrupt() { // 使得该线程阻塞 LockSupport.park(this); return Thread.interrupted(); }\",\"该方法的关键是会调用 LookSupport.park() 方法，该方法是用来阻塞当前线程的。因此到这里就应该清楚了，acquireQueued() 在自旋过程中主要完成了两件事情：\",\"如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出；\",\"获取锁失败的话，先将节点状态设置成 SIGNAL，然后调用 LookSupport.park 方法使得当前线程阻塞。\",\"经过上面的分析，独占式锁的获取过程也就是 acquire() 方法的执行流程如下图所示：\"]},\"518\":{\"h\":\"3.2 独占锁的释放（release）\",\"t\":[\"独占锁的释放就相对来说比较容易理解了，先看源码：\",\"public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; }\",\"这段代码逻辑就比较容易理解了，如果同步状态释放成功（tryRelease返回 true）则会执行 if 块中的代码，当 head 指向的头结点不为 null，并且该节点的状态值不为 0 的话才会执行 unparkSuccessor() 方法。\",\"unparkSuccessor() 方法源码：\",\"private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws < 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ //头节点的后继节点 Node s = node.next; if (s == null || s.waitStatus > 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus <= 0) s = t; } if (s != null) // 后继节点不为null时唤醒该线程 LockSupport.unpark(s.thread); }\",\"首先获取头节点的后继节点，当后继节点的时候会调用 LookSupport.unpark() 方法，该方法会唤醒该节点的后继节点所包装的线程。因此，每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个 FIFO（先进先出）的过程。\",\"现在通过学习源码的方式，我们学习到了独占式锁的获取和释放的过程以及同步队列，做一下总结：\",\"线程获取锁失败，线程被封装成 Node 进行入队操作，核心方法在于 addWaiter() 和 enq()，同时 enq() 完成对同步队列的头结点初始化工作以及 CAS 操作失败的重试；\",\"线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用 LookSupport.park() 方法使得线程阻塞；\",\"释放锁的时候会唤醒后继节点。\",\"总体来说：在获取同步状态时，AQS 维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用 unparkSuccessor() 方法唤醒后继节点。\"]},\"519\":{\"h\":\"3.3 可中断式获取锁（acquireInterruptibly）\",\"t\":[\"我们知道 lock 相较于 synchronized 有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。\",\"可响应中断式锁可调用方法 lock.lockInterruptibly();，而该方法其底层会调用 AQS 的 acquireInterruptibly() 方法，源码为：\",\"public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) // 线程获取锁失败 doAcquireInterruptibly(arg); }\",\"在获取同步状态失败后就会调用 doAcquireInterruptibly() 方法：\",\"private void doAcquireInterruptibly(int arg) throws InterruptedException { // 将节点插入到同步队列中 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); // 获取锁出队 if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return; } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) //线程中断抛异常 throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } }\",\"关键信息请看注释。与 acquire 方法逻辑几乎一致，唯一的区别是当 parkAndCheckInterrupt() 返回 true 即线程阻塞时该线程被中断，代码抛出被中断异常。\"]},\"520\":{\"h\":\"3.4 超时等待式获取锁（tryAcquireNanos）\",\"t\":[\"通过调用 lock.tryLock(timeout, TimeUnit) 方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：\",\"在超时时间内，当前线程成功获取了锁；\",\"当前线程在超时时间内被中断；\",\"超时时间结束，仍未获得锁返回 false。\",\"阅读源码来看下底层具体是怎么实现的，该方法会调用 AQS 的方法 tryAcquireNanos()，源码为：\",\"public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 实现超时等待的效果 return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout); }\",\"很显然这段源码最终是靠 doAcquireNanos 方法实现超时等待的效果，该方法源码如下：\",\"private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (nanosTimeout <= 0L) return false; // 1. 根据超时时间和当前时间计算出截止时间 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); //2. 当前线程获得锁出队列 if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return true; } // 3.1 重新计算超时时间 nanosTimeout = deadline - System.nanoTime(); // 3.2 已经超时返回false if (nanosTimeout <= 0L) return false; // 3.3 线程阻塞等待 if (shouldParkAfterFailedAcquire(p, node) && nanosTimeout > spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // 3.4 线程被中断抛出被中断异常 if (Thread.interrupted()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } }\",\"程序逻辑如图所示：\",\"程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上。\",\"在第 1 步会先计算出按照现在时间和超时时间计算出理论上的截止时间。比如当前时间是 8h10min，超时时间是 10min，那么根据 deadline = System.nanoTime() + nanosTimeout 计算出刚好达到超时时间时的系统时间就是 8h10min+10min=8h20min。\",\"然后根据 deadline - System.nanoTime() 就可以判断是否已经超时了。比如，当前系统时间是 8h30min 很明显已经超过了理论上的系统时间 8h20min，deadline - System.nanoTime() 计算出来就是一个负数，自然而然会在 3.2 步中的 if 判断之间返回 false。\",\"如果还没有超时，即 3.2 步中的 if 判断为 true，那就会继续执行 3.3 步。通过 LockSupport.parkNanos 使得当前线程阻塞，同时在 3.4 步增加了对中断的检测，若检测出被中断直接抛出被中断异常。\"]},\"521\":{\"h\":\"4. 共享锁\"},\"522\":{\"h\":\"4.1 共享锁的获取（acquireShared）\",\"t\":[\"现在来看看共享锁是怎样实现的？共享锁的获取方法为 acquireShared，源码为：\",\"public final void acquireShared(int arg) { if (tryAcquireShared(arg) < 0) doAcquireShared(arg); }\",\"这段源码的逻辑也很容易理解，在该方法中会首先调用 tryAcquireShared() 方法，其返回值是一个int类型，当返回值为大于等于 0 的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行 doAcquireShared() 方法，该方法的源码为：\",\"private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r >= 0) { // 当该节点的前驱节点是头结点且成功获取同步状态 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }\",\"现在看这段代码，逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且 tryAcquireShared(arg) 返回值大于等于 0 即能成功获得同步状态。\"]},\"523\":{\"h\":\"4.2 共享锁的释放（releaseShared）\",\"t\":[\"共享锁的释放在 AQS 中会调用方法 releaseShared()：\",\"public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; }\",\"当成功释放同步状态之后，即 tryReleaseShared 会继续执行 doReleaseShared 方法：\",\"private void doReleaseShared() { /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) { Node h = head; if (h != null && h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } }\",\"这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的 CAS 保证，当 CAS 操作失败 continue，在下一次循环中进行重试。\"]},\"524\":{\"h\":\"4.3 可中断（acquireSharedInterruptibly），超时等待（tryAcquireSharedNanos）\",\"t\":[\"关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致，具体的就不再说了，如果理解了上面的内容对这部分的理解也是水到渠成的。\"]},\"525\":{\"c\":[\"并发编程\"]},\"526\":{\"c\":[\"JUC\"]},\"527\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"528\":{\"h\":\"Zh\"},\"529\":{\"h\":\"Min IO\"},\"530\":{\"h\":\"中间件\"},\"531\":{\"h\":\"Linux\"},\"532\":{\"h\":\"操作系统\"},\"533\":{\"h\":\"My SQL\"},\"534\":{\"h\":\"数据库\"},\"535\":{\"h\":\"Java\"},\"536\":{\"h\":\"编程语言\"},\"537\":{\"h\":\"创建型\"},\"538\":{\"h\":\"设计模式\"},\"539\":{\"h\":\"JUC 并发编程\"}},\"dirtCount\":0,\"index\":[[\"已经超时返回false\",{\"1\":{\"520\":1}}],[\"已过时\",{\"1\":{\"307\":1}}],[\"阅读源码来看下底层具体是怎么实现的\",{\"1\":{\"520\":1}}],[\"仍未获得锁返回\",{\"1\":{\"520\":1}}],[\"仍可以从剩下的盘中的数据进行恢复\",{\"1\":{\"134\":1}}],[\"移除队列\",{\"1\":{\"518\":1}}],[\"移动\",{\"1\":{\"71\":1}}],[\"维护一个同步队列\",{\"1\":{\"518\":1}}],[\"维护了哈希散列表的若干个桶\",{\"1\":{\"391\":1}}],[\"头节点的后继节点\",{\"1\":{\"518\":1}}],[\"头是按指定排序方式的最小元素\",{\"1\":{\"333\":1}}],[\"获得当前节点的先驱节点\",{\"1\":{\"516\":1}}],[\"获取同步状态失败的线程会加入到队列中进行自旋\",{\"1\":{\"518\":1}}],[\"获取同步状态失败\",{\"0\":{\"516\":1}}],[\"获取失败就将当前线程加入同步队列\",{\"1\":{\"515\":1}}],[\"获取与lock绑定的等待通知组件\",{\"1\":{\"505\":1}}],[\"获取等待队列中第一个节点\",{\"1\":{\"379\":1}}],[\"获取成功并支持重入\",{\"1\":{\"366\":1}}],[\"获取写锁获取的次数\",{\"1\":{\"366\":1}}],[\"获取写锁当前的同步状态\",{\"1\":{\"366\":1}}],[\"获取读锁再释放写锁的次序\",{\"1\":{\"364\":1,\"371\":1}}],[\"获取堆顶元素但不删除\",{\"1\":{\"333\":1}}],[\"获取堆顶元素并删除\",{\"1\":{\"333\":1}}],[\"获取队尾元素但不删除\",{\"1\":{\"332\":1}}],[\"获取队尾元素并删除\",{\"1\":{\"332\":1}}],[\"获取队首元素但不删除\",{\"1\":{\"332\":1}}],[\"获取队首元素并删除\",{\"1\":{\"332\":1}}],[\"获取锁出队\",{\"1\":{\"519\":1}}],[\"获取锁成功\",{\"0\":{\"517\":1}}],[\"获取锁成功进行出队操作\",{\"1\":{\"513\":1}}],[\"获取锁失败的话\",{\"1\":{\"517\":1}}],[\"获取锁失败进入等待状态\",{\"1\":{\"516\":1}}],[\"获取锁失败进行入队操作\",{\"1\":{\"513\":1}}],[\"获取锁失败\",{\"1\":{\"516\":1}}],[\"获取锁放回true反之返回fasle\",{\"1\":{\"505\":1}}],[\"获取锁的节点出队的逻辑是\",{\"1\":{\"517\":1}}],[\"获取锁的过程能够响应中断\",{\"1\":{\"505\":1}}],[\"获取锁的时候同样会从主内存中共享变量\",{\"1\":{\"445\":1}}],[\"获取锁的指令\",{\"1\":{\"443\":1}}],[\"获取锁\",{\"1\":{\"316\":1,\"505\":1}}],[\"获取类中的单个构造函数的信息\",{\"1\":{\"310\":1}}],[\"获取类或接口中的单个字段的信息\",{\"1\":{\"310\":1}}],[\"获取类或接口中的单个方法的信息\",{\"1\":{\"310\":1}}],[\"获取类的实例对象\",{\"1\":{\"310\":1}}],[\"获取值\",{\"1\":{\"295\":1}}],[\"获取关键字\",{\"1\":{\"295\":1}}],[\"获取map中的所有对象的集合\",{\"1\":{\"295\":1}}],[\"获取第i个元素\",{\"1\":{\"291\":1}}],[\"获取字符串长度\",{\"1\":{\"156\":1}}],[\"获取\",{\"1\":{\"118\":1,\"380\":1}}],[\"获取对应职业文件姓名\",{\"1\":{\"118\":1}}],[\"获取的数据与地图一样\",{\"1\":{\"112\":1}}],[\"获取的是工作岗位的数量\",{\"1\":{\"111\":1}}],[\"获取数据与上图一样\",{\"1\":{\"110\":1}}],[\"获取所有职位信息所在的div标签\",{\"1\":{\"96\":1}}],[\"获取到\",{\"1\":{\"89\":1}}],[\"获取城市编码\",{\"1\":{\"84\":1,\"86\":1,\"91\":1,\"93\":1}}],[\"获取城市对应省份全称\",{\"1\":{\"76\":1}}],[\"获取单位\",{\"1\":{\"76\":1}}],[\"怎么办\",{\"1\":{\"516\":1}}],[\"怎样判断当前同步状态是否成功获取或者是否成功释放\",{\"1\":{\"508\":1}}],[\"怎样计算得出索引\",{\"1\":{\"399\":1}}],[\"怎样从\",{\"1\":{\"378\":1}}],[\"怎样才能从\",{\"1\":{\"378\":1}}],[\"专注于获取释放的逻辑来实现自己想要表达的同步语义\",{\"1\":{\"508\":1}}],[\"专业版\",{\"1\":{\"68\":1}}],[\"专业版本\",{\"1\":{\"68\":1}}],[\"摘自\",{\"1\":{\"507\":1}}],[\"屏蔽\",{\"1\":{\"508\":1}}],[\"屏蔽了同步状态的管理\",{\"1\":{\"506\":1}}],[\"屏障\",{\"1\":{\"469\":8,\"487\":2,\"489\":2}}],[\"隐藏了实现细节\",{\"1\":{\"506\":1}}],[\"隐式支持重入性\",{\"1\":{\"358\":1}}],[\"隐式转化\",{\"1\":{\"233\":1}}],[\"隐式内连接语法\",{\"1\":{\"207\":1}}],[\"隐式内连接\",{\"1\":{\"207\":1}}],[\"虽然它失去了像\",{\"1\":{\"504\":1}}],[\"虽然只有一行代码\",{\"1\":{\"487\":1}}],[\"综上分析\",{\"1\":{\"499\":1}}],[\"串行\",{\"1\":{\"496\":1}}],[\"载入\",{\"1\":{\"494\":1}}],[\"动作使用\",{\"1\":{\"494\":1}}],[\"动态扩容的数组\",{\"1\":{\"327\":1}}],[\"动态调用实例的成员函数\",{\"1\":{\"309\":1}}],[\"动态引入类\",{\"1\":{\"309\":1}}],[\"动态大小\",{\"1\":{\"227\":1}}],[\"溢出\",{\"0\":{\"490\":1},\"1\":{\"490\":2}}],[\"额外增加约束\",{\"1\":{\"488\":1}}],[\"初识\",{\"0\":{\"502\":1,\"506\":1}}],[\"初次读引用变量\",{\"1\":{\"487\":3}}],[\"初次读对象引用和初次读该对象包含的\",{\"1\":{\"487\":1}}],[\"初始状态\",{\"1\":{\"513\":1}}],[\"初始时线程的本地内存中\",{\"1\":{\"468\":1}}],[\"初始化对象\",{\"1\":{\"497\":1}}],[\"初始化之前的值\",{\"1\":{\"487\":1}}],[\"初始化放在第一次插入数据时\",{\"1\":{\"397\":1}}],[\"初始化有两种\",{\"1\":{\"324\":1}}],[\"初始化时不需要指明数组大小\",{\"1\":{\"160\":1}}],[\"初始化\",{\"1\":{\"26\":1,\"260\":1,\"262\":1,\"399\":1}}],[\"零值\",{\"1\":{\"487\":1}}],[\"父类被\",{\"1\":{\"483\":1}}],[\"父类的\",{\"1\":{\"482\":1}}],[\"举个例子\",{\"1\":{\"507\":1}}],[\"举一个小例子\",{\"1\":{\"483\":1}}],[\"举例来说\",{\"1\":{\"508\":1}}],[\"举例\",{\"1\":{\"82\":1,\"233\":1}}],[\"宏变量\",{\"1\":{\"479\":2}}],[\"声明该实例变量或者在构造器中指定初始值\",{\"1\":{\"477\":1}}],[\"必要要在非静态初始化块\",{\"1\":{\"477\":1}}],[\"必须保证多个线程能够安全的释放同步状态\",{\"1\":{\"523\":1}}],[\"必须调用\",{\"1\":{\"504\":1}}],[\"必须符合以下两条规则\",{\"1\":{\"494\":1}}],[\"必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值\",{\"1\":{\"477\":1}}],[\"必须要切换到对应的数据库中\",{\"1\":{\"175\":1}}],[\"必须实现\",{\"1\":{\"333\":1}}],[\"必须能被400整除\",{\"1\":{\"239\":1}}],[\"必须使所有的数据都保持一致状态\",{\"1\":{\"218\":1}}],[\"必须同名\",{\"1\":{\"129\":1}}],[\"吗\",{\"0\":{\"473\":1,\"485\":1}}],[\"给出答案\",{\"1\":{\"470\":1}}],[\"给定map大小\",{\"1\":{\"397\":1}}],[\"给定map的大小以及加载因子\",{\"1\":{\"397\":1}}],[\"给定map的大小\",{\"1\":{\"397\":1}}],[\"给定一个map\",{\"1\":{\"397\":1}}],[\"禁止在构造函数对一个\",{\"1\":{\"488\":1}}],[\"禁止初次读对象的引用与读该对象包含的\",{\"1\":{\"488\":1}}],[\"禁止\",{\"1\":{\"488\":1}}],[\"禁止编译器把\",{\"1\":{\"487\":1}}],[\"禁止对final域的写重排序到构造函数之外\",{\"1\":{\"487\":1}}],[\"禁止下面所有的普通写操作和上面的\",{\"1\":{\"469\":1}}],[\"禁止下面所有的普通读操作和上面的\",{\"1\":{\"469\":1}}],[\"禁止上面的普通写和下面的\",{\"1\":{\"469\":1}}],[\"防止上面的\",{\"1\":{\"469\":1}}],[\"防城港\",{\"1\":{\"76\":1,\"77\":1}}],[\"随后执行\",{\"1\":{\"468\":1}}],[\"随州\",{\"1\":{\"76\":1,\"77\":1}}],[\"脏值\",{\"1\":{\"461\":1}}],[\"脏读\",{\"1\":{\"429\":1,\"437\":1}}],[\"经常会被用作不变类上\",{\"1\":{\"484\":1}}],[\"经过我们这样的分析\",{\"1\":{\"516\":1}}],[\"经过我们的分析可以得出如下结论\",{\"1\":{\"482\":1}}],[\"经过上面的分析\",{\"1\":{\"467\":1,\"517\":1}}],[\"经过上面的理解\",{\"1\":{\"461\":1}}],[\"经过分析我们可以得出如下结论\",{\"1\":{\"466\":1}}],[\"经验\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":1}}],[\"导致锁膨胀的流程图\",{\"1\":{\"459\":1}}],[\"导航栏输入\",{\"1\":{\"128\":1}}],[\"解锁\",{\"0\":{\"459\":1},\"1\":{\"494\":1}}],[\"解决方案可以沿袭数据库中常用的乐观锁方式\",{\"1\":{\"451\":1}}],[\"解决外键关联\",{\"1\":{\"200\":1}}],[\"遍历偏向对象的锁记录\",{\"1\":{\"455\":1}}],[\"遍历过所有的节点以后就完成了复制工作\",{\"1\":{\"401\":1}}],[\"拥有偏向锁的栈会被执行\",{\"1\":{\"455\":1}}],[\"拥有一个同步队列和多个等待队列\",{\"1\":{\"377\":1}}],[\"竞争锁\",{\"1\":{\"454\":1}}],[\"偏向锁在\",{\"1\":{\"456\":1}}],[\"偏向锁撤销流程\",{\"1\":{\"455\":1}}],[\"偏向锁使用了一种等到竞争出现才释放锁的机制\",{\"1\":{\"455\":1}}],[\"偏向锁的撤销\",{\"0\":{\"455\":1},\"1\":{\"455\":1}}],[\"偏向锁的获取\",{\"0\":{\"454\":1}}],[\"偏向锁\",{\"0\":{\"453\":1}}],[\"偏向锁状态\",{\"1\":{\"452\":1}}],[\"意味着偏向锁升级成轻量级锁后不能降级成偏向锁\",{\"1\":{\"452\":1}}],[\"意味着可以有多个条件\",{\"1\":{\"194\":1}}],[\"级别从低到高依次是\",{\"1\":{\"452\":1}}],[\"年龄值以及锁标志位等信息\",{\"1\":{\"452\":1}}],[\"年份值\",{\"1\":{\"183\":1}}],[\"未优化前\",{\"1\":{\"449\":1}}],[\"未选中时\",{\"1\":{\"71\":1}}],[\"预期的值\",{\"1\":{\"449\":1}}],[\"预计同时操作数据的线程\",{\"1\":{\"397\":1}}],[\"毕竟\",{\"1\":{\"446\":1}}],[\"毕节\",{\"1\":{\"76\":1,\"77\":1}}],[\"令人钦佩\",{\"1\":{\"446\":1}}],[\"伟大的科学家们也是这样做的\",{\"1\":{\"446\":1}}],[\"缩短获取锁的时间\",{\"1\":{\"446\":1}}],[\"缩进来增强语句的可读性\",{\"1\":{\"171\":1}}],[\"缩进\",{\"1\":{\"71\":1}}],[\"支付宝解放了大家去钱包找钱的过程\",{\"1\":{\"446\":1}}],[\"支持自定义时间单位\",{\"1\":{\"375\":1}}],[\"支持可重复加锁\",{\"1\":{\"366\":1}}],[\"支持重入\",{\"1\":{\"364\":1}}],[\"支持重入性\",{\"1\":{\"358\":1}}],[\"支持非公平性\",{\"1\":{\"364\":1}}],[\"支持两种锁\",{\"1\":{\"360\":1}}],[\"支持从小到大或者从大到小查找\",{\"1\":{\"221\":1}}],[\"支持多线程\",{\"1\":{\"139\":1}}],[\"支持多种内容类型和视图\",{\"1\":{\"41\":1}}],[\"支持市面主流的开发语言并且可以通过\",{\"1\":{\"134\":1}}],[\"支持全面\",{\"1\":{\"134\":1}}],[\"排它性\",{\"1\":{\"446\":1}}],[\"排序\",{\"1\":{\"329\":1}}],[\"排序方式\",{\"1\":{\"197\":1}}],[\"排序方式2\",{\"1\":{\"197\":1}}],[\"排序方式1\",{\"1\":{\"197\":1}}],[\"排序在日常开发中是非常常见的一个操作\",{\"1\":{\"197\":1}}],[\"排序查询\",{\"0\":{\"197\":1},\"1\":{\"192\":1}}],[\"排序字段列表\",{\"1\":{\"192\":1}}],[\"啦\",{\"1\":{\"445\":1}}],[\"告诉\",{\"1\":{\"445\":1,\"508\":1}}],[\"蓝色的则是通过程序顺序规则和监视器锁规则推测出来\",{\"1\":{\"444\":1}}],[\"任意线程对\",{\"1\":{\"443\":1}}],[\"任意一个对象都拥有自己的监视器\",{\"1\":{\"443\":1}}],[\"任何一个\",{\"1\":{\"375\":1}}],[\"机制\",{\"0\":{\"443\":1}}],[\"今后可能需要关注的问题\",{\"0\":{\"437\":1}}],[\"认定一个\",{\"1\":{\"435\":1}}],[\"认定一个锁只会被单个线程访问\",{\"1\":{\"435\":1}}],[\"采取了保守策略\",{\"1\":{\"469\":1}}],[\"采取了不同的策略\",{\"1\":{\"435\":1}}],[\"采用模板方法进行设计\",{\"1\":{\"507\":1}}],[\"采用\",{\"1\":{\"403\":1}}],[\"采用懒加载的方式\",{\"1\":{\"393\":1}}],[\"采用二叉搜索树或者是红黑树来作为索引的结构有什么问题\",{\"1\":{\"221\":1}}],[\"易于编程\",{\"1\":{\"435\":1}}],[\"易学\",{\"1\":{\"65\":1}}],[\"站在\",{\"1\":{\"435\":1}}],[\"承担哪些功能\",{\"1\":{\"434\":1}}],[\"承德\",{\"1\":{\"76\":1,\"77\":1}}],[\"允许\",{\"1\":{\"433\":1}}],[\"允许这种重排序\",{\"1\":{\"432\":1,\"435\":1}}],[\"监视器锁规则\",{\"1\":{\"433\":1}}],[\"监听参数\",{\"1\":{\"95\":1}}],[\"于任意后续对\",{\"1\":{\"467\":1}}],[\"于任意后续对这个volatile域的读\",{\"1\":{\"467\":1}}],[\"于任意后续对这个\",{\"1\":{\"433\":1}}],[\"于对该监视器的加锁\",{\"1\":{\"444\":1}}],[\"于线程\",{\"1\":{\"433\":2}}],[\"于随后对这个锁的加锁\",{\"1\":{\"433\":1}}],[\"于该线程中的任意后续操作\",{\"1\":{\"433\":1}}],[\"于是就在桌子上贴了一张纸条\",{\"1\":{\"428\":1}}],[\"于是\",{\"1\":{\"399\":1}}],[\"于是我们开篇的第一个问题\",{\"1\":{\"366\":1}}],[\"点是\",{\"1\":{\"432\":2}}],[\"点击下一页按钮\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"点击i\",{\"1\":{\"70\":1}}],[\"点击close关闭即可\",{\"1\":{\"67\":1}}],[\"点击\",{\"1\":{\"45\":1,\"53\":1,\"57\":1}}],[\"严重影响了并发编程的效率\",{\"1\":{\"431\":1}}],[\"规则定义\",{\"1\":{\"467\":1}}],[\"规则中有一条是\",{\"1\":{\"467\":1}}],[\"规则以及内存抽象模型\",{\"1\":{\"445\":1}}],[\"规则简单易懂\",{\"1\":{\"436\":1}}],[\"规则对应于一个或多个编译器和处理器重排序规则\",{\"1\":{\"436\":1}}],[\"规则不但简单易懂\",{\"1\":{\"435\":1}}],[\"规则能满足程序员的需求\",{\"1\":{\"435\":1}}],[\"规则1\",{\"1\":{\"433\":1}}],[\"规则\",{\"0\":{\"431\":1},\"1\":{\"433\":3,\"435\":1,\"441\":1,\"444\":2}}],[\"问题在于\",{\"1\":{\"494\":1}}],[\"问题了\",{\"1\":{\"451\":1}}],[\"问题\",{\"1\":{\"430\":1,\"451\":1}}],[\"统称为处理器重排序\",{\"1\":{\"430\":1}}],[\"统计数量\",{\"1\":{\"195\":1}}],[\"统计该词出现的次数\",{\"1\":{\"118\":1}}],[\"尽可能地提高程序执行的并行度\",{\"1\":{\"432\":1}}],[\"尽可能提高并行度\",{\"1\":{\"430\":1}}],[\"尽管依然满足了\",{\"1\":{\"490\":1}}],[\"尽管\",{\"1\":{\"432\":1,\"442\":1,\"494\":1}}],[\"尽量保证每个锁只占用一个资源\",{\"1\":{\"349\":1}}],[\"抽象示意图\",{\"1\":{\"429\":1}}],[\"抽象结构模型\",{\"0\":{\"429\":1}}],[\"决定了一个线程对共享变量的写入何时对其他线程是可见的\",{\"1\":{\"429\":1}}],[\"共享锁的释放在\",{\"1\":{\"523\":1}}],[\"共享锁的释放\",{\"0\":{\"523\":1}}],[\"共享锁的获取方法为\",{\"1\":{\"522\":1}}],[\"共享锁的获取\",{\"0\":{\"522\":1}}],[\"共享锁的获取和释放以及可中断锁\",{\"1\":{\"512\":1}}],[\"共享锁\",{\"0\":{\"521\":1}}],[\"共享式锁\",{\"1\":{\"512\":1}}],[\"共享式释放同步状态\",{\"1\":{\"508\":1,\"512\":1}}],[\"共享式获取同步状态\",{\"1\":{\"508\":1,\"512\":1}}],[\"共享式获取与释放同步状态\",{\"1\":{\"507\":1}}],[\"共享式\",{\"1\":{\"508\":1}}],[\"共享变量会先放在主存中\",{\"1\":{\"429\":1}}],[\"共享数据会出现线程安全的问题\",{\"1\":{\"428\":1}}],[\"共享内存和消息传递\",{\"1\":{\"428\":1}}],[\"哪些不是原子操作\",{\"1\":{\"494\":1}}],[\"哪些是共享变量\",{\"1\":{\"428\":1}}],[\"哪怕数据库发生异常\",{\"1\":{\"218\":1}}],[\"妈妈在赶去坐公交的路上给小明打了个电话\",{\"1\":{\"428\":1}}],[\"妈妈的手机还有电\",{\"1\":{\"428\":1}}],[\"放在\",{\"1\":{\"428\":1}}],[\"放入\",{\"1\":{\"333\":1}}],[\"饭做好了\",{\"1\":{\"428\":1}}],[\"紧接着\",{\"1\":{\"423\":1}}],[\"紧接着到第\",{\"1\":{\"399\":1}}],[\"块中释放锁\",{\"1\":{\"504\":1}}],[\"块中执行\",{\"1\":{\"423\":1}}],[\"块中的代码\",{\"1\":{\"423\":1,\"518\":1}}],[\"块中的语句\",{\"1\":{\"423\":1}}],[\"块中\",{\"1\":{\"423\":1}}],[\"块盘\",{\"1\":{\"134\":2}}],[\"守护线程自然而然就会退出\",{\"1\":{\"423\":1}}],[\"守护线程是一种特殊的线程\",{\"1\":{\"423\":1}}],[\"守护线程\",{\"0\":{\"423\":1}}],[\"⬇️\",{\"1\":{\"422\":1}}],[\"⬇️pycharm\",{\"0\":{\"68\":1}}],[\"⬇️python\",{\"0\":{\"65\":1}}],[\"睡眠\",{\"1\":{\"419\":1}}],[\"调度器会先检查它是否具有比当前允许线程更高的优先级\",{\"1\":{\"417\":1}}],[\"调度器仍然需要分配时间片\",{\"1\":{\"414\":1}}],[\"调用方法enq\",{\"1\":{\"516\":1}}],[\"调用模板方法\",{\"1\":{\"507\":1}}],[\"调用这个对象的行为都可以获取正确的结果\",{\"1\":{\"427\":1}}],[\"调用对象的\",{\"1\":{\"413\":1}}],[\"调用构造器方法的时候并未构造出\",{\"1\":{\"397\":1}}],[\"调用该方法后会使得当前线程所封装的\",{\"1\":{\"378\":1}}],[\"调用\",{\"1\":{\"377\":1,\"378\":1,\"379\":3,\"386\":2,\"399\":1,\"515\":1,\"516\":1}}],[\"调用者不用管被调用方法是否完成\",{\"1\":{\"351\":1}}],[\"调用者后面的代码才能执行\",{\"1\":{\"351\":1}}],[\"调用者必须等待被调用的方法结束后\",{\"1\":{\"351\":1}}],[\"调用相同的函数\",{\"1\":{\"284\":1}}],[\"调用函数\",{\"0\":{\"266\":1}}],[\"抢占式调度系统给每一个可运行线程一个时间片来执行任务\",{\"1\":{\"414\":1}}],[\"事实上\",{\"1\":{\"414\":1}}],[\"事务的四大特性简称为\",{\"1\":{\"218\":1}}],[\"事务一旦提交或回滚\",{\"1\":{\"218\":1}}],[\"事务完成时\",{\"1\":{\"218\":1}}],[\"事务是不可分割的最小单元\",{\"1\":{\"218\":1}}],[\"事务是一组操作的集合\",{\"1\":{\"216\":1}}],[\"事务有哪些特性\",{\"1\":{\"218\":1}}],[\"事务中的操作要么全部成功\",{\"1\":{\"218\":1}}],[\"事务中间件\",{\"1\":{\"9\":1}}],[\"事务操作有关的\",{\"1\":{\"217\":1}}],[\"事务作用\",{\"1\":{\"216\":1}}],[\"事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求\",{\"1\":{\"216\":1}}],[\"事务\",{\"0\":{\"215\":1}}],[\"看看他们做了什么事情\",{\"1\":{\"517\":1}}],[\"看上面的图片已经将每种情况整理出来了\",{\"1\":{\"477\":1}}],[\"看似没有其他线程参与\",{\"1\":{\"413\":1}}],[\"看完了\",{\"1\":{\"400\":1}}],[\"看完了写锁\",{\"1\":{\"369\":1}}],[\"终止线程\",{\"0\":{\"416\":1}}],[\"终止\",{\"1\":{\"412\":1}}],[\"知道\",{\"1\":{\"409\":1}}],[\"明白它的底层数据结构\",{\"1\":{\"408\":1}}],[\"独占式锁的获取过程也就是\",{\"1\":{\"517\":1}}],[\"独占式锁的获取和释放\",{\"1\":{\"512\":1}}],[\"独占式锁\",{\"1\":{\"512\":1}}],[\"独占式锁进行线程安全的并发控制的\",{\"1\":{\"391\":1}}],[\"独占式释放同步状态\",{\"1\":{\"508\":1}}],[\"独占式获取同步状态\",{\"1\":{\"508\":1,\"512\":1}}],[\"独占式获取与释放同步状态\",{\"1\":{\"507\":1}}],[\"独占式\",{\"1\":{\"508\":1}}],[\"独占锁的释放就相对来说比较容易理解了\",{\"1\":{\"518\":1}}],[\"独占锁的释放\",{\"0\":{\"518\":1}}],[\"独占锁的获取\",{\"0\":{\"515\":1}}],[\"独占锁\",{\"0\":{\"514\":1},\"1\":{\"407\":1}}],[\"谈谈concurrenthashmap1\",{\"1\":{\"403\":1}}],[\"起到了控制的作用\",{\"1\":{\"403\":1}}],[\"起始索引可以省略\",{\"1\":{\"198\":1}}],[\"起始索引从\",{\"1\":{\"198\":1}}],[\"起始索引\",{\"1\":{\"198\":2}}],[\"臃肿的设计\",{\"1\":{\"403\":1}}],[\"刚好在做\",{\"1\":{\"451\":1}}],[\"刚好等于新容量的\",{\"1\":{\"401\":1}}],[\"刚刚发送的消息\",{\"1\":{\"468\":1}}],[\"刚刚获取到的city\",{\"1\":{\"84\":1}}],[\"刚刚我们获取完url的两个参数信息\",{\"1\":{\"82\":1}}],[\"仔细体会下会发现很巧妙\",{\"1\":{\"401\":1}}],[\"倍即\",{\"1\":{\"401\":1}}],[\"倍代码为\",{\"1\":{\"401\":1}}],[\"倍\",{\"1\":{\"401\":1}}],[\"扩容结束修改sizectl属性\",{\"1\":{\"401\":1}}],[\"扩容时使用\",{\"1\":{\"393\":1}}],[\"原子操作\",{\"1\":{\"494\":1}}],[\"原子性是指一个操作是不可中断的\",{\"1\":{\"494\":1}}],[\"原子性是指事务包装的一组\",{\"1\":{\"218\":1}}],[\"原子性\",{\"0\":{\"493\":1,\"494\":1},\"1\":{\"218\":2,\"467\":1}}],[\"原来的变化路径\",{\"1\":{\"451\":1}}],[\"原因是它支持多线程进行扩容操作\",{\"1\":{\"401\":1}}],[\"桶数组节点即\",{\"1\":{\"400\":1}}],[\"桶节点的key与查找的key相同\",{\"1\":{\"400\":1}}],[\"碰撞\",{\"1\":{\"399\":1}}],[\"覆盖旧值即可\",{\"1\":{\"399\":1}}],[\"往链表中插入节点的部分代码为\",{\"1\":{\"399\":1}}],[\"且\",{\"1\":{\"432\":1,\"433\":1}}],[\"且这两个操作有一个为写操作\",{\"1\":{\"430\":1}}],[\"且消耗最少的资源\",{\"1\":{\"415\":1}}],[\"且该节点为特殊节点\",{\"1\":{\"399\":1}}],[\"且每条\",{\"1\":{\"276\":1}}],[\"确定遍历中的索引i\",{\"1\":{\"401\":1}}],[\"确定好数组的索引\",{\"1\":{\"399\":1}}],[\"确定在\",{\"1\":{\"399\":1}}],[\"确保main线程结束前能给daemonthread能够分到时间片\",{\"1\":{\"423\":1}}],[\"确保用户输入不为空\",{\"1\":{\"86\":1,\"93\":1}}],[\"确保在对象销毁时关闭csv文件\",{\"1\":{\"86\":1,\"93\":1}}],[\"确保如果文件打开失败\",{\"1\":{\"86\":1,\"93\":1}}],[\"步增加了对中断的检测\",{\"1\":{\"520\":1}}],[\"步会先计算出按照现在时间和超时时间计算出理论上的截止时间\",{\"1\":{\"520\":1}}],[\"步\",{\"1\":{\"399\":1,\"520\":1}}],[\"步中的\",{\"1\":{\"520\":2}}],[\"步中会进一步计算数组中可用的大小\",{\"1\":{\"398\":1}}],[\"步中会先通过\",{\"1\":{\"398\":1}}],[\"步中调用\",{\"1\":{\"378\":1}}],[\"称为\",{\"1\":{\"399\":1}}],[\"称为嵌套查询\",{\"1\":{\"210\":1}}],[\"挺有意思的吧\",{\"1\":{\"398\":1}}],[\"乘以加载因子\",{\"1\":{\"398\":1}}],[\"得出数组的大小\",{\"1\":{\"398\":1}}],[\"|=\",{\"1\":{\"397\":5}}],[\"||\",{\"1\":{\"194\":1,\"240\":2,\"366\":2,\"369\":1,\"370\":1,\"378\":1,\"379\":1,\"398\":2,\"399\":4,\"400\":2,\"401\":3,\"402\":8,\"518\":1,\"520\":1}}],[\"种操作都是原子的\",{\"1\":{\"494\":1}}],[\"种状态\",{\"1\":{\"412\":1,\"452\":1}}],[\"种构造器\",{\"1\":{\"397\":1}}],[\"种构造器方法\",{\"1\":{\"397\":1}}],[\"种情况的条件是当前等待的线程被中断后代码会走到\",{\"1\":{\"378\":1}}],[\"树节点\",{\"1\":{\"394\":1}}],[\"树的高度一旦高了\",{\"1\":{\"221\":1}}],[\"树的层级比较深\",{\"1\":{\"221\":1}}],[\"域也为\",{\"1\":{\"517\":1}}],[\"域设置为\",{\"1\":{\"517\":1}}],[\"域已经完全初始化成功\",{\"1\":{\"490\":1}}],[\"域已经在构造函数被初始化过了\",{\"1\":{\"490\":1}}],[\"域已经被正确初始化过了\",{\"1\":{\"487\":1}}],[\"域需要的\",{\"1\":{\"489\":1}}],[\"域会要求编译器在\",{\"1\":{\"489\":1}}],[\"域读\",{\"1\":{\"488\":1}}],[\"域全部已经初始化过\",{\"1\":{\"488\":1}}],[\"域写重排序规则\",{\"1\":{\"490\":1}}],[\"域写重排序规则可以确保我们在使用一个对象引用的时候\",{\"1\":{\"490\":1}}],[\"域写重排序到构造方法之外\",{\"1\":{\"488\":1}}],[\"域写与构造方法重排序\",{\"1\":{\"488\":1}}],[\"域写\",{\"1\":{\"488\":1}}],[\"域写针对编译器和处理器重排序增加了这样的约束\",{\"1\":{\"488\":1}}],[\"域写之后\",{\"1\":{\"487\":1,\"489\":1}}],[\"域之前\",{\"1\":{\"487\":1}}],[\"域存在间接依赖性\",{\"1\":{\"487\":1}}],[\"域操作的前面插入一个\",{\"1\":{\"487\":1}}],[\"域变量前已经读到了该对象的引用\",{\"1\":{\"487\":1}}],[\"域变量\",{\"1\":{\"487\":1}}],[\"域重排序规则为\",{\"1\":{\"487\":1}}],[\"域重排序规则\",{\"0\":{\"486\":1},\"1\":{\"487\":2}}],[\"域的操作前插入一个\",{\"1\":{\"489\":1}}],[\"域的重排序\",{\"1\":{\"488\":1}}],[\"域的重排序规则会要求编译器在读\",{\"1\":{\"489\":1}}],[\"域的重排序规则可以确保\",{\"1\":{\"487\":2}}],[\"域的重排序规则为\",{\"1\":{\"487\":1}}],[\"域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序\",{\"1\":{\"488\":1}}],[\"域的对象的引用\",{\"1\":{\"487\":1}}],[\"域的读操作就\",{\"1\":{\"487\":1}}],[\"域的读\",{\"1\":{\"433\":1,\"489\":1}}],[\"域的写禁止重排序到构造方法外\",{\"1\":{\"488\":1}}],[\"域的写重排序到构造函数之外\",{\"1\":{\"487\":2}}],[\"域的写\",{\"1\":{\"433\":1,\"467\":1}}],[\"域为引用类型\",{\"0\":{\"488\":1}}],[\"域为基本类型\",{\"0\":{\"487\":1}}],[\"域为\",{\"1\":{\"408\":2}}],[\"域\",{\"1\":{\"394\":1,\"487\":1}}],[\"赋值\",{\"1\":{\"494\":1}}],[\"赋值给线程工作内存的变量\",{\"1\":{\"494\":1}}],[\"赋值给\",{\"1\":{\"397\":1,\"449\":1}}],[\"赋值给sizectl\",{\"1\":{\"397\":1}}],[\"赋值给变量\",{\"1\":{\"393\":1}}],[\"赋给\",{\"1\":{\"449\":1}}],[\"赋给变量操作就是不安全的\",{\"1\":{\"393\":1}}],[\"赋予可执行权限\",{\"1\":{\"126\":1}}],[\"×\",{\"1\":{\"393\":1}}],[\"−n\",{\"1\":{\"393\":1}}],[\"−1\",{\"1\":{\"393\":1,\"398\":2,\"399\":1}}],[\"装载\",{\"1\":{\"393\":1}}],[\"轻量级解锁时\",{\"1\":{\"459\":1}}],[\"轻量级锁状态和重量级锁状态\",{\"1\":{\"452\":1}}],[\"轻量级锁\",{\"0\":{\"457\":1},\"1\":{\"391\":1}}],[\"轻便\",{\"1\":{\"133\":1}}],[\"做一下总结\",{\"1\":{\"518\":1}}],[\"做晚饭后准备叫小明回家吃饭\",{\"1\":{\"428\":1}}],[\"做进一步封装\",{\"1\":{\"399\":1}}],[\"做到平衡的\",{\"1\":{\"399\":1}}],[\"做了哪些事情呢\",{\"1\":{\"397\":1}}],[\"做了很多的优化\",{\"1\":{\"391\":1}}],[\"做准备\",{\"1\":{\"44\":1}}],[\"呢\",{\"1\":{\"391\":1,\"399\":2}}],[\"版本的\",{\"1\":{\"403\":1}}],[\"版本与\",{\"1\":{\"403\":1}}],[\"版本中\",{\"1\":{\"399\":1}}],[\"版本中为了防止拉链过长\",{\"1\":{\"399\":1}}],[\"版本之前的\",{\"1\":{\"399\":1}}],[\"版本舍弃了\",{\"1\":{\"391\":1}}],[\"版的\",{\"1\":{\"128\":1}}],[\"光是代码量就足足增加了很多\",{\"1\":{\"391\":1}}],[\"充当锁的角色\",{\"1\":{\"391\":1}}],[\"充分利用多核\",{\"1\":{\"346\":1}}],[\"体系中古老的\",{\"1\":{\"391\":1}}],[\"体系下依然会有同样的方法实现等待\",{\"1\":{\"375\":1}}],[\"秒结束后通过\",{\"1\":{\"387\":1}}],[\"致使\",{\"1\":{\"387\":1}}],[\"致使线程阻塞\",{\"1\":{\"386\":1}}],[\"状态的更新使用\",{\"1\":{\"506\":1}}],[\"状态变化\",{\"1\":{\"452\":1}}],[\"状态转换可以说是线程的生命周期\",{\"1\":{\"417\":1}}],[\"状态时可以通过\",{\"1\":{\"417\":1}}],[\"状态如下图所示\",{\"1\":{\"408\":1}}],[\"状态\",{\"1\":{\"386\":2,\"403\":1,\"417\":7,\"443\":1,\"508\":1}}],[\"状态更新等\",{\"1\":{\"126\":1}}],[\"推出\",{\"1\":{\"386\":1}}],[\"推送代码到\",{\"0\":{\"26\":1}}],[\"案发现场\",{\"1\":{\"386\":1}}],[\"案例\",{\"1\":{\"178\":1,\"185\":2,\"189\":1,\"202\":1}}],[\"唤醒处于阻塞状态的指定线程\",{\"1\":{\"386\":1}}],[\"唤醒线程\",{\"1\":{\"386\":1}}],[\"唤醒一个等待在\",{\"1\":{\"375\":1}}],[\"纳秒\",{\"1\":{\"386\":1}}],[\"入队操作\",{\"0\":{\"516\":1}}],[\"入参增加一个\",{\"1\":{\"386\":3}}],[\"入栈元素e\",{\"1\":{\"330\":1}}],[\"阻塞同步\",{\"1\":{\"449\":1}}],[\"阻塞状态\",{\"1\":{\"417\":1}}],[\"阻塞\",{\"1\":{\"387\":1,\"412\":1}}],[\"阻塞了线程\",{\"1\":{\"386\":1}}],[\"阻塞和等待线程\",{\"0\":{\"415\":1}}],[\"阻塞和唤醒线程的功能是依赖于\",{\"1\":{\"386\":1}}],[\"阻塞和非阻塞通常用来形容多线程间的相互影响\",{\"1\":{\"353\":1}}],[\"阻塞和非阻塞\",{\"0\":{\"353\":1}}],[\"阻塞当前线程\",{\"1\":{\"386\":3}}],[\"阻塞线程\",{\"1\":{\"386\":1}}],[\"究竟为何方神圣\",{\"1\":{\"385\":1}}],[\"工具\",{\"0\":{\"384\":1}}],[\"工具类\",{\"0\":{\"334\":1}}],[\"处于中间层\",{\"1\":{\"435\":1}}],[\"处\",{\"1\":{\"379\":1,\"399\":1}}],[\"处理当前同步队列尾节点为\",{\"1\":{\"516\":1}}],[\"处理当前节点是treebin时的情况\",{\"1\":{\"401\":1}}],[\"处理当前节点为链表的头结点的情况\",{\"1\":{\"401\":1}}],[\"处理为例\",{\"1\":{\"489\":1}}],[\"处理器中\",{\"1\":{\"489\":1}}],[\"处理器会在读\",{\"1\":{\"487\":1}}],[\"处理器和编译为了性能优化会对指令序列有编译器和处理器重排序\",{\"1\":{\"485\":1}}],[\"处理器不直接和内存进行通信\",{\"1\":{\"466\":1}}],[\"处理器可以改变语句对应机器指令的执行顺序\",{\"1\":{\"430\":1}}],[\"处理被中断的情况\",{\"1\":{\"378\":1}}],[\"处理在第二步中cas操作失败的自旋已经实现重入性\",{\"1\":{\"369\":1}}],[\"处理冲突\",{\"1\":{\"226\":1}}],[\"处理完成后的数据如下\",{\"1\":{\"77\":1}}],[\"真正对头节点做处理的逻辑在\",{\"1\":{\"379\":1}}],[\"真正的并行也只能出现在拥有多个\",{\"1\":{\"352\":1}}],[\"超时时间是\",{\"1\":{\"520\":1}}],[\"超时时间结束\",{\"1\":{\"520\":1}}],[\"超时等待\",{\"0\":{\"524\":1}}],[\"超时等待式获取锁\",{\"0\":{\"520\":1}}],[\"超时等待锁获取这些特性的实现\",{\"1\":{\"512\":1}}],[\"超时获取锁\",{\"1\":{\"505\":1}}],[\"超时机制的支持\",{\"1\":{\"378\":1}}],[\"超过了话则取最大值\",{\"1\":{\"397\":1}}],[\"超出范围时抛出\",{\"1\":{\"300\":1}}],[\"到工作内存后\",{\"1\":{\"494\":1}}],[\"到目前为止\",{\"1\":{\"378\":2}}],[\"到这一步\",{\"1\":{\"34\":1}}],[\"尾节点\",{\"1\":{\"378\":1}}],[\"尾插入节点失败后负责自旋进行尝试\",{\"1\":{\"516\":1}}],[\"尾插入\",{\"1\":{\"378\":1,\"516\":1}}],[\"尾插入到等待队列中\",{\"1\":{\"378\":2}}],[\"持有偏向锁的线程才会释放锁\",{\"1\":{\"455\":1}}],[\"持有多个\",{\"1\":{\"377\":1}}],[\"持久性\",{\"1\":{\"218\":2}}],[\"示意图如下\",{\"1\":{\"377\":1,\"517\":1}}],[\"示例代码很简单就不说了\",{\"1\":{\"386\":1}}],[\"示例\",{\"1\":{\"183\":1,\"198\":1}}],[\"模板方法又依赖于被\",{\"1\":{\"508\":1}}],[\"模式下情景图如下\",{\"1\":{\"377\":1}}],[\"模糊匹配\",{\"1\":{\"194\":1}}],[\"底层方法\",{\"1\":{\"409\":1}}],[\"底层数据结构改变为采用数组+链表+红黑树的数据形式\",{\"1\":{\"391\":1}}],[\"底层级别的\",{\"1\":{\"375\":1}}],[\"底层是通过双向链表实现的\",{\"1\":{\"327\":1}}],[\"底层是通过数组\",{\"1\":{\"327\":1}}],[\"配合使用\",{\"1\":{\"377\":1}}],[\"配合完成等待通知机制\",{\"1\":{\"375\":1}}],[\"配置等\",{\"1\":{\"306\":1}}],[\"配置文件\",{\"0\":{\"139\":1}}],[\"配置\",{\"1\":{\"129\":1}}],[\"配置项目\",{\"1\":{\"16\":1}}],[\"几个方法实现等待\",{\"1\":{\"375\":1}}],[\"详解\",{\"0\":{\"374\":1}}],[\"更改为\",{\"1\":{\"467\":1}}],[\"更改node中的指针域next\",{\"1\":{\"409\":2}}],[\"更改node中的数据域item\",{\"1\":{\"409\":1}}],[\"更简单的说\",{\"1\":{\"435\":1}}],[\"更多关于\",{\"1\":{\"403\":1}}],[\"更新的新值\",{\"1\":{\"449\":1}}],[\"更新后数据并没有及时写回到主存\",{\"1\":{\"429\":1}}],[\"更新状态为0\",{\"1\":{\"379\":1}}],[\"更新\",{\"1\":{\"378\":1,\"402\":1}}],[\"更新lastwaiter\",{\"1\":{\"378\":1}}],[\"更新同步状态\",{\"1\":{\"369\":1}}],[\"更偏向于左外连接\",{\"1\":{\"208\":1}}],[\"减少写状态\",{\"1\":{\"367\":1}}],[\"减库存\",{\"1\":{\"346\":1}}],[\"位置放入\",{\"1\":{\"401\":1}}],[\"位置的元素再进行判断\",{\"1\":{\"401\":1}}],[\"位进行异或运算\",{\"1\":{\"399\":1}}],[\"位与高\",{\"1\":{\"399\":1}}],[\"位于\",{\"1\":{\"385\":1}}],[\"位于应用与操作系统\",{\"1\":{\"9\":1}}],[\"位表示\",{\"1\":{\"367\":1}}],[\"位用来表示读锁被获取的次数\",{\"1\":{\"366\":1,\"369\":1}}],[\"位用来表示写锁的获取次数\",{\"1\":{\"366\":1}}],[\"位代表什么呢\",{\"1\":{\"366\":1}}],[\"位\",{\"1\":{\"366\":2,\"452\":1}}],[\"位然后减\",{\"1\":{\"366\":1}}],[\"遵守\",{\"1\":{\"430\":1}}],[\"遵循获取写锁\",{\"1\":{\"364\":1,\"371\":1}}],[\"遵义\",{\"1\":{\"76\":1,\"77\":1}}],[\"吞吐量还是非公平优于公平\",{\"1\":{\"364\":1}}],[\"现代处理器采用了指令级并行技术来将多条指令重叠执行\",{\"1\":{\"430\":1}}],[\"现代操作系统基本采用时分的形式调度运行的线程\",{\"1\":{\"422\":1}}],[\"现象\",{\"1\":{\"360\":1,\"429\":1}}],[\"现在看这段代码\",{\"1\":{\"522\":1}}],[\"现在通过学习源码的方式\",{\"1\":{\"518\":1}}],[\"现在将这几种情况归纳整理一下\",{\"1\":{\"477\":1}}],[\"现在能够读出\",{\"1\":{\"470\":1}}],[\"现在已经\",{\"1\":{\"470\":1}}],[\"现在对于文章开头的问题\",{\"1\":{\"470\":1}}],[\"现在大概的理解就是\",{\"1\":{\"465\":1}}],[\"现在只需要扫描下就可以完成付款了\",{\"1\":{\"446\":1}}],[\"现在来看一看\",{\"1\":{\"444\":1}}],[\"现在来看看共享锁是怎样实现的\",{\"1\":{\"522\":1}}],[\"现在来看看\",{\"1\":{\"385\":1}}],[\"现在来看看读锁\",{\"1\":{\"369\":1}}],[\"现在来做一些总结\",{\"1\":{\"399\":1}}],[\"现在回过头再来看\",{\"1\":{\"378\":1}}],[\"现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的\",{\"1\":{\"519\":1}}],[\"现在我们已经很清楚获取独占式锁失败的线程包装成\",{\"1\":{\"516\":1}}],[\"现在我们来换一个角度进行考虑\",{\"1\":{\"478\":1}}],[\"现在我们来重点关注2\",{\"1\":{\"444\":1}}],[\"现在我们可以得出结论\",{\"1\":{\"379\":1}}],[\"现在我们可以得出另外一个结论\",{\"1\":{\"366\":1}}],[\"现在我们回过头来看写锁获取方法\",{\"1\":{\"366\":1}}],[\"现在这个问题的答案就已经被我们弄清楚了\",{\"1\":{\"366\":1}}],[\"现在就可以得出来一个结论\",{\"1\":{\"366\":1}}],[\"现在的问题就是每个城市对应的参数是什么\",{\"1\":{\"81\":1}}],[\"现在开始查看\",{\"1\":{\"34\":1}}],[\"饥饿\",{\"1\":{\"360\":1}}],[\"造成\",{\"1\":{\"360\":1}}],[\"源码中的\",{\"1\":{\"508\":1}}],[\"源码中涉及到并发处理都会使用\",{\"1\":{\"409\":1}}],[\"源码如下\",{\"1\":{\"370\":1,\"399\":1,\"515\":1,\"516\":3}}],[\"源码的实现逻辑请看注释\",{\"1\":{\"367\":1}}],[\"源码为\",{\"1\":{\"360\":2,\"366\":1,\"367\":1,\"397\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"源文件的名称应该和\",{\"1\":{\"281\":1}}],[\"源文件声明规则\",{\"0\":{\"281\":1}}],[\"满足原子性\",{\"1\":{\"494\":1}}],[\"满足以下条件则可以成为不可变类\",{\"1\":{\"484\":1}}],[\"满足\",{\"1\":{\"360\":1}}],[\"何谓公平性\",{\"1\":{\"360\":1}}],[\"计数器就会加一\",{\"1\":{\"443\":1}}],[\"计数加一\",{\"1\":{\"359\":1}}],[\"计时等待\",{\"1\":{\"412\":1}}],[\"计算出来就是一个负数\",{\"1\":{\"520\":1}}],[\"计算出刚好达到超时时间时的系统时间就是\",{\"1\":{\"520\":1}}],[\"计算\",{\"1\":{\"399\":1}}],[\"计算key的hash值\",{\"1\":{\"399\":1}}],[\"计算数组中可用的大小\",{\"1\":{\"398\":1}}],[\"计算公式\",{\"1\":{\"198\":1}}],[\"计算指定列的平均值\",{\"1\":{\"195\":1}}],[\"计算指定列的最小值\",{\"1\":{\"195\":1}}],[\"计算指定列的最大值\",{\"1\":{\"195\":1}}],[\"计算指定列的数值和\",{\"1\":{\"195\":1}}],[\"计算工作的平均工资\",{\"1\":{\"77\":1}}],[\"计算机网络\",{\"0\":{\"5\":1},\"1\":{\"2\":1}}],[\"计算机\",{\"0\":{\"2\":1}}],[\"针对上面的实例程序\",{\"1\":{\"488\":1}}],[\"针对引用数据类型\",{\"1\":{\"488\":1}}],[\"针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱\",{\"1\":{\"503\":1}}],[\"针对这两种类型的变量赋初值的时机是不同的\",{\"1\":{\"477\":1}}],[\"针对这种情况\",{\"1\":{\"429\":1}}],[\"针对这种境况\",{\"1\":{\"391\":1}}],[\"针对这种读多写少的情况\",{\"1\":{\"364\":1}}],[\"针对处理器重排序\",{\"1\":{\"430\":1}}],[\"针对编译器重排序\",{\"1\":{\"430\":1}}],[\"针对\",{\"1\":{\"375\":2}}],[\"针对第一个问题\",{\"1\":{\"359\":1}}],[\"针对于数据库设计\",{\"1\":{\"173\":1}}],[\"次方\",{\"1\":{\"397\":1}}],[\"次才算成功释放\",{\"1\":{\"359\":1}}],[\"次之后\",{\"1\":{\"359\":1}}],[\"次\",{\"1\":{\"359\":3,\"366\":1,\"441\":1,\"461\":1,\"494\":1}}],[\"次磁盘\",{\"1\":{\"221\":1}}],[\"公平性选择\",{\"1\":{\"364\":1}}],[\"公平性\",{\"1\":{\"360\":1}}],[\"公平锁为了保证时间上的绝对顺序\",{\"1\":{\"360\":1}}],[\"公平锁每次获取到锁为同步队列中的第一个节点\",{\"1\":{\"360\":1}}],[\"公平锁每次都是从同步队列中的第一个节点获取到锁\",{\"1\":{\"360\":1}}],[\"公平锁\",{\"1\":{\"360\":1}}],[\"公平锁与公平锁\",{\"0\":{\"360\":1}}],[\"公平锁和非公平锁\",{\"1\":{\"358\":1,\"360\":1}}],[\"公司领域\",{\"1\":{\"96\":1}}],[\"公司姓名\",{\"1\":{\"96\":1}}],[\"公司标签如图所示\",{\"1\":{\"96\":1}}],[\"公司信息如图所示\",{\"1\":{\"96\":1}}],[\"公司\",{\"1\":{\"75\":2,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":1}}],[\"彻底理解\",{\"0\":{\"357\":1,\"440\":1,\"464\":1}}],[\"什么是\",{\"0\":{\"448\":1}}],[\"什么是线程安全\",{\"1\":{\"427\":1}}],[\"什么是线程优先级呢\",{\"1\":{\"422\":1}}],[\"什么是对象存储\",{\"0\":{\"133\":1}}],[\"什么事就不用管了\",{\"1\":{\"351\":1}}],[\"尝试使用定时锁\",{\"1\":{\"349\":1}}],[\"避免一个线程在锁内部占有多个资源\",{\"1\":{\"349\":1}}],[\"避免一个线程同时获得多个锁\",{\"1\":{\"349\":1}}],[\"避免创建不需要的线程\",{\"1\":{\"348\":1}}],[\"完成对同步队列的头结点初始化工作以及\",{\"1\":{\"518\":1}}],[\"完成链式队列的头结点的初始化\",{\"1\":{\"516\":1}}],[\"完成扩容\",{\"1\":{\"401\":1}}],[\"完成文件夹\",{\"1\":{\"134\":1}}],[\"完全可以看出当前死锁的情况\",{\"1\":{\"349\":1}}],[\"证明这种推论\",{\"1\":{\"349\":1}}],[\"形成死锁\",{\"1\":{\"349\":1}}],[\"形参列表中的形参通常用逗号隔开\",{\"1\":{\"268\":1}}],[\"形参和实参的类型和个数必须匹配\",{\"1\":{\"267\":1}}],[\"形参和实参\",{\"0\":{\"267\":1}}],[\"释放前驱节点\",{\"1\":{\"516\":1,\"517\":1}}],[\"释放同步状态\",{\"1\":{\"512\":1}}],[\"释放后的变量才可以被其他线程锁定\",{\"1\":{\"494\":1}}],[\"释放当前线程所占用的lock\",{\"1\":{\"378\":1}}],[\"释放了\",{\"1\":{\"359\":1}}],[\"释放自减的方式实现重入\",{\"1\":{\"358\":1}}],[\"释放的resource\",{\"1\":{\"349\":1}}],[\"释放的\",{\"1\":{\"349\":1}}],[\"释放锁时对同步队列中的线程进行通知等核心方法\",{\"1\":{\"513\":1}}],[\"释放锁的时候会唤醒后继节点\",{\"1\":{\"518\":1}}],[\"释放锁的时候会将共享变量同步到主内存中\",{\"1\":{\"498\":1}}],[\"释放锁的时候会将值刷新到主内存中\",{\"1\":{\"445\":1}}],[\"释放锁的时候同样会重写到主内存中\",{\"1\":{\"445\":1}}],[\"释放锁的过程\",{\"1\":{\"378\":1}}],[\"释放锁相对应的内存语义\",{\"1\":{\"445\":1}}],[\"释放锁后就会将计数器减一\",{\"1\":{\"443\":1}}],[\"释放锁\",{\"1\":{\"316\":1,\"444\":1}}],[\"稍微不注意就会出现死锁的情况\",{\"1\":{\"349\":1}}],[\"线程阻塞等待\",{\"1\":{\"520\":1}}],[\"线程被中断抛出被中断异常\",{\"1\":{\"520\":1}}],[\"线程被封装成\",{\"1\":{\"518\":1}}],[\"线程被唤醒执行后续操作\",{\"1\":{\"387\":1}}],[\"线程进入等待状态等待获取独占式锁\",{\"1\":{\"516\":1}}],[\"线程进入到\",{\"1\":{\"417\":2}}],[\"线程排队等底层实现\",{\"1\":{\"508\":1}}],[\"线程线程\",{\"1\":{\"488\":1}}],[\"线程线程转换图如上图所示\",{\"1\":{\"417\":1}}],[\"线程中断抛异常\",{\"1\":{\"519\":1}}],[\"线程中将\",{\"1\":{\"470\":1}}],[\"线程中本地内存中共享变量就会置为失效的状态\",{\"1\":{\"468\":1}}],[\"线程对\",{\"1\":{\"465\":1}}],[\"线程在工作内存进行操作后何时会写到主内存中\",{\"1\":{\"465\":1}}],[\"线程在执行同步块之前\",{\"1\":{\"458\":1}}],[\"线程做累加操作有可能是使用原来的就值\",{\"1\":{\"461\":1}}],[\"线程累加后\",{\"1\":{\"461\":1}}],[\"线程获取锁是一个自旋的过程\",{\"1\":{\"518\":1}}],[\"线程获取锁是一种悲观锁策略\",{\"1\":{\"448\":1}}],[\"线程获取锁失败\",{\"1\":{\"518\":1,\"519\":1}}],[\"线程获取到锁\",{\"1\":{\"381\":1}}],[\"线程获取到锁之后更改条件\",{\"1\":{\"381\":1}}],[\"线程获取到\",{\"1\":{\"378\":1}}],[\"线程不需要再次获取同一把锁\",{\"1\":{\"443\":1}}],[\"线程运行时拥有自己的栈空间\",{\"1\":{\"441\":1}}],[\"线程运行结束后\",{\"1\":{\"417\":1}}],[\"线程之间主要通过读\",{\"1\":{\"428\":1}}],[\"线程之间如何完成同步\",{\"1\":{\"428\":1}}],[\"线程之间如何通信\",{\"1\":{\"428\":1}}],[\"线程间协作通信可以类比人与人之间的协作的方式\",{\"1\":{\"428\":1}}],[\"线程通信\",{\"0\":{\"428\":1}}],[\"线程可以通过\",{\"1\":{\"423\":1}}],[\"线程先睡眠\",{\"1\":{\"423\":1}}],[\"线程结束后\",{\"1\":{\"423\":2}}],[\"线程就不会出现阻塞停顿的状态\",{\"1\":{\"448\":1}}],[\"线程就可以理解守护线程\",{\"1\":{\"423\":1}}],[\"线程就处于可运行状态\",{\"1\":{\"414\":1}}],[\"线程规划存在差异\",{\"1\":{\"422\":1}}],[\"线程分配到的时间多少也就决定了线程使用处理器资源的多少\",{\"1\":{\"422\":1}}],[\"线程优先级\",{\"1\":{\"422\":1}}],[\"线程终止后\",{\"1\":{\"420\":1}}],[\"线程才会继续往下执行\",{\"1\":{\"419\":1}}],[\"线程切换到的是\",{\"1\":{\"417\":1}}],[\"线程创建之后调用\",{\"1\":{\"417\":1}}],[\"线程是会在不同的状态间进行转换的\",{\"1\":{\"417\":1}}],[\"线程状态变为\",{\"1\":{\"443\":1}}],[\"线程状态转换\",{\"0\":{\"417\":1}}],[\"线程状态及其属性\",{\"0\":{\"412\":1}}],[\"线程自然终于\",{\"1\":{\"416\":1}}],[\"线程会分配到若干时间片\",{\"1\":{\"422\":1}}],[\"线程会切换到\",{\"1\":{\"417\":1}}],[\"线程会由于以下两个原因之一而终止\",{\"1\":{\"416\":1}}],[\"线程会进入到\",{\"1\":{\"386\":1,\"417\":1}}],[\"线程调度的细节依赖于操作系统提供的服务\",{\"1\":{\"414\":1}}],[\"线程调用\",{\"1\":{\"387\":1}}],[\"线程的后继节点\",{\"1\":{\"513\":1}}],[\"线程的前驱节点\",{\"1\":{\"513\":1}}],[\"线程的排队\",{\"1\":{\"506\":1,\"507\":1}}],[\"线程的读操作\",{\"1\":{\"432\":1}}],[\"线程的写操作\",{\"1\":{\"432\":1}}],[\"线程的使用\",{\"1\":{\"423\":1}}],[\"线程的基本操作\",{\"0\":{\"418\":1}}],[\"线程的\",{\"1\":{\"412\":1,\"433\":1}}],[\"线程的信息\",{\"1\":{\"386\":1}}],[\"线程睡眠\",{\"1\":{\"387\":1}}],[\"线程时都会有阻塞对象的描述\",{\"1\":{\"386\":1}}],[\"线程信息可以看出\",{\"1\":{\"386\":1}}],[\"线程更改了条件此时相对于\",{\"1\":{\"381\":1}}],[\"线程开始执行的时候由于条件不满足\",{\"1\":{\"381\":1}}],[\"线程\",{\"1\":{\"380\":1,\"386\":2,\"387\":1,\"403\":2,\"413\":1,\"429\":4,\"444\":3,\"445\":4,\"455\":1,\"468\":3,\"470\":1,\"487\":4,\"488\":1,\"497\":1,\"516\":1}}],[\"线程安全的方式\",{\"1\":{\"407\":1}}],[\"线程安全\",{\"0\":{\"349\":1}}],[\"线程没有处于请求操作所要求的适当状态时抛出的异常\",{\"1\":{\"300\":1}}],[\"测量上下文切换次数\",{\"1\":{\"348\":1}}],[\"测量上下文切换的时长\",{\"1\":{\"348\":1}}],[\"测试点的\",{\"1\":{\"52\":1}}],[\"协程\",{\"1\":{\"348\":1}}],[\"协议的\",{\"1\":{\"133\":1}}],[\"协议\",{\"1\":{\"9\":1}}],[\"过于频繁反而无法发挥出多线程编程的优势\",{\"1\":{\"348\":1}}],[\"让其他线程有机会运行\",{\"1\":{\"414\":1}}],[\"让出的时间片只会分配给当前线程相同优先级的线程\",{\"1\":{\"422\":1}}],[\"让出的\",{\"1\":{\"422\":1}}],[\"让出\",{\"1\":{\"398\":1}}],[\"让每一个\",{\"1\":{\"391\":1}}],[\"让我们觉得多个线程是同时执行的\",{\"1\":{\"348\":1}}],[\"让两张表的数据建立连接\",{\"1\":{\"182\":1,\"200\":1}}],[\"频繁的上下文切换\",{\"0\":{\"348\":1}}],[\"难道就没有一点缺点么\",{\"1\":{\"347\":1}}],[\"面对复杂业务模型\",{\"1\":{\"346\":1}}],[\"面对如此复杂的计算量就需要充分利用多核的计算的能力\",{\"1\":{\"346\":1}}],[\"面试题\",{\"1\":{\"196\":1,\"218\":1}}],[\"像素的图片\",{\"1\":{\"346\":1}}],[\"顶级计算机科学家\",{\"1\":{\"346\":1}}],[\"性能得到提升\",{\"1\":{\"346\":1}}],[\"性别\",{\"1\":{\"201\":1}}],[\"催生了并发编程的趋势\",{\"1\":{\"346\":1}}],[\"甚至在极端情况下\",{\"1\":{\"399\":1}}],[\"甚至在一些数据库开发规范中\",{\"1\":{\"200\":1}}],[\"甚至很臭\",{\"1\":{\"377\":1}}],[\"甚至拥有多达\",{\"1\":{\"346\":1}}],[\"核心方法在于\",{\"1\":{\"518\":1}}],[\"核心方法为\",{\"1\":{\"359\":2,\"360\":1}}],[\"核心为两个部分\",{\"1\":{\"445\":1}}],[\"核心思想为\",{\"1\":{\"393\":1}}],[\"核心扩展上继续得到体验\",{\"1\":{\"346\":1}}],[\"核心\",{\"1\":{\"346\":1}}],[\"核心甚至\",{\"1\":{\"346\":1}}],[\"家用型\",{\"1\":{\"346\":1}}],[\"家目录路径下执行\",{\"1\":{\"146\":1}}],[\"短短十几年的时间\",{\"1\":{\"346\":1}}],[\"短文本字符串\",{\"1\":{\"183\":1}}],[\"他们将摩尔定律的责任推给了软件开发者\",{\"1\":{\"346\":1}}],[\"他们为了进一步提升计算速度\",{\"1\":{\"346\":1}}],[\"他们两者之间一对一的关系\",{\"1\":{\"201\":1}}],[\"聪明的硬件工程师并没有停止研发的脚步\",{\"1\":{\"346\":1}}],[\"芯片的计划推迟到2005年\",{\"1\":{\"346\":1}}],[\"宣布彻底取消\",{\"1\":{\"346\":1}}],[\"宣布\",{\"1\":{\"346\":1}}],[\"宣城\",{\"1\":{\"76\":1,\"77\":1}}],[\"摩尔定律似乎在\",{\"1\":{\"346\":1}}],[\"摩尔定律并不是一种自然法则或者是物理定律\",{\"1\":{\"346\":1}}],[\"摩尔定律\",{\"1\":{\"346\":1}}],[\"硬件的发展极其迅速\",{\"1\":{\"346\":1}}],[\"因此到这里就应该清楚了\",{\"1\":{\"517\":1}}],[\"因此同步队列选择了带头结点的链式存储结构\",{\"1\":{\"516\":1}}],[\"因此基本数据类型变量不能被改变\",{\"1\":{\"479\":1}}],[\"因此线程\",{\"1\":{\"468\":1}}],[\"因此也叫做非阻塞同步\",{\"1\":{\"449\":1}}],[\"因此系统就没有对象需要守护的了\",{\"1\":{\"423\":1}}],[\"因此可以执行顺序可以是\",{\"1\":{\"430\":1}}],[\"因此可以安全的将新值\",{\"1\":{\"393\":1}}],[\"因此可能在统计的时候有其他线程正在执行插入或删除操作\",{\"1\":{\"402\":1}}],[\"因此只能说这个数量是个估计值\",{\"1\":{\"402\":1}}],[\"因此通过\",{\"1\":{\"399\":1}}],[\"因此每个\",{\"1\":{\"377\":1}}],[\"因此\",{\"1\":{\"333\":1,\"346\":2,\"349\":1,\"360\":1,\"366\":1,\"391\":1,\"395\":1,\"413\":1,\"419\":1,\"423\":1,\"429\":1,\"430\":1,\"431\":1,\"432\":2,\"448\":1,\"466\":1,\"483\":1,\"487\":2,\"488\":2,\"494\":1,\"496\":1,\"498\":1,\"516\":2,\"518\":1}}],[\"因为同步队列是\",{\"1\":{\"512\":1}}],[\"因为构造函数中操作\",{\"1\":{\"490\":1}}],[\"因为普通方法无法修改\",{\"1\":{\"484\":1}}],[\"因为自旋会消耗\",{\"1\":{\"459\":1}}],[\"因为这是一种互斥同步\",{\"1\":{\"449\":1}}],[\"因为每个线程所操作的都是当前最新的版本数据\",{\"1\":{\"441\":1}}],[\"因为不可能在调用\",{\"1\":{\"402\":1}}],[\"因为不管是二叉搜索数还是红黑数\",{\"1\":{\"221\":1}}],[\"因为时间非常短\",{\"1\":{\"348\":1}}],[\"因为\",{\"1\":{\"330\":1,\"391\":1,\"417\":1,\"451\":1,\"508\":3}}],[\"因为在这类函数的最后一句后面会隐式地执行\",{\"1\":{\"275\":1}}],[\"因为此时name只读\",{\"1\":{\"153\":1}}],[\"堆排序只能保证根是最大\",{\"1\":{\"333\":1}}],[\"很明显已经超过了理论上的系统时间\",{\"1\":{\"520\":1}}],[\"很自然而然的想法就是每一个线程依次去读写这个共享变量\",{\"1\":{\"441\":1}}],[\"很多时候\",{\"1\":{\"420\":1}}],[\"很容易理解\",{\"1\":{\"397\":1,\"399\":1}}],[\"很显然它是让当前线程按照指定的时间休眠\",{\"1\":{\"421\":1}}],[\"很显然这段源码最终是靠\",{\"1\":{\"520\":1}}],[\"很显然这不是一种高效的方式\",{\"1\":{\"407\":1}}],[\"很显然这将是出现性能瓶颈的地方\",{\"1\":{\"364\":1}}],[\"很显然可以通过\",{\"1\":{\"399\":1}}],[\"很显然\",{\"1\":{\"378\":1,\"441\":1,\"508\":1}}],[\"很显然写锁是独占式锁\",{\"1\":{\"366\":1}}],[\"很显然不是\",{\"1\":{\"347\":1}}],[\"很难确定是取到了null元素还是队列为空\",{\"1\":{\"331\":1}}],[\"很少会使用物理外键\",{\"1\":{\"200\":1}}],[\"又叫做比较交换来鉴别线程是否出现冲突\",{\"1\":{\"448\":1}}],[\"又称为无锁操作\",{\"1\":{\"448\":1}}],[\"又称子查询\",{\"1\":{\"210\":1}}],[\"又能提高程序的执行效率\",{\"1\":{\"435\":1}}],[\"又获得了\",{\"1\":{\"422\":1}}],[\"又比如当我们在网上购物时\",{\"1\":{\"346\":1}}],[\"又实现\",{\"1\":{\"331\":1}}],[\"既然是旧的了\",{\"1\":{\"468\":1}}],[\"既然不会出现冲突自然而然就不会阻塞其他线程的操作\",{\"1\":{\"448\":1}}],[\"既然每次只能通过一个\",{\"1\":{\"446\":1}}],[\"既实现\",{\"1\":{\"331\":1}}],[\"既能节省存储成本\",{\"1\":{\"133\":1}}],[\"出队操作\",{\"0\":{\"517\":1}}],[\"出现冲突就重试当前操作直到没有冲突为止\",{\"1\":{\"448\":1}}],[\"出现线程安全的问题一般是因为主内存和工作内存数据不一致性和重排序导致的\",{\"1\":{\"427\":1}}],[\"出现线程安全的问题\",{\"1\":{\"349\":1}}],[\"出来一个\",{\"1\":{\"397\":1}}],[\"出口就只剩下两个地方\",{\"1\":{\"378\":1}}],[\"出一个\",{\"1\":{\"377\":1}}],[\"出栈一个元素\",{\"1\":{\"330\":1}}],[\"出题系统完善\",{\"1\":{\"44\":1}}],[\"出题必须使用\",{\"1\":{\"44\":1}}],[\"出题\",{\"1\":{\"43\":1}}],[\"另一个操作\",{\"1\":{\"432\":1}}],[\"另一个是\",{\"1\":{\"408\":1}}],[\"另一个是原链表的反序排列\",{\"1\":{\"401\":1}}],[\"另一种方式是\",{\"1\":{\"428\":1}}],[\"另一种是这份代码第一个测试点就没有通过\",{\"1\":{\"55\":1}}],[\"另外一种则是链表的形式\",{\"1\":{\"513\":1}}],[\"另外一种方式通过\",{\"1\":{\"391\":1}}],[\"另外在\",{\"1\":{\"503\":1}}],[\"另外在阻塞线程这一系列方法中还有一个很有意思的现象就是\",{\"1\":{\"386\":1}}],[\"另外也验证了\",{\"1\":{\"445\":1}}],[\"另外需要注意的是\",{\"1\":{\"417\":1,\"422\":1}}],[\"另外当\",{\"1\":{\"417\":1}}],[\"另外由于\",{\"1\":{\"413\":1}}],[\"另外只用到了异或运算\",{\"1\":{\"399\":1}}],[\"另外还会有另外一个问题\",{\"1\":{\"516\":1}}],[\"另外还要一个特别有意思的事情就是关于重排序问题\",{\"1\":{\"435\":1}}],[\"另外还提供了超时等待的方法\",{\"1\":{\"420\":1}}],[\"另外还提供了另外一种方式\",{\"1\":{\"360\":1}}],[\"另外还需要注意的是\",{\"1\":{\"398\":1}}],[\"另外可以看出很多属性都是用\",{\"1\":{\"394\":1}}],[\"另外注意到\",{\"1\":{\"377\":1}}],[\"另外\",{\"1\":{\"330\":1,\"346\":1,\"369\":1,\"387\":1,\"391\":1,\"397\":1,\"399\":1,\"408\":1,\"413\":1,\"419\":2,\"421\":1,\"422\":1,\"427\":1,\"430\":1,\"437\":2}}],[\"映射\",{\"0\":{\"329\":1}}],[\"映射到表中一个位置以便存储和检索数据的数据结构\",{\"1\":{\"226\":1}}],[\"接着调用\",{\"1\":{\"399\":1}}],[\"接近\",{\"1\":{\"391\":1}}],[\"接收到通知条件满足\",{\"1\":{\"381\":1}}],[\"接下来就去研究一下加入队列的方式\",{\"1\":{\"516\":1}}],[\"接下来要对这些模板方法的逻辑进行学习\",{\"1\":{\"512\":1}}],[\"接下来\",{\"1\":{\"378\":1,\"513\":1}}],[\"接下来我们用一个\",{\"1\":{\"377\":1}}],[\"接受一个集合容器\",{\"1\":{\"327\":1}}],[\"接口中的方法也只是调用了\",{\"1\":{\"508\":1}}],[\"接口中定义的方法\",{\"1\":{\"505\":1}}],[\"接口中不添加修饰符时\",{\"1\":{\"286\":1}}],[\"接口出现之前\",{\"1\":{\"504\":1}}],[\"接口实际上扩展自\",{\"1\":{\"332\":1}}],[\"接口或者是\",{\"1\":{\"329\":1}}],[\"接口时\",{\"1\":{\"300\":1}}],[\"接口的\",{\"1\":{\"364\":2}}],[\"接口的一个类\",{\"1\":{\"358\":1}}],[\"接口的多态\",{\"0\":{\"289\":1}}],[\"接口的实现\",{\"0\":{\"288\":1}}],[\"接口的继承\",{\"0\":{\"287\":1}}],[\"接口的定义\",{\"0\":{\"286\":1}}],[\"接口也可以继承其他接口\",{\"1\":{\"285\":1}}],[\"接口协议\",{\"1\":{\"134\":1}}],[\"接口\",{\"0\":{\"285\":1,\"505\":1},\"1\":{\"133\":1,\"291\":1,\"293\":1,\"294\":1,\"295\":1,\"314\":1,\"329\":3,\"331\":2,\"333\":2,\"394\":1,\"413\":5,\"504\":1}}],[\"顺序链表\",{\"1\":{\"327\":1}}],[\"顺序数组列表\",{\"1\":{\"327\":1}}],[\"列表\",{\"0\":{\"327\":1}}],[\"列子查询\",{\"0\":{\"212\":1},\"1\":{\"210\":1}}],[\"转换成\",{\"1\":{\"413\":1}}],[\"转换成线程安全的\",{\"1\":{\"407\":1}}],[\"转换为string\",{\"1\":{\"324\":1}}],[\"转byte\",{\"1\":{\"324\":1}}],[\"没一开始没有k\",{\"1\":{\"329\":1}}],[\"没找到则返回\",{\"1\":{\"324\":2}}],[\"没有把\",{\"1\":{\"494\":1}}],[\"没有的话就调用\",{\"1\":{\"399\":1}}],[\"没有线程先获取锁\",{\"1\":{\"377\":1}}],[\"没有线程安全问题\",{\"1\":{\"139\":1}}],[\"没有返回值的\",{\"1\":{\"275\":1}}],[\"没有明确结构的数据\",{\"1\":{\"132\":1}}],[\"忽略大小写进行比较\",{\"1\":{\"324\":1}}],[\"忽略警告等\",{\"1\":{\"306\":1}}],[\"存在三个\",{\"1\":{\"433\":1}}],[\"存放的是\",{\"1\":{\"394\":1}}],[\"存放字符串池\",{\"1\":{\"324\":1}}],[\"存储结构\",{\"1\":{\"452\":1}}],[\"存储的的是\",{\"1\":{\"221\":1}}],[\"存储的元数据主要包括对象的描述信息\",{\"1\":{\"133\":1}}],[\"存储到了相同地址\",{\"1\":{\"260\":1}}],[\"存储到\",{\"1\":{\"198\":1}}],[\"存储\",{\"1\":{\"134\":1,\"494\":1}}],[\"存储桶\",{\"1\":{\"133\":1}}],[\"存储和检索数据\",{\"1\":{\"133\":1}}],[\"存储数据的目录路径\",{\"1\":{\"128\":1}}],[\"系列的返回值\",{\"1\":{\"324\":1}}],[\"系统中一般默认使用\",{\"1\":{\"146\":1}}],[\"刷题过程中常用\",{\"1\":{\"321\":1}}],[\"刷新一下网页\",{\"1\":{\"81\":1}}],[\"加入同步队列的线程引用\",{\"1\":{\"513\":1}}],[\"加一\",{\"1\":{\"494\":1}}],[\"加锁线程\",{\"1\":{\"467\":1}}],[\"加锁\",{\"0\":{\"458\":1},\"1\":{\"444\":1,\"445\":1}}],[\"加锁和解锁必须在一个数据库连接里\",{\"1\":{\"349\":1}}],[\"加载因子以及并发度\",{\"1\":{\"397\":1}}],[\"加载因子\",{\"1\":{\"393\":1,\"398\":1,\"399\":2}}],[\"加载新内容\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":2}}],[\"加到函数上\",{\"1\":{\"317\":1}}],[\"加到代码块上\",{\"1\":{\"317\":1}}],[\"锁和同步器很好的隔离了使用者和实现者所需关注的领域\",{\"1\":{\"506\":1}}],[\"锁是面向使用者\",{\"1\":{\"506\":1}}],[\"锁是用来控制多个线程访问共享资源的方式\",{\"1\":{\"504\":1}}],[\"锁定\",{\"1\":{\"494\":1}}],[\"锁就会膨胀成重量级锁\",{\"1\":{\"459\":1}}],[\"锁不仅不存在多线程竞争\",{\"1\":{\"453\":1}}],[\"锁可以升级但不能降级\",{\"1\":{\"452\":1}}],[\"锁一共有\",{\"1\":{\"452\":1}}],[\"锁获取和锁释放的内存语义\",{\"0\":{\"445\":1}}],[\"锁住的依然是该类的类对象\",{\"1\":{\"443\":1}}],[\"锁住的是类对象\",{\"1\":{\"443\":1}}],[\"锁住\",{\"1\":{\"403\":1}}],[\"锁降级\",{\"0\":{\"371\":1},\"1\":{\"364\":1}}],[\"锁未被完全释放\",{\"1\":{\"359\":1}}],[\"锁成功被释放\",{\"1\":{\"359\":1}}],[\"锁加到了\",{\"1\":{\"317\":1}}],[\"锁\",{\"0\":{\"316\":1}}],[\"休眠一个线程\",{\"1\":{\"315\":1}}],[\"继续先看图\",{\"1\":{\"445\":1}}],[\"继续来看代码\",{\"1\":{\"444\":1}}],[\"继续执行\",{\"1\":{\"381\":1}}],[\"继续输入exit\",{\"1\":{\"67\":1}}],[\"继承aqs的静态内存类\",{\"1\":{\"508\":1}}],[\"继承aqs\",{\"1\":{\"507\":1}}],[\"继承该父类\",{\"1\":{\"481\":1}}],[\"继承thread\",{\"1\":{\"413\":2}}],[\"继承于承载数据的\",{\"1\":{\"394\":1}}],[\"继承了\",{\"1\":{\"330\":1,\"391\":1}}],[\"继承\",{\"1\":{\"314\":1,\"508\":1}}],[\"写的内存屏障都会被省略\",{\"1\":{\"489\":1}}],[\"写过程没有重排序\",{\"1\":{\"487\":1}}],[\"写\",{\"1\":{\"487\":3,\"489\":1}}],[\"写final域\",{\"1\":{\"487\":1}}],[\"写普通域\",{\"1\":{\"487\":1}}],[\"写一个例子来加深理解\",{\"1\":{\"481\":1}}],[\"写与下面可能有的\",{\"1\":{\"469\":1}}],[\"写重排序\",{\"1\":{\"469\":2,\"489\":1}}],[\"写是在前面和后面分别插入内存屏障\",{\"1\":{\"469\":1}}],[\"写操作的后面插入一个\",{\"1\":{\"469\":1}}],[\"写操作的前面插入一个\",{\"1\":{\"469\":1}}],[\"写后的状态图\",{\"1\":{\"468\":1}}],[\"写后读\",{\"1\":{\"430\":1}}],[\"写后写\",{\"1\":{\"430\":1}}],[\"写缓冲区\",{\"1\":{\"430\":1}}],[\"写共享变量来完成隐式通信\",{\"1\":{\"428\":1}}],[\"写状态由同步状态的低\",{\"1\":{\"367\":1}}],[\"写锁释放通过重写\",{\"1\":{\"367\":1}}],[\"写锁未被任何线程获取\",{\"1\":{\"366\":1}}],[\"写锁的释放\",{\"0\":{\"367\":1}}],[\"写锁的实现依然也是采用这种方式\",{\"1\":{\"366\":1}}],[\"写锁的获取\",{\"0\":{\"366\":1}}],[\"写锁详解\",{\"0\":{\"365\":1}}],[\"写锁是怎样获取和释放的\",{\"1\":{\"364\":1}}],[\"写锁能够降级成为读锁\",{\"1\":{\"364\":1,\"371\":1}}],[\"写锁获取之后能够再次获取写锁\",{\"1\":{\"364\":1}}],[\"写数据很少\",{\"1\":{\"364\":1}}],[\"写法2\",{\"1\":{\"314\":1,\"317\":1}}],[\"写法1\",{\"1\":{\"314\":1,\"317\":1}}],[\"写速度最高可以高达\",{\"1\":{\"134\":1}}],[\"反应到\",{\"1\":{\"494\":1}}],[\"反之\",{\"1\":{\"449\":1,\"516\":1}}],[\"反射\",{\"0\":{\"309\":1},\"1\":{\"309\":1}}],[\"反向播放\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"反向退格\",{\"1\":{\"71\":1}}],[\"抑制编译器警告\",{\"1\":{\"307\":1}}],[\"限定\",{\"1\":{\"487\":1}}],[\"限定某个函数必须重载其他函数\",{\"1\":{\"307\":1}}],[\"限定某个函数必须重写其他函数\",{\"1\":{\"307\":1}}],[\"限制该字段值不能为null\",{\"1\":{\"182\":1}}],[\"旧值\",{\"1\":{\"449\":1}}],[\"旧版中所遗留的繁冗代码和\",{\"1\":{\"306\":1}}],[\"旧字段名\",{\"1\":{\"185\":1}}],[\"构造头结点\",{\"1\":{\"516\":1}}],[\"构造了一个\",{\"1\":{\"487\":1}}],[\"构造函数返回前插入一个\",{\"1\":{\"489\":1}}],[\"构造函数\",{\"1\":{\"487\":1}}],[\"构造函数执行结束\",{\"1\":{\"433\":1}}],[\"构造两个链表\",{\"1\":{\"401\":1}}],[\"构造一个空的map\",{\"1\":{\"397\":1}}],[\"构造器\",{\"1\":{\"306\":1}}],[\"构成的链表\",{\"1\":{\"391\":1}}],[\"构建minioclient对象\",{\"1\":{\"139\":1}}],[\"十一\",{\"0\":{\"312\":1}}],[\"十\",{\"0\":{\"305\":1}}],[\"十堰\",{\"1\":{\"76\":1,\"77\":1}}],[\"捕获异常\",{\"0\":{\"302\":1}}],[\"及其回溯打印到标准错误流\",{\"1\":{\"301\":1}}],[\"及pycharm的使用\",{\"1\":{\"71\":1}}],[\"拒绝访问一个类的时候\",{\"1\":{\"300\":1}}],[\"换句话说\",{\"1\":{\"300\":1}}],[\"换行\",{\"1\":{\"237\":2}}],[\"抛出\",{\"1\":{\"419\":1}}],[\"抛出异常\",{\"0\":{\"303\":1}}],[\"抛出的异常表明某一线程已经试图等待对象的监视器\",{\"1\":{\"300\":1}}],[\"抛出的异常表明向方法传递了一个不合法或不正确的参数\",{\"1\":{\"300\":1}}],[\"抛出该异常\",{\"1\":{\"300\":9}}],[\"抛出此类的一个实例\",{\"1\":{\"300\":1}}],[\"抛出此异常\",{\"1\":{\"300\":1}}],[\"试图将错误类型的对象存储到一个对象数组时抛出的异常\",{\"1\":{\"300\":1}}],[\"异常\",{\"1\":{\"299\":1,\"300\":2}}],[\"异常处理可以允许我们在程序运行时进行诊断和补救\",{\"1\":{\"296\":1}}],[\"异常处理\",{\"0\":{\"296\":1}}],[\"虚拟机特殊的约定\",{\"1\":{\"465\":1}}],[\"虚拟机提供的最轻量级的同步机制\",{\"1\":{\"465\":1}}],[\"虚拟机就会自然退出\",{\"1\":{\"423\":1}}],[\"虚拟机\",{\"1\":{\"297\":1}}],[\"九\",{\"0\":{\"296\":1}}],[\"九江\",{\"1\":{\"76\":1,\"77\":1}}],[\"队列头结点引用指向当前节点\",{\"1\":{\"517\":1}}],[\"队列头指针用指向当前节点\",{\"1\":{\"516\":1}}],[\"队列的实现方式无外乎两者一是通过数组的形式\",{\"1\":{\"513\":1}}],[\"队列构成等待队列\",{\"1\":{\"506\":1}}],[\"队列也是我们常用的一种数据结构\",{\"1\":{\"407\":1}}],[\"队列中元素数量\",{\"1\":{\"333\":1}}],[\"队列中元素个数\",{\"1\":{\"332\":1}}],[\"队列\",{\"0\":{\"293\":1,\"331\":1}}],[\"弹出栈顶元素\",{\"1\":{\"292\":1}}],[\"压入元素\",{\"1\":{\"292\":1}}],[\"栈中的锁记录和对象头的\",{\"1\":{\"455\":1}}],[\"栈是否为空\",{\"1\":{\"292\":1}}],[\"栈\",{\"0\":{\"292\":1,\"330\":1}}],[\"清除\",{\"1\":{\"413\":1}}],[\"清空\",{\"1\":{\"291\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1}}],[\"清远\",{\"1\":{\"76\":1,\"77\":1}}],[\"八\",{\"0\":{\"290\":1}}],[\"八大基本数据类型和\",{\"1\":{\"272\":1}}],[\"普通变量\",{\"1\":{\"487\":1}}],[\"普通域\",{\"1\":{\"487\":2}}],[\"普通队列\",{\"1\":{\"330\":1}}],[\"普通函数中既可以调用普通函数\",{\"1\":{\"282\":1}}],[\"普洱\",{\"1\":{\"76\":1,\"77\":1}}],[\"带着这样的问题我们就来看看\",{\"1\":{\"516\":1}}],[\"带头结点与不带头结点相比\",{\"1\":{\"516\":1}}],[\"带\",{\"1\":{\"282\":1,\"386\":1}}],[\"静态域和数组元素都是放在堆内存中\",{\"1\":{\"428\":1}}],[\"静态函数中只能调用静态函数\",{\"1\":{\"282\":1}}],[\"静态\",{\"1\":{\"282\":1}}],[\"静态部署\",{\"1\":{\"26\":1}}],[\"七\",{\"0\":{\"279\":1}}],[\"七台河\",{\"1\":{\"76\":1,\"77\":1}}],[\"交出来的时间片其他线程都可以去竞争\",{\"1\":{\"422\":1}}],[\"交换a\",{\"1\":{\"275\":1}}],[\"交集部分数据\",{\"1\":{\"206\":1}}],[\"地址\",{\"1\":{\"273\":1}}],[\"地图的缩放比\",{\"1\":{\"102\":1}}],[\"地图\",{\"0\":{\"102\":1,\"111\":1},\"2\":{\"124\":1}}],[\"除零错误\",{\"1\":{\"302\":1}}],[\"除以零\",{\"1\":{\"300\":1}}],[\"除\",{\"1\":{\"273\":1}}],[\"除了通过传统的命令行进行操作之外\",{\"1\":{\"134\":1}}],[\"除了\",{\"1\":{\"48\":1}}],[\"引入了红黑树\",{\"1\":{\"399\":1}}],[\"引入依赖\",{\"0\":{\"138\":1}}],[\"引用对象\",{\"1\":{\"490\":1}}],[\"引用不能从构造函数中\",{\"0\":{\"490\":1}}],[\"引用的对象的成员域的写入\",{\"1\":{\"488\":1}}],[\"引用数据类型\",{\"0\":{\"479\":1},\"1\":{\"488\":1}}],[\"引用\",{\"1\":{\"378\":1}}],[\"引用传递\",{\"0\":{\"273\":1}}],[\"错误\",{\"1\":{\"267\":3,\"268\":1}}],[\"错解\",{\"1\":{\"44\":1}}],[\"依旧以上面计算圆面积的进行描述\",{\"1\":{\"433\":1}}],[\"依然使用独占锁的话\",{\"1\":{\"364\":1}}],[\"依然还是以非公平锁为例\",{\"1\":{\"359\":1}}],[\"依次类推\",{\"1\":{\"267\":1}}],[\"依赖于m\",{\"1\":{\"183\":2}}],[\"被\",{\"1\":{\"465\":1}}],[\"被唤醒的线程就会进行新一轮的夺锁之争\",{\"1\":{\"459\":1}}],[\"被唤醒\",{\"1\":{\"387\":1}}],[\"被唤醒啦\",{\"1\":{\"318\":1}}],[\"被所有类的对象共享\",{\"1\":{\"282\":1}}],[\"被调函数开始执行\",{\"1\":{\"266\":1}}],[\"被4整除即可\",{\"1\":{\"239\":1}}],[\"修饰\",{\"1\":{\"483\":2}}],[\"修饰时\",{\"1\":{\"483\":1}}],[\"修饰基本数据类型变量时\",{\"1\":{\"479\":1}}],[\"修饰的用来改变同步状态的方法\",{\"1\":{\"506\":1}}],[\"修饰的话就可以禁止\",{\"1\":{\"497\":1}}],[\"修饰的数据类型分类\",{\"1\":{\"488\":1}}],[\"修饰的对象的成员域读操作\",{\"1\":{\"488\":1}}],[\"修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序\",{\"1\":{\"488\":1}}],[\"修饰的对象的成员域的写入\",{\"1\":{\"488\":1}}],[\"修饰的对象的成员域写操作\",{\"1\":{\"488\":1}}],[\"修饰的\",{\"1\":{\"484\":1}}],[\"修饰的成员变量\",{\"1\":{\"484\":1}}],[\"修饰的方法需要由继承\",{\"1\":{\"507\":1}}],[\"修饰的方法是可以重载的\",{\"1\":{\"482\":1}}],[\"修饰的方法不能够被子类所重写\",{\"1\":{\"481\":1}}],[\"修饰的方法\",{\"1\":{\"481\":1,\"508\":1}}],[\"修饰的时候\",{\"1\":{\"481\":1}}],[\"修饰的引用数据类型变量\",{\"1\":{\"479\":1}}],[\"修饰的是一个基本数据类型的数据\",{\"1\":{\"479\":1}}],[\"修饰的是基本数据类型和引用类型有区别吗\",{\"1\":{\"478\":1}}],[\"修饰的共享变量进行写操作的时候会多出\",{\"1\":{\"466\":1}}],[\"修饰的变量\",{\"1\":{\"487\":1}}],[\"修饰的变量能够保证每个线程能够获取该变量的最新值\",{\"1\":{\"465\":1}}],[\"修饰的变量给\",{\"1\":{\"465\":1}}],[\"修饰方法实现的\",{\"1\":{\"407\":1}}],[\"修饰其他注解的注解\",{\"1\":{\"308\":1}}],[\"修饰符来修饰该类的成员变量\",{\"1\":{\"484\":1}}],[\"修饰符修饰\",{\"1\":{\"479\":1}}],[\"修饰符包括\",{\"1\":{\"265\":1}}],[\"修饰符\",{\"1\":{\"264\":1,\"282\":1}}],[\"修改它的属性和一些操作\",{\"1\":{\"395\":1}}],[\"修改语句的条件可以有\",{\"1\":{\"189\":1}}],[\"修改数据\",{\"1\":{\"187\":1}}],[\"修改数据类型\",{\"1\":{\"185\":1}}],[\"修改\",{\"0\":{\"185\":1,\"189\":1},\"1\":{\"185\":1}}],[\"修改表名\",{\"1\":{\"185\":1}}],[\"修改表的时候添加约束\",{\"1\":{\"182\":1}}],[\"修改表\",{\"1\":{\"179\":1}}],[\"修改安装路径\",{\"1\":{\"67\":1,\"70\":1}}],[\"修改缓存目录和全局目录\",{\"0\":{\"35\":1}}],[\"修改或删除的文件\",{\"1\":{\"26\":1}}],[\"理解函数\",{\"1\":{\"263\":1}}],[\"理想情况下\",{\"1\":{\"226\":1}}],[\"拼接字符串\",{\"1\":{\"262\":1,\"324\":1,\"325\":1}}],[\"速度较快\",{\"1\":{\"262\":1}}],[\"速度较慢\",{\"1\":{\"262\":1}}],[\"遇到回车才会停止\",{\"1\":{\"261\":1}}],[\"遇到空格不会停止输入\",{\"1\":{\"261\":1}}],[\"遇到空格\",{\"1\":{\"261\":1}}],[\"遇到含糊不清的地方\",{\"1\":{\"146\":1}}],[\"翻转字符串\",{\"1\":{\"260\":1}}],[\"翻页操作\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"翻页处理\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"去读取该对象时就会出错\",{\"1\":{\"490\":1}}],[\"去收银台付款\",{\"1\":{\"446\":1}}],[\"去深入了解下读写锁\",{\"1\":{\"364\":1}}],[\"去除首尾空白字符\",{\"1\":{\"324\":2}}],[\"去除重复记录\",{\"1\":{\"193\":1}}],[\"去除重复行\",{\"1\":{\"75\":1}}],[\"去掉首尾的空白字符\",{\"1\":{\"260\":1}}],[\"负责同步状态的管理\",{\"1\":{\"507\":1}}],[\"负数表示小于\",{\"1\":{\"260\":1}}],[\"负载因子\",{\"1\":{\"228\":1}}],[\"负载因子的调整\",{\"1\":{\"228\":1}}],[\"找不到文件\",{\"1\":{\"303\":1}}],[\"找不到相应的类\",{\"1\":{\"300\":1}}],[\"找不到返回\",{\"1\":{\"260\":1}}],[\"找到hash值相同的key\",{\"1\":{\"399\":1}}],[\"找到请求标头的\",{\"1\":{\"82\":1}}],[\"找到city\",{\"1\":{\"81\":1}}],[\"填充数组\",{\"1\":{\"257\":1}}],[\"含有这样两个成员变量\",{\"1\":{\"408\":1}}],[\"含有3个元素的数组\",{\"1\":{\"253\":2}}],[\"含最小\",{\"1\":{\"194\":1}}],[\"程序逻辑同独占锁可响应中断式获取基本一致\",{\"1\":{\"520\":1}}],[\"程序逻辑如图所示\",{\"1\":{\"520\":1}}],[\"程序逻辑通过注释已经标出\",{\"1\":{\"516\":1}}],[\"程序的逻辑主要分为两个部分\",{\"1\":{\"516\":1}}],[\"程序的执行结果不能被改变\",{\"1\":{\"430\":1}}],[\"程序主要是靠\",{\"1\":{\"504\":1}}],[\"程序天然的有序性可以总结为\",{\"1\":{\"497\":1}}],[\"程序天生就是一个多线程程序\",{\"1\":{\"413\":1}}],[\"程序顺序规则\",{\"1\":{\"433\":1}}],[\"程序员为了理解\",{\"1\":{\"436\":1}}],[\"程序员来说\",{\"1\":{\"436\":1}}],[\"程序员希望基于一个强内存模型来编写代码\",{\"1\":{\"435\":1}}],[\"程序员希望内存模型易于理解\",{\"1\":{\"435\":1}}],[\"程序员对内存模型的使用\",{\"1\":{\"435\":1}}],[\"程序员对于这两个操作是否真的被重排序并不关心\",{\"1\":{\"432\":1}}],[\"程序员关心的是程序执行时的语义不能被改变\",{\"1\":{\"432\":1}}],[\"程序从\",{\"1\":{\"413\":1}}],[\"程序自动退出\",{\"1\":{\"315\":1}}],[\"程序就不能编译通过\",{\"1\":{\"299\":1}}],[\"程序应该从逻辑角度尽可能避免这类异常的发生\",{\"1\":{\"299\":1}}],[\"程序中断规则\",{\"1\":{\"433\":1}}],[\"程序中\",{\"1\":{\"422\":1}}],[\"程序中可以选择捕获处理\",{\"1\":{\"299\":1}}],[\"程序中应当尽可能去处理这些异常\",{\"1\":{\"297\":1}}],[\"程序如下所示\",{\"1\":{\"265\":1}}],[\"程序\",{\"1\":{\"250\":1}}],[\"跳转语句\",{\"0\":{\"246\":1}}],[\"空形参列表\",{\"1\":{\"268\":1}}],[\"空语句表示true\",{\"1\":{\"245\":1}}],[\"空语句\",{\"1\":{\"245\":1}}],[\"空间效率\",{\"1\":{\"228\":1}}],[\"空间限制\",{\"1\":{\"46\":1}}],[\"唯一的不同在于获取锁失败后\",{\"1\":{\"520\":1}}],[\"唯一的不同在于增加了\",{\"1\":{\"360\":1}}],[\"唯一的区别是当\",{\"1\":{\"519\":1}}],[\"唯一的区别是\",{\"1\":{\"244\":1}}],[\"唯一约束\",{\"1\":{\"182\":1}}],[\"死循环中会继续重试\",{\"1\":{\"517\":1}}],[\"死循环中不断尝试\",{\"1\":{\"516\":1}}],[\"死循环\",{\"1\":{\"243\":1,\"423\":1,\"516\":1}}],[\"项\",{\"1\":{\"243\":1,\"245\":1,\"254\":1}}],[\"项目开发中\",{\"1\":{\"199\":1}}],[\"项目需要用到多语言么\",{\"1\":{\"22\":1}}],[\"项目的文件夹名称\",{\"1\":{\"22\":1}}],[\"项目初始化\",{\"0\":{\"22\":1}}],[\"项目配置\",{\"0\":{\"18\":1}}],[\"项目部署\",{\"0\":{\"25\":1},\"1\":{\"16\":1}}],[\"项目\",{\"1\":{\"15\":1,\"18\":1,\"21\":1,\"25\":1,\"61\":1}}],[\"求斐波那切数列第n项\",{\"1\":{\"278\":1}}],[\"求斐波那契数列的第\",{\"1\":{\"243\":1,\"245\":1}}],[\"求\",{\"1\":{\"243\":1,\"245\":1,\"248\":1}}],[\"求和\",{\"1\":{\"195\":1}}],[\"循环后就会调用\",{\"1\":{\"378\":1}}],[\"循环中的逻辑判断为\",{\"1\":{\"378\":1}}],[\"循环中\",{\"1\":{\"378\":1}}],[\"循环体中只有一条语句时\",{\"1\":{\"245\":1}}],[\"循环不常用\",{\"1\":{\"244\":1}}],[\"循环永久执行\",{\"1\":{\"243\":1}}],[\"循环\",{\"0\":{\"243\":1,\"244\":1,\"245\":1},\"1\":{\"378\":3,\"420\":1}}],[\"循环语句\",{\"0\":{\"242\":1}}],[\"代码抛出被中断异常\",{\"1\":{\"519\":1}}],[\"代码首先获取当前节点的先驱节点\",{\"1\":{\"516\":1}}],[\"代码如下\",{\"1\":{\"497\":1}}],[\"代码\",{\"1\":{\"466\":1}}],[\"代码中就是\",{\"1\":{\"494\":1}}],[\"代码中\",{\"1\":{\"442\":1}}],[\"代码块时\",{\"1\":{\"417\":1}}],[\"代码逻辑请看注释\",{\"1\":{\"401\":1}}],[\"代码为\",{\"1\":{\"399\":1}}],[\"代码的逻辑见注释\",{\"1\":{\"398\":1}}],[\"代码的逻辑请看注释\",{\"1\":{\"359\":1,\"369\":1,\"400\":1}}],[\"代码的主要逻辑请看注释\",{\"1\":{\"378\":1}}],[\"代码执行顺序\",{\"1\":{\"242\":1}}],[\"代替\",{\"1\":{\"306\":1,\"402\":1}}],[\"代表文件传入的参数个数\",{\"1\":{\"159\":1}}],[\"代表\",{\"1\":{\"22\":1,\"84\":1,\"399\":1}}],[\"思维是主要的\",{\"1\":{\"242\":1}}],[\"思考\",{\"1\":{\"221\":1}}],[\"​\",{\"1\":{\"240\":3}}],[\"闰年有两种情况\",{\"1\":{\"239\":1}}],[\"练习题3\",{\"1\":{\"254\":1}}],[\"练习题2\",{\"1\":{\"254\":1}}],[\"练习题1\",{\"1\":{\"254\":1}}],[\"练习\",{\"1\":{\"239\":4,\"240\":1,\"243\":2,\"245\":2,\"249\":1}}],[\"闫学灿\",{\"1\":{\"238\":1,\"242\":1,\"250\":1,\"258\":1,\"263\":1,\"279\":1,\"296\":1}}],[\"判断之间返回\",{\"1\":{\"520\":1}}],[\"判断相同的两个对象其\",{\"1\":{\"484\":1}}],[\"判断当前\",{\"1\":{\"399\":1}}],[\"判断当前线程能否获得锁为例\",{\"1\":{\"359\":1}}],[\"判断为\",{\"1\":{\"398\":1,\"520\":1}}],[\"判断该pair是否和对象元素e相等\",{\"1\":{\"337\":1}}],[\"判断队列是否为空\",{\"1\":{\"333\":1}}],[\"判断是否有其他线程进行了修改操作\",{\"1\":{\"403\":1}}],[\"判断是否超过了允许的最大值\",{\"1\":{\"397\":1}}],[\"判断是否为空白字符串\",{\"1\":{\"324\":1}}],[\"判断是否以某个后缀结尾\",{\"1\":{\"260\":1}}],[\"判断是否以某个前缀开头\",{\"1\":{\"260\":1}}],[\"判断字符串是否为空\",{\"1\":{\"324\":1}}],[\"判断两个字符串的字典序大小\",{\"1\":{\"260\":1}}],[\"判断两个字符串是否相等\",{\"1\":{\"260\":1}}],[\"判断一个大于\",{\"1\":{\"247\":1}}],[\"判断闰年\",{\"1\":{\"239\":1,\"240\":1}}],[\"判断语句\",{\"0\":{\"238\":1}}],[\"判断条件不同\",{\"1\":{\"196\":1}}],[\"效率较高\",{\"1\":{\"236\":1,\"237\":1}}],[\"效率较低\",{\"1\":{\"236\":1,\"237\":1}}],[\"读对象的普通域被重排序到了读对象引用的前面就会出现线程\",{\"1\":{\"487\":1}}],[\"读对象的引用和读该对象的\",{\"1\":{\"487\":1}}],[\"读对象引用\",{\"1\":{\"487\":1}}],[\"读final域\",{\"1\":{\"487\":1}}],[\"读普通域\",{\"1\":{\"487\":1}}],[\"读重排序\",{\"1\":{\"469\":2}}],[\"读\",{\"1\":{\"469\":1,\"487\":3,\"489\":2}}],[\"读操作是在后面插入两个内存屏障\",{\"1\":{\"469\":1}}],[\"读操作的后面插入一个\",{\"1\":{\"469\":2}}],[\"读这个\",{\"1\":{\"468\":1}}],[\"读后写\",{\"1\":{\"430\":1}}],[\"读到的是过期的数据\",{\"1\":{\"429\":1}}],[\"读锁释放\",{\"1\":{\"370\":1}}],[\"读锁释放的实现主要通过方法\",{\"1\":{\"370\":1}}],[\"读锁的释放\",{\"0\":{\"370\":1}}],[\"读锁的获取实现方法为\",{\"1\":{\"369\":1}}],[\"读锁的获取\",{\"0\":{\"369\":1}}],[\"读锁获取失败\",{\"1\":{\"369\":1}}],[\"读锁获取后能再次获取\",{\"1\":{\"364\":1}}],[\"读锁不是独占式锁\",{\"1\":{\"369\":1}}],[\"读锁详解\",{\"0\":{\"368\":1}}],[\"读锁是怎样获取和释放的\",{\"1\":{\"364\":1}}],[\"读写所允许同一时刻被多个读线程访问\",{\"1\":{\"364\":1}}],[\"读写锁支持锁降级\",{\"1\":{\"371\":1}}],[\"读写锁是怎样实现分别记录读锁和写锁的状态的\",{\"1\":{\"366\":1}}],[\"读写锁是怎样实现分别记录读写状态的\",{\"1\":{\"364\":1}}],[\"读写锁\",{\"1\":{\"364\":1}}],[\"读写锁介绍\",{\"0\":{\"364\":1}}],[\"读入下一行\",{\"1\":{\"236\":1}}],[\"读入下一个双精度浮点数\",{\"1\":{\"236\":1}}],[\"读入下一个单精度浮点数\",{\"1\":{\"236\":1}}],[\"读入下一个整数\",{\"1\":{\"236\":1}}],[\"读入下一个字符串\",{\"1\":{\"236\":1}}],[\"读取\",{\"1\":{\"494\":2}}],[\"读取变量\",{\"1\":{\"494\":2}}],[\"读取同一个\",{\"1\":{\"468\":1}}],[\"读取和写入字符\",{\"1\":{\"262\":1}}],[\"读取整个数组\",{\"0\":{\"163\":1}}],[\"读取数组中某个元素的值\",{\"0\":{\"162\":1}}],[\"读取对应excel\",{\"1\":{\"118\":1}}],[\"读取两个\",{\"1\":{\"75\":1}}],[\"方法逻辑几乎一致\",{\"1\":{\"519\":1}}],[\"方法源码\",{\"1\":{\"518\":1}}],[\"方法源码为\",{\"1\":{\"378\":1,\"379\":1,\"391\":1,\"400\":1,\"517\":1}}],[\"方法主要逻辑是使用\",{\"1\":{\"517\":1}}],[\"方法主要包含了三个操作\",{\"1\":{\"487\":1}}],[\"方法设置为队列的头结点\",{\"1\":{\"517\":1}}],[\"方法可能承担两个任务\",{\"1\":{\"516\":1}}],[\"方法可以做这样的总结\",{\"1\":{\"516\":1}}],[\"方法可以看做是线程间协作的一种方式\",{\"1\":{\"420\":1}}],[\"方法可以将等待队列中等待时间最长的节点移动到同步队列中\",{\"1\":{\"379\":1}}],[\"方法再调用\",{\"1\":{\"515\":1}}],[\"方法再来看\",{\"1\":{\"400\":1}}],[\"方法实际上会调用\",{\"1\":{\"515\":1}}],[\"方法实现超时等待的效果\",{\"1\":{\"520\":1}}],[\"方法实现自己的同步语义\",{\"1\":{\"508\":1}}],[\"方法实现\",{\"1\":{\"378\":1}}],[\"方法实现的\",{\"1\":{\"366\":1,\"369\":1}}],[\"方法基础上增加了能响应中断的功能\",{\"1\":{\"512\":1}}],[\"方法基本一致\",{\"1\":{\"378\":1}}],[\"方法相同\",{\"1\":{\"512\":1}}],[\"方法相较于无参的\",{\"1\":{\"386\":1}}],[\"方法另一个线程执行\",{\"1\":{\"490\":1}}],[\"方法定义参数和异常处理器参数不会在线程间共享\",{\"1\":{\"428\":1}}],[\"方法在休眠时间达到后如果再次获得\",{\"1\":{\"421\":1}}],[\"方法只允许与当前线程具有相同优先级的线程能够获得释放出来的\",{\"1\":{\"422\":1}}],[\"方法只是会让出cpu并不会释放掉对象锁\",{\"1\":{\"421\":1}}],[\"方法只会在同一个线程中执行这个任务\",{\"1\":{\"413\":1}}],[\"方法只会对等待队列的头节点进行操作\",{\"1\":{\"379\":1}}],[\"方法会利用\",{\"1\":{\"516\":1}}],[\"方法会释放占有的对象锁\",{\"1\":{\"421\":1}}],[\"方法会增加\",{\"1\":{\"386\":1}}],[\"方法没有这个限制可以在任何地方种使用\",{\"1\":{\"421\":1}}],[\"方法必须等待\",{\"1\":{\"421\":1}}],[\"方法必须要在同步方法或者同步块中调用\",{\"1\":{\"421\":1}}],[\"方法必须是已经获得了\",{\"1\":{\"378\":1}}],[\"方法经常拿来与\",{\"1\":{\"421\":1}}],[\"方法并不会失去锁\",{\"1\":{\"421\":1}}],[\"方法并且当前线程获取\",{\"1\":{\"375\":1}}],[\"方法通知所有的等待线程\",{\"1\":{\"420\":1}}],[\"方法外\",{\"1\":{\"420\":1}}],[\"方法一共提供如下这些方法\",{\"1\":{\"420\":1}}],[\"方法线程会进入到\",{\"1\":{\"417\":1}}],[\"方法开始运行\",{\"1\":{\"417\":1}}],[\"方法开始执行\",{\"1\":{\"413\":1}}],[\"方法正常退出\",{\"1\":{\"416\":1}}],[\"方法或者\",{\"1\":{\"417\":1}}],[\"方法或者像被阻塞或等待时才失去控制权\",{\"1\":{\"414\":1}}],[\"方法或者当前线程被中断\",{\"1\":{\"386\":1}}],[\"方法结尾处调用了\",{\"1\":{\"402\":1}}],[\"方法类似\",{\"1\":{\"402\":1}}],[\"方法获得\",{\"1\":{\"401\":1}}],[\"方法获取该位置上的元素\",{\"1\":{\"399\":1}}],[\"方法获取锁成功后调用了\",{\"1\":{\"380\":2}}],[\"方法对其进行中断操作\",{\"1\":{\"419\":1}}],[\"方法对\",{\"1\":{\"399\":1}}],[\"方法整体流程\",{\"1\":{\"399\":1}}],[\"方法判断为\",{\"1\":{\"399\":1}}],[\"方法完成向红黑树插入新节点\",{\"1\":{\"399\":1}}],[\"方法为\",{\"1\":{\"399\":1,\"517\":1}}],[\"方法进行修改同步状态\",{\"1\":{\"507\":1}}],[\"方法进行设置\",{\"1\":{\"422\":1}}],[\"方法进行比价\",{\"1\":{\"421\":1}}],[\"方法进行了一次重\",{\"1\":{\"399\":1}}],[\"方法进入等待队列\",{\"1\":{\"380\":1}}],[\"方法是获取独占式锁\",{\"1\":{\"515\":1}}],[\"方法是可以被重载的\",{\"1\":{\"482\":1}}],[\"方法是不能够被子类重写的\",{\"1\":{\"482\":1}}],[\"方法是\",{\"1\":{\"421\":1}}],[\"方法是怎样实现的\",{\"1\":{\"399\":1}}],[\"方法是将头节点移动到同步队列中\",{\"1\":{\"379\":1}}],[\"方法是将同步状态\",{\"1\":{\"366\":1}}],[\"方法了吧\",{\"1\":{\"399\":1}}],[\"方法将新值插入即可\",{\"1\":{\"399\":1}}],[\"方法将\",{\"1\":{\"398\":1,\"399\":1,\"407\":1}}],[\"方法唤醒后继节点\",{\"1\":{\"518\":1}}],[\"方法唤醒\",{\"1\":{\"387\":1}}],[\"方法阻塞线程会致使线程进入到\",{\"1\":{\"386\":1}}],[\"方法使得线程阻塞\",{\"1\":{\"518\":1}}],[\"方法使得当前线程阻塞\",{\"1\":{\"517\":1}}],[\"方法使得当前线程进入等待状态\",{\"1\":{\"378\":1}}],[\"方法使线程转换到\",{\"1\":{\"417\":1}}],[\"方法使该线程进入等待状态同时释放锁\",{\"1\":{\"381\":1}}],[\"方法就不是被\",{\"1\":{\"481\":1}}],[\"方法就是\",{\"1\":{\"481\":1}}],[\"方法就很容易了\",{\"1\":{\"400\":1}}],[\"方法就像一个开关控制着线程\",{\"1\":{\"380\":1}}],[\"方法就可以实现这种机制\",{\"1\":{\"380\":1}}],[\"方法上\",{\"1\":{\"379\":1}}],[\"方法中\",{\"1\":{\"517\":1}}],[\"方法中是一个\",{\"1\":{\"423\":1}}],[\"方法中退出执行后续操作\",{\"1\":{\"380\":1}}],[\"方法中返回\",{\"1\":{\"379\":1,\"386\":1}}],[\"方法中的\",{\"1\":{\"379\":1}}],[\"方法做了些什么事情\",{\"1\":{\"379\":1}}],[\"方法也是基于该节点\",{\"1\":{\"379\":1}}],[\"方法也相同\",{\"1\":{\"330\":1}}],[\"方法首先会检测当前线程是否已经获取\",{\"1\":{\"379\":1}}],[\"方法抛被中断的异常\",{\"1\":{\"378\":1}}],[\"方法抛出\",{\"1\":{\"300\":1}}],[\"方法如出一辙\",{\"1\":{\"378\":1}}],[\"方法示意图如下图\",{\"1\":{\"378\":1}}],[\"方法当前节点移动到了同步队列后\",{\"1\":{\"378\":1}}],[\"方法第一个前提条件自然而然的是要先退出这个\",{\"1\":{\"378\":1}}],[\"方法时出现报错\",{\"1\":{\"481\":1}}],[\"方法时实际具体实现是\",{\"1\":{\"399\":1}}],[\"方法时\",{\"1\":{\"378\":1}}],[\"方法有这样一段逻辑\",{\"1\":{\"378\":1}}],[\"方法释放锁\",{\"1\":{\"504\":1}}],[\"方法释放锁将当前线程加入到等待队列中\",{\"1\":{\"377\":1}}],[\"方法释放\",{\"1\":{\"378\":1}}],[\"方法退出\",{\"1\":{\"378\":2}}],[\"方法后\",{\"1\":{\"378\":1}}],[\"方法后会使得当前获取\",{\"1\":{\"378\":1}}],[\"方法后线程依次尾插入到等待队列中\",{\"1\":{\"377\":1}}],[\"方法创建多个\",{\"1\":{\"377\":1}}],[\"方法创建一个类的实例\",{\"1\":{\"300\":1}}],[\"方法的执行流程如下图所示\",{\"1\":{\"517\":1}}],[\"方法的开始\",{\"1\":{\"433\":1}}],[\"方法的调用先行于被中断线程的代码检测到中断时间的发生\",{\"1\":{\"433\":1}}],[\"方法的使用\",{\"1\":{\"420\":1}}],[\"方法的时候像\",{\"1\":{\"402\":1}}],[\"方法的逻辑就基本说的差不多了\",{\"1\":{\"399\":1}}],[\"方法的代码量有点长\",{\"1\":{\"399\":1}}],[\"方法的功能实现则是靠\",{\"1\":{\"386\":1}}],[\"方法的每一个线程\",{\"1\":{\"379\":1}}],[\"方法的区别体现在\",{\"1\":{\"379\":1}}],[\"方法的线程\",{\"1\":{\"413\":1}}],[\"方法的线程成功退出\",{\"1\":{\"379\":1}}],[\"方法的线程必须是已经获得了\",{\"1\":{\"378\":1}}],[\"方法的线程会加入到等待队列中\",{\"1\":{\"377\":1}}],[\"方法的理解加深\",{\"1\":{\"378\":1}}],[\"方法的前提条件\",{\"1\":{\"378\":1}}],[\"方法的注释为独占式锁获取的次数即写锁被获取的次数\",{\"1\":{\"366\":1}}],[\"方法返回的话一定是该线程获取了与\",{\"1\":{\"378\":1}}],[\"方法返回\",{\"1\":{\"375\":1,\"378\":1,\"517\":1}}],[\"方法返回null时\",{\"1\":{\"331\":1}}],[\"方法和类\",{\"1\":{\"474\":1}}],[\"方法和\",{\"1\":{\"369\":1,\"385\":1,\"517\":1}}],[\"方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断\",{\"1\":{\"360\":1}}],[\"方法来表达自己的同步语义\",{\"1\":{\"359\":1}}],[\"方法来拼接\",{\"1\":{\"323\":1}}],[\"方法\",{\"0\":{\"398\":1,\"399\":1,\"400\":1,\"401\":1,\"480\":1},\"1\":{\"301\":1,\"306\":1,\"360\":1,\"366\":1,\"367\":1,\"369\":2,\"375\":3,\"378\":2,\"379\":1,\"380\":1,\"385\":2,\"386\":3,\"399\":1,\"402\":4,\"412\":1,\"413\":4,\"414\":1,\"416\":1,\"422\":1,\"423\":1,\"467\":2,\"468\":2,\"481\":1,\"484\":3,\"487\":3,\"488\":3,\"490\":1,\"507\":2,\"515\":3,\"516\":4,\"517\":3,\"518\":2,\"519\":2,\"522\":2,\"523\":1}}],[\"方法克隆对象\",{\"1\":{\"300\":1}}],[\"方式达到超时等待获取锁的效果\",{\"1\":{\"520\":1}}],[\"方式只能支持一个\",{\"1\":{\"375\":1}}],[\"方式不支持\",{\"1\":{\"375\":1}}],[\"方式2\",{\"1\":{\"236\":1,\"237\":1}}],[\"方式1\",{\"1\":{\"236\":1,\"237\":1}}],[\"方便进行问题排查\",{\"1\":{\"386\":3}}],[\"方便进行业务拆分\",{\"1\":{\"346\":1}}],[\"方便复用\",{\"1\":{\"146\":1}}],[\"方便使用和管理数据\",{\"1\":{\"133\":1}}],[\"方便地逐一卡掉错解\",{\"1\":{\"44\":1}}],[\"浮点数\",{\"1\":{\"235\":1}}],[\"整体示意图为下图\",{\"1\":{\"516\":1}}],[\"整体来看这是一个这又是一个自旋的过程\",{\"1\":{\"516\":1}}],[\"整体设计思路采用模板方法设计模式\",{\"1\":{\"508\":1}}],[\"整个过程即为\",{\"1\":{\"445\":1}}],[\"整个扩容操作分为两个部分\",{\"1\":{\"401\":1}}],[\"整个堆并不是有序的\",{\"1\":{\"333\":1}}],[\"整理如下\",{\"1\":{\"512\":1}}],[\"整理\",{\"1\":{\"321\":1}}],[\"整型变量的自增\",{\"1\":{\"235\":1}}],[\"整数的加减乘除四则运算\",{\"1\":{\"235\":1}}],[\"整合\",{\"0\":{\"137\":1}}],[\"取模\",{\"1\":{\"399\":1}}],[\"取模运算符\",{\"1\":{\"234\":1}}],[\"取队首元素但不删除\",{\"1\":{\"331\":1}}],[\"取队首元素并删除\",{\"1\":{\"331\":1}}],[\"取消注释行\",{\"1\":{\"71\":1}}],[\"才会离开等待池\",{\"1\":{\"421\":1}}],[\"才会继续执行\",{\"1\":{\"420\":1}}],[\"才能够确保队列元素整体有序\",{\"1\":{\"333\":1}}],[\"才可以使用\",{\"1\":{\"233\":1}}],[\"才有该选项\",{\"1\":{\"50\":1}}],[\"然而\",{\"1\":{\"228\":1}}],[\"然后根据\",{\"1\":{\"520\":1}}],[\"然后根据哈希值快速定位到元素在表中的位置\",{\"1\":{\"226\":1}}],[\"然后根据哈希值将元素存储在表中适当的位置\",{\"1\":{\"226\":1}}],[\"然后会在\",{\"1\":{\"517\":1}}],[\"然后插入同步队列的过程了\",{\"1\":{\"516\":1}}],[\"然后线程\",{\"1\":{\"467\":1,\"468\":1,\"488\":1}}],[\"然后线程尝试使用\",{\"1\":{\"458\":1}}],[\"然后执行引擎会基于工作内存中的数据进行操作处理\",{\"1\":{\"465\":1}}],[\"然后执行该脚本\",{\"1\":{\"158\":1}}],[\"然后检查持有偏向锁的线程是否活着\",{\"1\":{\"455\":1}}],[\"然后\",{\"1\":{\"446\":1,\"481\":1}}],[\"然后去纸币付款收银员找零\",{\"1\":{\"446\":1}}],[\"然后将之前的头结点的\",{\"1\":{\"517\":1}}],[\"然后将这个对象做\",{\"1\":{\"451\":1}}],[\"然后将该值拷贝到线程\",{\"1\":{\"445\":1}}],[\"然后将用户变量默认的\",{\"1\":{\"34\":1}}],[\"然后用\",{\"1\":{\"443\":1}}],[\"然后又传给下一个线程\",{\"1\":{\"420\":1}}],[\"然后分别对着两个线程进行中断操作\",{\"1\":{\"419\":1}}],[\"然后按照既定的代码逻辑执行\",{\"1\":{\"413\":1}}],[\"然后两者相减为\",{\"1\":{\"401\":1}}],[\"然后利用\",{\"1\":{\"401\":1}}],[\"然后乘以加载因子\",{\"1\":{\"398\":1}}],[\"然后通过\",{\"1\":{\"378\":1}}],[\"然后加入到等待队列中\",{\"1\":{\"378\":1}}],[\"然后调用\",{\"1\":{\"377\":1,\"517\":1}}],[\"然后在调用\",{\"1\":{\"515\":1}}],[\"然后在2004年秋季\",{\"1\":{\"346\":1}}],[\"然后在题面中加上\",{\"1\":{\"47\":1}}],[\"然后查看字符串池中是否存在\",{\"1\":{\"324\":1}}],[\"然后对地址中的值修改\",{\"1\":{\"273\":1}}],[\"然后从该位置移除元素\",{\"1\":{\"226\":1}}],[\"然后可以对分类完的数据进行合并计算\",{\"1\":{\"196\":1}}],[\"然后返回一个结果值\",{\"1\":{\"195\":1}}],[\"然后回车\",{\"1\":{\"169\":1}}],[\"然后再变成\",{\"1\":{\"451\":1}}],[\"然后再使用如下指令\",{\"1\":{\"169\":1}}],[\"然后再在\",{\"1\":{\"403\":1}}],[\"然后再在系统变量的path中添加\",{\"1\":{\"34\":1}}],[\"然后再在安装路径的根目录下新建两个文件夹\",{\"0\":{\"33\":1}}],[\"然后运行对拍\",{\"1\":{\"53\":1}}],[\"然后点击\",{\"1\":{\"45\":1,\"49\":1}}],[\"适用于需要快速查找\",{\"1\":{\"228\":1}}],[\"适合存放任意类型的文件\",{\"1\":{\"133\":1}}],[\"冲突的概率\",{\"1\":{\"399\":1}}],[\"冲突\",{\"1\":{\"399\":1}}],[\"冲突解决策略以及负载因子的调整等问题\",{\"1\":{\"228\":1}}],[\"冲突可能导致性能下降\",{\"1\":{\"228\":1}}],[\"冲突问题\",{\"1\":{\"228\":1}}],[\"灵活的键类型\",{\"1\":{\"227\":1}}],[\"键\",{\"1\":{\"329\":1}}],[\"键值对以\",{\"1\":{\"329\":1}}],[\"键值对乱序\",{\"1\":{\"329\":1}}],[\"键值对存储\",{\"1\":{\"227\":1}}],[\"键盘win+r进入cmd\",{\"1\":{\"34\":1}}],[\"假设一个线程\",{\"1\":{\"490\":1}}],[\"假设线程\",{\"1\":{\"468\":1,\"487\":2}}],[\"假设每一次操作都不会产生冲突\",{\"1\":{\"393\":1}}],[\"假设\",{\"1\":{\"221\":1}}],[\"假设根据职位\",{\"1\":{\"75\":1}}],[\"组成\",{\"1\":{\"221\":1}}],[\"组成的\",{\"1\":{\"221\":1}}],[\"节点出队即该节点引用的线程获得锁\",{\"1\":{\"518\":1}}],[\"节点如何进行入队和出队是怎样做的呢\",{\"1\":{\"513\":1}}],[\"节点从同步队列中取消\",{\"1\":{\"513\":1}}],[\"节点的等待状态等信息\",{\"1\":{\"513\":1}}],[\"节点的数据结构\",{\"1\":{\"513\":1}}],[\"节点的数据结构是什么样的\",{\"1\":{\"513\":1}}],[\"节点的状态有\",{\"1\":{\"513\":1}}],[\"节点状态\",{\"1\":{\"513\":1}}],[\"节点主要包含了两个域\",{\"1\":{\"408\":1}}],[\"节点\",{\"1\":{\"394\":1,\"401\":3}}],[\"节点大小\",{\"1\":{\"221\":1}}],[\"节点分为\",{\"1\":{\"221\":1}}],[\"占用了\",{\"1\":{\"349\":2}}],[\"占\",{\"1\":{\"221\":1}}],[\"占位符\",{\"1\":{\"194\":1}}],[\"拓展\",{\"1\":{\"221\":1}}],[\"便于数据的排序及区间范围查询\",{\"1\":{\"221\":1}}],[\"叶子节点是一个双向链表\",{\"1\":{\"221\":1}}],[\"叶子节点形成了一个双向链表\",{\"1\":{\"221\":1}}],[\"叶子节点\",{\"1\":{\"221\":2}}],[\"检测是否进行扩容\",{\"1\":{\"402\":1}}],[\"检查占有线程是否是当前线程\",{\"1\":{\"359\":1}}],[\"检查型异常必须被捕获或者抛出\",{\"1\":{\"303\":1}}],[\"检查性异常\",{\"1\":{\"300\":1}}],[\"检查是否存在\",{\"1\":{\"86\":1,\"93\":1}}],[\"检索元素时\",{\"1\":{\"226\":1}}],[\"检索速度就会降低\",{\"1\":{\"221\":1}}],[\"答案\",{\"1\":{\"221\":1}}],[\"答案是可以添加内存屏障\",{\"1\":{\"469\":1}}],[\"答案是不必的\",{\"1\":{\"443\":1}}],[\"答案是\",{\"1\":{\"139\":1}}],[\"红色的是根据\",{\"1\":{\"467\":1}}],[\"红色的为监视器锁规则推导而出\",{\"1\":{\"444\":1}}],[\"红黑树也是一棵平衡的二叉树\",{\"1\":{\"221\":1}}],[\"红河哈尼族彝族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"退出的时候\",{\"1\":{\"443\":1}}],[\"退出时会调用\",{\"1\":{\"420\":1}}],[\"退出\",{\"1\":{\"378\":2,\"423\":1}}],[\"退出即可\",{\"1\":{\"67\":1}}],[\"退化的二叉查找树\",{\"1\":{\"221\":1}}],[\"二元组\",{\"1\":{\"337\":1}}],[\"二是将控制权转移给被调用函数\",{\"1\":{\"266\":1}}],[\"二者之间可以相互转化\",{\"1\":{\"259\":1}}],[\"二\",{\"0\":{\"238\":1}}],[\"二次探测和双重散列\",{\"1\":{\"226\":1}}],[\"二叉查找树\",{\"1\":{\"221\":3}}],[\"二进制形式的极大文本数据\",{\"1\":{\"183\":1}}],[\"二进制形式的中等长度文本数据\",{\"1\":{\"183\":1}}],[\"二进制形式的长文本数据\",{\"1\":{\"183\":1}}],[\"降低性能开销\",{\"1\":{\"360\":1}}],[\"降低\",{\"1\":{\"220\":1}}],[\"降低数据排序的成本\",{\"1\":{\"220\":1}}],[\"降低数据库的\",{\"1\":{\"220\":1}}],[\"降序\",{\"1\":{\"197\":1,\"333\":1}}],[\"隔离性\",{\"1\":{\"218\":2}}],[\"撤销\",{\"1\":{\"218\":1}}],[\"失败的线程会重新尝试\",{\"1\":{\"449\":1}}],[\"失败会直接进入到同步队列\",{\"1\":{\"380\":1}}],[\"失败或者已经获取读锁的线程再次获取读锁时\",{\"1\":{\"369\":1}}],[\"失败抛出异常\",{\"1\":{\"331\":3}}],[\"失败\",{\"1\":{\"217\":1,\"515\":1}}],[\"成员变量来表示同步状态以及通过一个\",{\"1\":{\"506\":1}}],[\"成员变量等\",{\"1\":{\"309\":1}}],[\"成员变量\",{\"0\":{\"477\":1},\"1\":{\"282\":2}}],[\"成本\",{\"1\":{\"220\":1}}],[\"成功则线程执行\",{\"1\":{\"515\":1}}],[\"成功释放同步状态\",{\"1\":{\"378\":1}}],[\"成功返回队首元素\",{\"1\":{\"331\":2}}],[\"成功返回true\",{\"1\":{\"331\":1}}],[\"成功\",{\"1\":{\"217\":1,\"515\":1}}],[\"成都\",{\"1\":{\"76\":1,\"77\":1}}],[\"回车等空白字符时停止输入\",{\"1\":{\"261\":1}}],[\"回车也是一个字符\",{\"1\":{\"237\":1}}],[\"回车之后\",{\"1\":{\"169\":1}}],[\"回滚事务\",{\"1\":{\"217\":2}}],[\"再需要读取从主内存中去读取该变量的最新值\",{\"1\":{\"468\":1}}],[\"再执行计算操作就会有问题\",{\"1\":{\"466\":1}}],[\"再执行删除\",{\"1\":{\"178\":1}}],[\"再将该值刷新到主内存\",{\"1\":{\"445\":1}}],[\"再如\",{\"1\":{\"435\":1}}],[\"再进行重试\",{\"1\":{\"393\":1}}],[\"再看代码出现第\",{\"1\":{\"378\":1}}],[\"再才有做后面的逻辑判断的必要性\",{\"1\":{\"360\":1}}],[\"再次获取\",{\"1\":{\"359\":1}}],[\"再写\",{\"1\":{\"281\":1}}],[\"再输入\",{\"1\":{\"254\":1}}],[\"再提交\",{\"1\":{\"217\":1}}],[\"先进先出\",{\"1\":{\"518\":1}}],[\"先看源码\",{\"1\":{\"518\":1}}],[\"先看同步状态是否获取成功\",{\"1\":{\"515\":1}}],[\"先看看哪些是原子操作\",{\"1\":{\"494\":1}}],[\"先看一段示例代码\",{\"1\":{\"487\":1}}],[\"先看一个现象\",{\"1\":{\"441\":1}}],[\"先定义一个父类\",{\"1\":{\"481\":1}}],[\"先执行了\",{\"1\":{\"490\":1}}],[\"先执行\",{\"1\":{\"467\":1,\"468\":1}}],[\"先来看两个核心之一\",{\"1\":{\"467\":1}}],[\"先对共享变量\",{\"1\":{\"444\":1}}],[\"先天具有重入性\",{\"1\":{\"443\":1}}],[\"先行于发生它的\",{\"1\":{\"433\":1}}],[\"先将节点状态设置成\",{\"1\":{\"517\":1}}],[\"先将\",{\"1\":{\"399\":1}}],[\"先通过\",{\"1\":{\"380\":1}}],[\"先检测当前线程是否已经获取lock\",{\"1\":{\"379\":1}}],[\"先写\",{\"1\":{\"281\":1}}],[\"先减1后取值\",{\"1\":{\"234\":1}}],[\"先取值后减1\",{\"1\":{\"234\":1}}],[\"先取值后加1\",{\"1\":{\"234\":1}}],[\"先加1后取值\",{\"1\":{\"234\":1}}],[\"先开启\",{\"1\":{\"217\":1}}],[\"先注册登陆\",{\"1\":{\"45\":1}}],[\"手动提交事务使用步骤\",{\"1\":{\"217\":1}}],[\"手动提交事务\",{\"1\":{\"217\":1}}],[\"手机号\",{\"1\":{\"183\":1,\"201\":1}}],[\"简称同步器\",{\"1\":{\"505\":1}}],[\"简单来讲\",{\"1\":{\"220\":1}}],[\"简而言之\",{\"1\":{\"216\":1}}],[\"简介\",{\"0\":{\"170\":1,\"375\":1,\"385\":1,\"391\":1,\"407\":1,\"441\":1,\"465\":1,\"474\":1,\"504\":1,\"512\":1}}],[\"行子查询\",{\"0\":{\"213\":1},\"1\":{\"210\":1}}],[\"显而易见对线程\",{\"1\":{\"497\":1}}],[\"显示转化\",{\"1\":{\"233\":1}}],[\"显示具体数据\",{\"1\":{\"102\":1,\"103\":1,\"112\":1}}],[\"显式内连接语法\",{\"1\":{\"207\":1}}],[\"显式内连接\",{\"1\":{\"207\":1}}],[\"子类被推荐定义为自定义同步组件的静态内部类\",{\"1\":{\"506\":1}}],[\"子类继承往往可以重写父类的方法和改变父类属性\",{\"1\":{\"483\":1}}],[\"子类不能重写父类的该方法\",{\"1\":{\"481\":1}}],[\"子类会继承父类的注解\",{\"1\":{\"308\":1}}],[\"子查询返回的结果是多行多列\",{\"1\":{\"214\":1}}],[\"子查询返回的结果是一行\",{\"1\":{\"213\":1}}],[\"子查询返回的结果是一列\",{\"1\":{\"212\":1}}],[\"子查询返回的结果是单个值\",{\"1\":{\"211\":1}}],[\"子查询可以书写的位置\",{\"1\":{\"210\":1}}],[\"子查询结果为多行多列\",{\"1\":{\"210\":1}}],[\"子查询结果为一行\",{\"1\":{\"210\":1}}],[\"子查询结果为一列\",{\"1\":{\"210\":1}}],[\"子查询结果为单个值\",{\"1\":{\"210\":1}}],[\"子查询外部的语句可以是\",{\"1\":{\"210\":1}}],[\"子查询\",{\"0\":{\"209\":1},\"1\":{\"206\":1}}],[\"子进程可以访问的变量\",{\"1\":{\"155\":1}}],[\"子进程不能访问的变量\",{\"1\":{\"155\":1}}],[\"右移一位相当于\",{\"1\":{\"401\":1}}],[\"右移一位表示\",{\"1\":{\"401\":1}}],[\"右移\",{\"1\":{\"366\":1}}],[\"右边的子节点比父节点大\",{\"1\":{\"221\":1}}],[\"右边距设置为\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"右表\",{\"1\":{\"208\":1}}],[\"右外连接相当于查询表2\",{\"1\":{\"208\":1}}],[\"右外连接语法结构\",{\"1\":{\"208\":1}}],[\"右外连接\",{\"1\":{\"206\":1,\"208\":1}}],[\"左移\",{\"1\":{\"366\":1}}],[\"左右\",{\"1\":{\"221\":1}}],[\"左边的子节点比父节点小\",{\"1\":{\"221\":1}}],[\"左边距设置为\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"左表\",{\"1\":{\"208\":1}}],[\"左外连接和右外连接是可以相互替换的\",{\"1\":{\"208\":1}}],[\"左外连接相当于查询表1\",{\"1\":{\"208\":1}}],[\"左外连接语法结构\",{\"1\":{\"208\":1}}],[\"左外连接\",{\"1\":{\"206\":1,\"208\":1}}],[\"两条原子操作\",{\"1\":{\"494\":1}}],[\"两行不存在数据依赖性可能会进行重排序\",{\"1\":{\"430\":1}}],[\"两者主要的区别\",{\"1\":{\"421\":1}}],[\"两者除了在使用方式上不同外\",{\"1\":{\"375\":1}}],[\"两个核心\",{\"1\":{\"467\":2}}],[\"两个操作重排序\",{\"1\":{\"433\":1}}],[\"两个操作的执行顺序对最终结果都不会产生影响\",{\"1\":{\"433\":1}}],[\"两个操作之间存在\",{\"1\":{\"432\":1}}],[\"两个方法都没有直接返回\",{\"1\":{\"402\":1}}],[\"两个实现类\",{\"1\":{\"327\":1,\"329\":1}}],[\"两个集合\",{\"1\":{\"205\":1}}],[\"两种写法均可\",{\"1\":{\"153\":1}}],[\"笛卡尔乘积是指在数学中\",{\"1\":{\"205\":1}}],[\"笛卡尔积\",{\"1\":{\"205\":1}}],[\"实际大小\",{\"1\":{\"399\":2}}],[\"实际大小n\",{\"1\":{\"398\":1}}],[\"实际的\",{\"1\":{\"394\":1}}],[\"实际上这对应着锁的获取和释放两个操作\",{\"1\":{\"513\":1}}],[\"实际上通过头尾指针来管理同步队列\",{\"1\":{\"513\":1}}],[\"实际上都是调用了其静态内存类\",{\"1\":{\"505\":1}}],[\"实际上包含了三个操作\",{\"1\":{\"494\":1}}],[\"实际上就像是给\",{\"1\":{\"468\":1}}],[\"实际上保存的是hashmap中的元素个数\",{\"1\":{\"402\":1}}],[\"实际上\",{\"1\":{\"352\":1,\"386\":1,\"391\":2,\"397\":1,\"413\":1,\"430\":1,\"487\":1}}],[\"实际上是\",{\"1\":{\"323\":1}}],[\"实现超时等待的效果\",{\"1\":{\"520\":1}}],[\"实现同步组件时推荐定义继承\",{\"1\":{\"508\":1}}],[\"实现中会有\",{\"1\":{\"450\":1}}],[\"实现类有很多\",{\"1\":{\"450\":1}}],[\"实现类是\",{\"1\":{\"331\":1}}],[\"实现callable接口\",{\"1\":{\"413\":1}}],[\"实现runable接口\",{\"1\":{\"413\":2}}],[\"实现依然是采用\",{\"1\":{\"391\":1}}],[\"实现原理为\",{\"1\":{\"445\":1}}],[\"实现原理\",{\"0\":{\"378\":1,\"379\":1,\"442\":1,\"466\":1}}],[\"实现原理分析\",{\"0\":{\"376\":1}}],[\"实现共享式同步组件的同步语义需要通过重写\",{\"1\":{\"369\":1}}],[\"实现对\",{\"1\":{\"337\":1}}],[\"实现的\",{\"1\":{\"327\":1}}],[\"实现多线程\",{\"0\":{\"314\":1}}],[\"实现\",{\"1\":{\"291\":1,\"293\":1,\"294\":1,\"295\":1,\"314\":1,\"413\":2,\"450\":1}}],[\"实现关系\",{\"1\":{\"202\":1}}],[\"实参数量过多\",{\"1\":{\"267\":1}}],[\"实参数量不足\",{\"1\":{\"267\":1}}],[\"实参类型不正确\",{\"1\":{\"267\":1}}],[\"实参是形参的初始值\",{\"1\":{\"267\":1}}],[\"实例变量\",{\"1\":{\"477\":1}}],[\"实例方法\",{\"1\":{\"421\":1}}],[\"实例的方法\",{\"1\":{\"409\":1}}],[\"实例构造器方法\",{\"0\":{\"397\":1}}],[\"实例化\",{\"1\":{\"328\":1,\"329\":1,\"331\":1,\"332\":1}}],[\"实例\",{\"1\":{\"234\":1,\"280\":1}}],[\"实体类\",{\"1\":{\"139\":1}}],[\"结束后即\",{\"1\":{\"420\":1}}],[\"结束时间\",{\"1\":{\"201\":1}}],[\"结合具体的实例看一看\",{\"1\":{\"419\":1}}],[\"结合上述分析\",{\"1\":{\"221\":1}}],[\"结果都不是这个数\",{\"1\":{\"441\":1}}],[\"结果会填充0或false值\",{\"1\":{\"322\":1}}],[\"结果就是\",{\"1\":{\"221\":1}}],[\"结构图\",{\"1\":{\"399\":1}}],[\"结构中如何避免这个问题\",{\"1\":{\"221\":1}}],[\"结构组织的索引\",{\"1\":{\"221\":1}}],[\"结构\",{\"0\":{\"221\":1},\"1\":{\"221\":1}}],[\"结构化查询语言\",{\"1\":{\"170\":1}}],[\"身份证的有效期\",{\"1\":{\"201\":1}}],[\"身份证签发机关\",{\"1\":{\"201\":1}}],[\"身份证号\",{\"1\":{\"201\":1}}],[\"身份信息\",{\"1\":{\"201\":1}}],[\"生产者消费者问题\",{\"1\":{\"380\":1}}],[\"生产者与消费者问题\",{\"1\":{\"380\":1}}],[\"生日\",{\"1\":{\"201\":1}}],[\"生成订单等等这些操作\",{\"1\":{\"346\":1}}],[\"生成该pair的哈希值\",{\"1\":{\"337\":1}}],[\"生成新的字符串\",{\"1\":{\"324\":1}}],[\"生成的\",{\"1\":{\"101\":1}}],[\"生成的数据如下\",{\"1\":{\"77\":1}}],[\"生成文件名\",{\"1\":{\"86\":1,\"93\":1}}],[\"生成页面对象\",{\"1\":{\"84\":1}}],[\"民族\",{\"1\":{\"201\":1}}],[\"逻辑几乎和独占式锁的获取一模一样\",{\"1\":{\"522\":1}}],[\"逻辑走到\",{\"1\":{\"378\":1}}],[\"逻辑\",{\"1\":{\"250\":1}}],[\"逻辑外键\",{\"1\":{\"200\":1}}],[\"逻辑运算符\",{\"1\":{\"194\":2}}],[\"消耗\",{\"1\":{\"220\":1}}],[\"消耗性能\",{\"1\":{\"200\":1}}],[\"消息中间件\",{\"1\":{\"9\":1}}],[\"影响增\",{\"1\":{\"200\":1}}],[\"缺点\",{\"0\":{\"228\":1},\"1\":{\"200\":1,\"220\":1,\"311\":1}}],[\"物理外键\",{\"1\":{\"200\":1}}],[\"物理外键和逻辑外键\",{\"1\":{\"200\":1}}],[\"总体来说\",{\"1\":{\"518\":1}}],[\"总的来说\",{\"1\":{\"508\":1}}],[\"总的作用是为处于自己上层的应用软件提供运行与开发的环境\",{\"1\":{\"9\":1}}],[\"总结果必然会是小于\",{\"1\":{\"494\":1}}],[\"总结\",{\"0\":{\"403\":1,\"434\":1,\"499\":1}}],[\"总结下\",{\"1\":{\"378\":1}}],[\"总大小是\",{\"1\":{\"221\":1}}],[\"总记录数\",{\"1\":{\"198\":3}}],[\"集群场景\",{\"1\":{\"200\":1}}],[\"集群可以组成联邦\",{\"1\":{\"134\":1}}],[\"集合和\",{\"1\":{\"205\":1}}],[\"集合\",{\"0\":{\"326\":1,\"328\":1},\"1\":{\"198\":1,\"205\":1}}],[\"集合中\",{\"1\":{\"198\":1}}],[\"传递性\",{\"1\":{\"433\":1}}],[\"传递的参数\",{\"1\":{\"198\":1}}],[\"传参\",{\"1\":{\"328\":1}}],[\"传入指定大小时的情况\",{\"1\":{\"397\":1}}],[\"传入正则表达式分隔字符串\",{\"1\":{\"324\":1}}],[\"传入的为二维列表\",{\"1\":{\"102\":1}}],[\"传给形参\",{\"1\":{\"273\":1}}],[\"条记录\",{\"1\":{\"221\":1}}],[\"条数据\",{\"1\":{\"221\":1}}],[\"条数\",{\"1\":{\"198\":1}}],[\"条件满足\",{\"1\":{\"381\":1}}],[\"条件表达式\",{\"0\":{\"240\":1}}],[\"条件查询\",{\"0\":{\"194\":1},\"1\":{\"192\":1}}],[\"条件列表\",{\"1\":{\"192\":1,\"194\":2,\"197\":1}}],[\"条件\",{\"1\":{\"189\":1,\"190\":1,\"196\":2,\"207\":1}}],[\"升序\",{\"1\":{\"197\":1,\"333\":1}}],[\"区别\",{\"1\":{\"196\":1}}],[\"区别于上面\",{\"1\":{\"111\":1}}],[\"函数在类的每个对象中都有独立的一份\",{\"1\":{\"282\":1}}],[\"函数在类中只有一份\",{\"1\":{\"282\":1}}],[\"函数与普通成员变量\",{\"1\":{\"282\":1}}],[\"函数完美地打包在一起\",{\"1\":{\"279\":1}}],[\"函数递归\",{\"0\":{\"278\":1}}],[\"函数名必须相同\",{\"1\":{\"307\":1}}],[\"函数名和参数列表必须相同\",{\"1\":{\"307\":1}}],[\"函数名称相同但参数列表不同\",{\"1\":{\"277\":1}}],[\"函数名字是\",{\"1\":{\"265\":1}}],[\"函数名字\",{\"1\":{\"264\":1}}],[\"函数重载\",{\"0\":{\"277\":1},\"1\":{\"277\":1}}],[\"函数如果想在它的中间位置提前退出\",{\"1\":{\"275\":1}}],[\"函数内定义的变量为局部变量\",{\"1\":{\"270\":1}}],[\"函数及其区别会在下一章中介绍\",{\"1\":{\"270\":1}}],[\"函数返回类型\",{\"0\":{\"269\":1}}],[\"函数的区别\",{\"1\":{\"282\":1}}],[\"函数的返回类型也可以是数组\",{\"1\":{\"269\":1}}],[\"函数的形参列表可以为空\",{\"1\":{\"268\":1}}],[\"函数的形参列表\",{\"0\":{\"268\":1}}],[\"函数的调用完成两项工作\",{\"1\":{\"266\":1}}],[\"函数基础\",{\"0\":{\"264\":1}}],[\"函数\",{\"0\":{\"263\":1},\"1\":{\"195\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"307\":1}}],[\"聚合函数会忽略空值\",{\"1\":{\"195\":1}}],[\"聚合函数\",{\"0\":{\"195\":1},\"1\":{\"195\":1,\"196\":1}}],[\"匹配任意个字符\",{\"1\":{\"194\":1}}],[\"匹配单个字符\",{\"1\":{\"194\":1}}],[\"别名2\",{\"1\":{\"193\":1,\"207\":2}}],[\"别名1\",{\"1\":{\"193\":1,\"207\":2}}],[\"姓名\",{\"1\":{\"189\":1,\"201\":1}}],[\"插入\",{\"1\":{\"516\":1}}],[\"插入一个\",{\"1\":{\"487\":1}}],[\"插入完节点之后再次检查链表长度\",{\"1\":{\"399\":1}}],[\"插入完键值对后再根据实际大小看是否需要转换成红黑树\",{\"1\":{\"399\":1}}],[\"插入新值的话就是向这个链表插入新值\",{\"1\":{\"399\":1}}],[\"插入数据的时候才真正的完成初始化创建\",{\"1\":{\"397\":1}}],[\"插入数据时\",{\"1\":{\"188\":1}}],[\"插入节点数超过了该临界值就需要扩容\",{\"1\":{\"393\":1}}],[\"插入到等待队列中即可\",{\"1\":{\"378\":1}}],[\"插入和删除快\",{\"1\":{\"327\":1}}],[\"插入和删除操作的场景\",{\"1\":{\"228\":1}}],[\"插入操作\",{\"1\":{\"226\":1}}],[\"插入的数据大小\",{\"1\":{\"188\":1}}],[\"批量添加数据\",{\"1\":{\"188\":2}}],[\"批量收集网站数据\",{\"1\":{\"75\":1}}],[\"值也是相等的\",{\"1\":{\"484\":1}}],[\"值是否为小于\",{\"1\":{\"400\":1}}],[\"值是不是等于\",{\"1\":{\"399\":1}}],[\"值即可\",{\"1\":{\"399\":1}}],[\"值相同的节点组成的链表的头节点\",{\"1\":{\"399\":1}}],[\"值相同的节点构成链表的形式\",{\"1\":{\"399\":1}}],[\"值相等并且\",{\"1\":{\"399\":1}}],[\"值大于\",{\"1\":{\"399\":1}}],[\"值与数组的长度取模操作\",{\"1\":{\"399\":1}}],[\"值能够分散能够均匀减小\",{\"1\":{\"399\":1}}],[\"值分散的不够均匀的话会大大增加哈希冲突的概率\",{\"1\":{\"399\":1}}],[\"值变为\",{\"1\":{\"398\":1}}],[\"值\",{\"1\":{\"360\":1,\"399\":1}}],[\"值传递\",{\"0\":{\"272\":1}}],[\"值2\",{\"1\":{\"188\":6,\"189\":1}}],[\"值1\",{\"1\":{\"188\":6,\"189\":1}}],[\"向程序员提供的\",{\"1\":{\"435\":1}}],[\"向程序员保证\",{\"1\":{\"432\":1}}],[\"向零整除后的余数\",{\"1\":{\"234\":1}}],[\"向哈希表中添加元素时\",{\"1\":{\"226\":1}}],[\"向指定字段添加数据\",{\"1\":{\"188\":1}}],[\"向上插入一行\",{\"1\":{\"71\":1}}],[\"增加了超时等待的功能\",{\"1\":{\"417\":1}}],[\"增加了超时返回的特性\",{\"1\":{\"386\":1}}],[\"增加写状态\",{\"1\":{\"366\":1}}],[\"增加\",{\"0\":{\"188\":1},\"1\":{\"488\":1}}],[\"删\",{\"1\":{\"187\":1,\"200\":1}}],[\"删除最后元素\",{\"1\":{\"327\":1}}],[\"删除最后元素为o\",{\"1\":{\"327\":1}}],[\"删除位于index的元素\",{\"1\":{\"327\":1}}],[\"删除关键字\",{\"1\":{\"295\":1}}],[\"删除元素\",{\"1\":{\"294\":1}}],[\"删除元素时\",{\"1\":{\"226\":1}}],[\"删除并返回队头\",{\"1\":{\"293\":1}}],[\"删除操作\",{\"1\":{\"226\":1}}],[\"删除索引\",{\"1\":{\"222\":1}}],[\"删除数据\",{\"1\":{\"187\":1}}],[\"删除数据库\",{\"0\":{\"178\":1}}],[\"删除一张不存在的表\",{\"1\":{\"186\":1}}],[\"删除字段\",{\"1\":{\"185\":1}}],[\"删除表语法\",{\"1\":{\"186\":1}}],[\"删除表\",{\"1\":{\"179\":1}}],[\"删除变量\",{\"0\":{\"154\":1}}],[\"删除失败会抛出异常\",{\"1\":{\"141\":1}}],[\"删除当前行\",{\"1\":{\"71\":1}}],[\"删除\",{\"0\":{\"186\":1,\"190\":1},\"1\":{\"71\":1,\"174\":1,\"178\":1,\"399\":1}}],[\"混合日期和时间值\",{\"1\":{\"183\":2}}],[\"至少能看到写线程\",{\"1\":{\"488\":1}}],[\"至此\",{\"1\":{\"399\":1}}],[\"至于为什么不用\",{\"1\":{\"391\":1}}],[\"至关重要\",{\"1\":{\"242\":1}}],[\"至\",{\"1\":{\"183\":5}}],[\"固定长度为11\",{\"1\":{\"183\":1}}],[\"固原\",{\"1\":{\"76\":1,\"77\":1}}],[\"极大文本数据\",{\"1\":{\"183\":1}}],[\"极大整数值\",{\"1\":{\"183\":1}}],[\"变为了成\",{\"1\":{\"451\":1}}],[\"变成线程安全的也可以使用\",{\"1\":{\"407\":1}}],[\"变得不可使用\",{\"1\":{\"327\":1}}],[\"变长数组\",{\"1\":{\"291\":1}}],[\"变长字符串\",{\"1\":{\"183\":1}}],[\"变量不需要与其他的状态变量共同参与不变约束\",{\"1\":{\"494\":1}}],[\"变量初始化后的值\",{\"1\":{\"487\":1}}],[\"变量未进行初始化\",{\"1\":{\"478\":1}}],[\"变量未初始化时系统不会进行隐式初始化\",{\"1\":{\"477\":1}}],[\"变量时就指定了初始值\",{\"1\":{\"479\":1}}],[\"变量时就像是接收了线程\",{\"1\":{\"468\":1}}],[\"变量时\",{\"1\":{\"468\":1}}],[\"变量写后\",{\"1\":{\"468\":1}}],[\"变量可以通过缓存一致性协议保证每个线程都能获得最新值\",{\"1\":{\"467\":1}}],[\"变量通过这样的机制就使得每个线程都能获得该变量的最新值\",{\"1\":{\"466\":1}}],[\"变量的不可更改性\",{\"1\":{\"479\":1}}],[\"变量的内存变化示意图\",{\"1\":{\"468\":1}}],[\"变量的读\",{\"1\":{\"467\":1}}],[\"变量的写\",{\"1\":{\"467\":1}}],[\"变量的修改会立刻被其他线程所感知\",{\"1\":{\"465\":1}}],[\"变量的作用域\",{\"0\":{\"270\":1}}],[\"变量当作一个普通变量来对待\",{\"1\":{\"435\":1}}],[\"变量只会被单个线程访问\",{\"1\":{\"435\":1}}],[\"变量规则\",{\"1\":{\"433\":1,\"467\":1}}],[\"变量都能够强制刷新到主存\",{\"1\":{\"429\":1}}],[\"变量定义的方式\",{\"1\":{\"233\":1}}],[\"变量必须先定义\",{\"1\":{\"233\":1}}],[\"变量类型\",{\"0\":{\"155\":1}}],[\"变量\",{\"0\":{\"150\":1,\"233\":1,\"476\":1},\"1\":{\"282\":3,\"450\":1,\"467\":1,\"470\":1}}],[\"变量值为安装路径\",{\"1\":{\"34\":1}}],[\"精确定点数\",{\"1\":{\"183\":1}}],[\"精度\",{\"1\":{\"183\":2}}],[\"小明回家后看到纸条如愿吃到妈妈做的饭菜\",{\"1\":{\"428\":1}}],[\"小明妈妈要去上班了十分紧急这个时候手机又没有电了\",{\"1\":{\"428\":1}}],[\"小明妈妈在家里做饭\",{\"1\":{\"428\":1}}],[\"小明在外面玩耍\",{\"1\":{\"428\":1}}],[\"小数\",{\"1\":{\"235\":1}}],[\"小数值\",{\"1\":{\"183\":1}}],[\"小于0直接抛异常\",{\"1\":{\"397\":1}}],[\"小于等于\",{\"1\":{\"194\":1,\"239\":1}}],[\"小于\",{\"1\":{\"194\":1,\"239\":1}}],[\"小整数值\",{\"1\":{\"183\":1}}],[\"范围为\",{\"1\":{\"335\":1}}],[\"范围遍历\",{\"1\":{\"256\":2,\"260\":1}}],[\"范围\",{\"1\":{\"183\":3}}],[\"类继承了\",{\"1\":{\"505\":1}}],[\"类都是不可变类\",{\"1\":{\"484\":1}}],[\"类变量\",{\"1\":{\"477\":1}}],[\"类变量有两个时机赋初值\",{\"1\":{\"477\":1}}],[\"类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值\",{\"1\":{\"477\":1}}],[\"类就是一个\",{\"1\":{\"474\":1}}],[\"类除了提供\",{\"1\":{\"420\":1}}],[\"类或\",{\"1\":{\"413\":1}}],[\"类实现如下\",{\"1\":{\"505\":1}}],[\"类实现了\",{\"1\":{\"394\":1}}],[\"类实现的\",{\"1\":{\"393\":1}}],[\"类有这样一个属性\",{\"1\":{\"377\":1}}],[\"类复用了在\",{\"1\":{\"377\":1}}],[\"类在\",{\"1\":{\"330\":1}}],[\"类却要调用一个\",{\"1\":{\"323\":1}}],[\"类使用\",{\"1\":{\"323\":1}}],[\"类用来表示内容可变的字符串\",{\"1\":{\"323\":1}}],[\"类用来表示那些创建后就不会再改变的字符串\",{\"1\":{\"323\":1}}],[\"类中的\",{\"1\":{\"300\":2}}],[\"类及其子类\",{\"1\":{\"299\":1}}],[\"类及其子类异常\",{\"1\":{\"299\":1}}],[\"类似\",{\"1\":{\"285\":1}}],[\"类似于c++中的sprintf\",{\"1\":{\"260\":1}}],[\"类似于字符串\",{\"1\":{\"164\":1}}],[\"类似于\",{\"1\":{\"51\":1,\"337\":1}}],[\"类的源码为\",{\"1\":{\"408\":1}}],[\"类的\",{\"1\":{\"394\":1,\"484\":1}}],[\"类的效率更高\",{\"1\":{\"323\":1}}],[\"类的构造函数中初始化了\",{\"1\":{\"301\":1}}],[\"类的多态\",{\"0\":{\"284\":1}}],[\"类的继承\",{\"0\":{\"283\":1}}],[\"类的定义\",{\"0\":{\"282\":1}}],[\"类的类名保持一致\",{\"1\":{\"281\":1}}],[\"类的一个对象\",{\"1\":{\"280\":1}}],[\"类定义一种全新的数据类型\",{\"1\":{\"280\":1}}],[\"类与对象\",{\"0\":{\"280\":1}}],[\"类与接口\",{\"0\":{\"279\":1}}],[\"类可以将变量\",{\"1\":{\"279\":1}}],[\"类\",{\"0\":{\"260\":1,\"483\":1},\"1\":{\"281\":2,\"292\":1,\"307\":1,\"314\":1,\"330\":2,\"337\":1,\"375\":1,\"377\":1,\"391\":1,\"394\":1,\"409\":1,\"413\":1,\"507\":1}}],[\"类型的类\",{\"1\":{\"474\":1}}],[\"类型转换\",{\"1\":{\"324\":1}}],[\"类型转化\",{\"1\":{\"233\":1}}],[\"类型上都属于\",{\"1\":{\"299\":1}}],[\"类型等采用值传递\",{\"1\":{\"272\":1}}],[\"类型\",{\"1\":{\"183\":3,\"185\":2,\"233\":1,\"366\":1}}],[\"从方法名就可以很清楚\",{\"1\":{\"516\":1}}],[\"从这个例子就可以很清楚的看出来\",{\"1\":{\"508\":1}}],[\"从这个图我们可以很清楚的看到这样几点\",{\"1\":{\"377\":1}}],[\"从执行情况也可以看出来当前\",{\"1\":{\"508\":1}}],[\"从横向来看\",{\"1\":{\"445\":1}}],[\"从横向上看\",{\"1\":{\"429\":1,\"468\":1}}],[\"从上图可以看出\",{\"1\":{\"445\":1}}],[\"从上图中就可以看出来\",{\"1\":{\"443\":1}}],[\"从上图中可以看出\",{\"1\":{\"435\":1}}],[\"从上面内存抽象结构来说\",{\"1\":{\"437\":1}}],[\"从上面的分析可以看出\",{\"1\":{\"435\":1}}],[\"从上面的结构示意图就可以看出存在这样一种情况\",{\"1\":{\"399\":1}}],[\"从程序员的角度来说\",{\"1\":{\"432\":1}}],[\"从程序语法角度讲是必须进行处理的异常\",{\"1\":{\"299\":1}}],[\"从主存中读取最新的共享变量\",{\"1\":{\"429\":1}}],[\"从主内存中将共享变量读入线程\",{\"1\":{\"429\":1}}],[\"从客户那里获取需求后\",{\"1\":{\"420\":1}}],[\"从类名就可以看的出来实现队列的数据结构是链式\",{\"1\":{\"407\":1}}],[\"从给出的注释来看\",{\"1\":{\"402\":1}}],[\"从链表中查找\",{\"1\":{\"400\":1}}],[\"从整体而言\",{\"1\":{\"399\":1}}],[\"从整体上来看\",{\"1\":{\"375\":1,\"445\":1,\"503\":1}}],[\"从该类的注释也可以看出\",{\"1\":{\"394\":1}}],[\"从而进一步可以佐证获得锁的过程是一个\",{\"1\":{\"518\":1}}],[\"从而进入同步队列\",{\"1\":{\"513\":1}}],[\"从而进入到同步代码块或者同步方法之中\",{\"1\":{\"446\":1}}],[\"从而实现自己的同步语义\",{\"1\":{\"508\":1}}],[\"从而避免这种情况\",{\"1\":{\"497\":1}}],[\"从而避免出现数据脏读的现象\",{\"1\":{\"465\":1}}],[\"从而保证该对象对所有线程可见时\",{\"1\":{\"488\":1}}],[\"从而保证数据的\",{\"1\":{\"465\":1}}],[\"从而就可以避免这种情况\",{\"1\":{\"487\":1}}],[\"从而\",{\"1\":{\"487\":1,\"498\":1}}],[\"从而能够顺利停止掉\",{\"1\":{\"470\":1}}],[\"从而能够结束在\",{\"1\":{\"470\":1}}],[\"从而需要再次从主内存中读取该值\",{\"1\":{\"470\":1}}],[\"从而对每个线程都是可见的\",{\"1\":{\"429\":1}}],[\"从而做出响应\",{\"1\":{\"419\":1}}],[\"从而确定新值插入到数组的哪个位置\",{\"1\":{\"399\":1}}],[\"从而大大减小哈希冲突的可能性\",{\"1\":{\"399\":1}}],[\"从而影响到\",{\"1\":{\"399\":1}}],[\"从而调用\",{\"1\":{\"398\":1}}],[\"从而使得线程\",{\"1\":{\"380\":1}}],[\"从而才有机会使得调用\",{\"1\":{\"379\":1}}],[\"从而提高系统的可靠性和容错能力\",{\"1\":{\"134\":1}}],[\"从业务概念方面来讲\",{\"1\":{\"342\":1}}],[\"从堆栈的顶部返回元素的位置\",{\"1\":{\"330\":1}}],[\"从休眠中中断线程\",{\"1\":{\"315\":1}}],[\"从第一个数中减去第二个数\",{\"1\":{\"234\":1}}],[\"从\",{\"1\":{\"182\":1,\"375\":1,\"433\":1}}],[\"具体是否插入还是得看是什么处理器\",{\"1\":{\"489\":1}}],[\"具体规则\",{\"0\":{\"433\":1}}],[\"具体的就不再说了\",{\"1\":{\"524\":1}}],[\"具体的大家可以使用一些工具去看一下\",{\"1\":{\"466\":1}}],[\"具体的可以看上面的表格\",{\"1\":{\"442\":1}}],[\"具体的一共有六项规则\",{\"1\":{\"433\":1}}],[\"具体的定义为\",{\"1\":{\"430\":1,\"432\":1}}],[\"具体的性能测试可以去网上查阅一些资料\",{\"1\":{\"391\":1}}],[\"具体方法是\",{\"1\":{\"413\":1}}],[\"具体使用请看注释\",{\"1\":{\"397\":1}}],[\"具体为\",{\"1\":{\"393\":1}}],[\"具体逻辑请看注释\",{\"1\":{\"379\":1}}],[\"具体请看注释\",{\"1\":{\"359\":1,\"378\":1}}],[\"具体地\",{\"1\":{\"134\":1}}],[\"具有原子性\",{\"1\":{\"499\":1}}],[\"具有可见性\",{\"1\":{\"498\":2}}],[\"具有有序性和可见性\",{\"1\":{\"499\":1}}],[\"具有有序性\",{\"1\":{\"496\":1}}],[\"具有更高的可控制性和扩展性\",{\"1\":{\"375\":1}}],[\"具有\",{\"1\":{\"182\":1}}],[\"要求编译器和处理器必须禁止这种重排序\",{\"1\":{\"435\":1}}],[\"要求\",{\"1\":{\"433\":1}}],[\"要求非空且唯一\",{\"1\":{\"182\":1}}],[\"要经历如下两步\",{\"1\":{\"429\":1}}],[\"要由线程调度器重新激活这个线程\",{\"1\":{\"415\":1}}],[\"要由操作系统为线程提供具体的运行时间\",{\"1\":{\"414\":1}}],[\"要确定一个线程的当前状态\",{\"1\":{\"412\":1}}],[\"要想先学习\",{\"1\":{\"408\":1}}],[\"要想将\",{\"1\":{\"407\":1}}],[\"要想向\",{\"1\":{\"399\":1}}],[\"要想不响应中断可以调用\",{\"1\":{\"378\":1}}],[\"要想能够深入的掌握\",{\"1\":{\"377\":1}}],[\"要想能够彻底的理解读写锁必须能够理解这样几个问题\",{\"1\":{\"364\":1}}],[\"要想支持重入性\",{\"1\":{\"359\":1}}],[\"要想完完全全的弄懂\",{\"1\":{\"358\":1}}],[\"要么恢复到无锁或者标记对象不适合作为偏向锁\",{\"1\":{\"455\":1}}],[\"要么重新偏向于其他线程\",{\"1\":{\"455\":1}}],[\"要么全部执行成功要么全部执行失败\",{\"1\":{\"494\":1}}],[\"要么全部成功\",{\"1\":{\"218\":1}}],[\"要么全部失败\",{\"1\":{\"218\":2}}],[\"要么全都失败\",{\"1\":{\"216\":1}}],[\"要么全都成功\",{\"1\":{\"216\":1}}],[\"要么同时失败\",{\"1\":{\"216\":1}}],[\"要么所有的\",{\"1\":{\"216\":1}}],[\"要使用此布局\",{\"1\":{\"1\":1}}],[\"描述\",{\"1\":{\"182\":1,\"183\":3,\"212\":1,\"217\":1,\"234\":1,\"300\":2}}],[\"约束是作用于表中字段上的\",{\"1\":{\"182\":1}}],[\"约束\",{\"0\":{\"182\":1},\"1\":{\"181\":3,\"182\":1,\"185\":2}}],[\"切换数据库\",{\"1\":{\"177\":1}}],[\"切换到对应的数据库下\",{\"1\":{\"177\":1}}],[\"切换到\",{\"1\":{\"22\":1,\"443\":1}}],[\"切换到想要放置项目的路径\",{\"1\":{\"22\":1}}],[\"则采用尾插入\",{\"1\":{\"516\":1}}],[\"则采用默认值\",{\"1\":{\"182\":1}}],[\"则先调用\",{\"1\":{\"515\":1}}],[\"则方法结束返回\",{\"1\":{\"515\":1}}],[\"则实现了对同步状态的管理\",{\"1\":{\"512\":1}}],[\"则尝试使用\",{\"1\":{\"454\":1}}],[\"则使用\",{\"1\":{\"454\":1}}],[\"则\",{\"1\":{\"444\":1,\"467\":1}}],[\"则调度器会剥夺某个当前允许线程的运行权\",{\"1\":{\"417\":1}}],[\"则调用\",{\"1\":{\"385\":1}}],[\"则需要再测试一下\",{\"1\":{\"454\":1}}],[\"则需要依次锁住所有的\",{\"1\":{\"403\":1}}],[\"则需要检验是否需要进行扩容操作\",{\"1\":{\"402\":1}}],[\"则需要刷新网页\",{\"1\":{\"81\":1}}],[\"则为树节点\",{\"1\":{\"400\":1}}],[\"则继续再看当前是不是树节点\",{\"1\":{\"400\":1}}],[\"则只需要覆盖该结点的\",{\"1\":{\"399\":1}}],[\"则得到的结点就是\",{\"1\":{\"399\":1}}],[\"则直接返回\",{\"1\":{\"400\":1,\"403\":1}}],[\"则直接将新值插入到链表末尾即可\",{\"1\":{\"399\":1}}],[\"则直接使用cas将值插入即可\",{\"1\":{\"399\":1}}],[\"则直接令\",{\"1\":{\"324\":1}}],[\"则表示没有竞争发生\",{\"1\":{\"459\":1}}],[\"则表示当前正有\",{\"1\":{\"393\":1}}],[\"则表明该变量已经被其他线程做了处理\",{\"1\":{\"393\":1}}],[\"则表明该变量没被其他线程进行修改\",{\"1\":{\"393\":1}}],[\"则可以调用\",{\"1\":{\"385\":1}}],[\"则可以从等待方法中返回\",{\"1\":{\"375\":1}}],[\"则写锁获取失败\",{\"1\":{\"366\":1}}],[\"则是为了减少一部分上下文切换\",{\"1\":{\"360\":1}}],[\"则有可能导致其他线程永远无法获取到锁\",{\"1\":{\"360\":1}}],[\"则从0开始加1\",{\"1\":{\"329\":1}}],[\"则从上到下匹配到第一个\",{\"1\":{\"241\":1}}],[\"则k在map中的值加1\",{\"1\":{\"329\":1}}],[\"则replace旧的value\",{\"1\":{\"329\":1}}],[\"则将对象头设置成无锁状态\",{\"1\":{\"455\":1}}],[\"则将\",{\"1\":{\"324\":1,\"378\":1}}],[\"则返回相应的索引\",{\"1\":{\"336\":1}}],[\"则返回defaultvalue\",{\"1\":{\"329\":1}}],[\"则返回null\",{\"1\":{\"329\":1}}],[\"则返回true\",{\"1\":{\"328\":1,\"329\":2}}],[\"则返回\",{\"1\":{\"322\":1}}],[\"则阻塞\",{\"1\":{\"316\":1}}],[\"则抛出该异常\",{\"1\":{\"300\":1}}],[\"则该索引为非法索引\",{\"1\":{\"300\":1}}],[\"则该函数内的每个分支都必须有\",{\"1\":{\"276\":1}}],[\"则不需要交换\",{\"1\":{\"275\":1}}],[\"则不执行删除操作\",{\"1\":{\"186\":1}}],[\"则执行循环体中的语句\",{\"1\":{\"243\":1}}],[\"则执行后面的语句\",{\"1\":{\"243\":1}}],[\"则通过冲突解决策略找到元素\",{\"1\":{\"226\":1}}],[\"则会执行\",{\"1\":{\"518\":1}}],[\"则会严重影响\",{\"1\":{\"399\":1}}],[\"则会删除整张表的所有数据\",{\"1\":{\"190\":1}}],[\"则会修改整张表的所有数据\",{\"1\":{\"189\":1}}],[\"则创建该数据库\",{\"1\":{\"176\":1}}],[\"否则就只能等待\",{\"1\":{\"443\":1}}],[\"否则就返回null即可\",{\"1\":{\"400\":1}}],[\"否则就向红黑树追加新节点\",{\"1\":{\"399\":1}}],[\"否则依次向后遍历\",{\"1\":{\"399\":1}}],[\"否则再对该值进一步处理\",{\"1\":{\"397\":1}}],[\"否则会报\",{\"1\":{\"423\":1}}],[\"否则会一直阻塞\",{\"1\":{\"385\":1}}],[\"否则会出现解锁失败的情况\",{\"1\":{\"349\":1}}],[\"否则可能阻塞\",{\"1\":{\"385\":1}}],[\"否则获取成功利用\",{\"1\":{\"369\":1}}],[\"否则\",{\"1\":{\"366\":1,\"378\":1,\"397\":1,\"508\":1,\"518\":1,\"522\":1}}],[\"否则锁仍未释放\",{\"1\":{\"359\":1}}],[\"否则poll\",{\"1\":{\"331\":1}}],[\"否则返回一个负数值\",{\"1\":{\"336\":1}}],[\"否则返回null\",{\"1\":{\"331\":2}}],[\"否则返回false\",{\"1\":{\"324\":1,\"328\":2,\"329\":3,\"330\":1,\"331\":2,\"332\":1,\"333\":1}}],[\"否则停止\",{\"1\":{\"243\":1}}],[\"否则输出no\",{\"1\":{\"239\":1}}],[\"否则执行另一些语句\",{\"1\":{\"239\":1}}],[\"否则不需要更换\",{\"1\":{\"333\":1}}],[\"否则不执行删除\",{\"1\":{\"178\":1}}],[\"否则不能操作\",{\"1\":{\"177\":1}}],[\"否则将会报错\",{\"1\":{\"176\":1}}],[\"否则需要手动添加环境变量\",{\"1\":{\"67\":1}}],[\"查找到则返回该节点的value\",{\"1\":{\"400\":1}}],[\"查找等算法\",{\"1\":{\"399\":1}}],[\"查找一个节点会出现时间复杂度为\",{\"1\":{\"399\":1}}],[\"查找\",{\"1\":{\"260\":1}}],[\"查找和删除操作\",{\"1\":{\"227\":1}}],[\"查找操作\",{\"1\":{\"226\":1}}],[\"查询同步队列中等待线程情况\",{\"1\":{\"507\":1}}],[\"查询快\",{\"1\":{\"327\":1}}],[\"查询两表或多表中交集部分数据\",{\"1\":{\"207\":1}}],[\"查询右表所有数据\",{\"1\":{\"206\":1}}],[\"查询左表所有数据\",{\"1\":{\"206\":1}}],[\"查询用户表和部门表中的数据\",{\"1\":{\"205\":1}}],[\"查询时从多张表中获取所需数据\",{\"1\":{\"205\":1}}],[\"查询页码\",{\"1\":{\"198\":1}}],[\"查询记录数\",{\"1\":{\"198\":1}}],[\"查询其他字段无任何意义\",{\"1\":{\"196\":1}}],[\"查询的字段一般为聚合函数和分组字段\",{\"1\":{\"196\":1}}],[\"查询所有字段\",{\"1\":{\"193\":1}}],[\"查询所有数据库\",{\"1\":{\"175\":1}}],[\"查询多个字段\",{\"1\":{\"193\":1}}],[\"查询分为以下几种类型\",{\"1\":{\"192\":1}}],[\"查询语句\",{\"1\":{\"192\":1}}],[\"查询指定表的建表语句\",{\"1\":{\"184\":1}}],[\"查询表\",{\"1\":{\"179\":1}}],[\"查询当前数据库所有表\",{\"1\":{\"184\":1}}],[\"查询当前数据库\",{\"1\":{\"175\":1}}],[\"查询数据库\",{\"0\":{\"175\":1}}],[\"查询\",{\"0\":{\"184\":1},\"1\":{\"174\":1}}],[\"查看字节码文件\",{\"1\":{\"443\":1}}],[\"查看栈顶元素\",{\"1\":{\"330\":1}}],[\"查看索引\",{\"1\":{\"222\":1}}],[\"查看指定表结构\",{\"1\":{\"184\":1}}],[\"查看文档\",{\"1\":{\"71\":1}}],[\"查看\",{\"1\":{\"71\":1,\"221\":1}}],[\"查看详细信息\",{\"1\":{\"55\":1}}],[\"查看源码\",{\"1\":{\"49\":1}}],[\"查看渲染后的题解\",{\"1\":{\"47\":1}}],[\"英文全称是\",{\"1\":{\"174\":1}}],[\"英语\",{\"1\":{\"9\":1}}],[\"索引名\",{\"1\":{\"222\":2}}],[\"索引节点大小\",{\"1\":{\"221\":1}}],[\"索引等\",{\"1\":{\"221\":1}}],[\"索引大大提高了查询效率\",{\"1\":{\"220\":1}}],[\"索引会占用存储空间\",{\"1\":{\"220\":1}}],[\"索引\",{\"0\":{\"219\":1},\"1\":{\"173\":1,\"220\":1,\"221\":2}}],[\"优先级高的线程相较于优先级低的线程优先获得处理器时间片\",{\"1\":{\"422\":1}}],[\"优先级的范围从\",{\"1\":{\"422\":1}}],[\"优先队列在添加元素的时候对元素的大小排序后再保存\",{\"1\":{\"333\":1}}],[\"优先队列\",{\"0\":{\"333\":1},\"1\":{\"293\":1}}],[\"优缺点\",{\"0\":{\"311\":1}}],[\"优化手段\",{\"1\":{\"173\":1}}],[\"优点\",{\"0\":{\"227\":1},\"1\":{\"44\":1,\"220\":1,\"311\":1}}],[\"字符可以参与运算\",{\"1\":{\"259\":1}}],[\"字符与整数的联系\",{\"0\":{\"259\":1}}],[\"字符数组的初始化\",{\"1\":{\"253\":1}}],[\"字符串比较必须能用equals\",{\"1\":{\"324\":1}}],[\"字符串分为两类\",{\"1\":{\"323\":1}}],[\"字符串或向量的排序\",{\"1\":{\"300\":1}}],[\"字符串或者其他对象\",{\"1\":{\"269\":1}}],[\"字符串的第i个位置的字符\",{\"1\":{\"260\":1}}],[\"字符串是计算机与人类沟通的重要手段\",{\"1\":{\"258\":1}}],[\"字符串等\",{\"1\":{\"227\":1}}],[\"字符串和日期型数据应该包含在引号中\",{\"1\":{\"188\":1}}],[\"字符串类型\",{\"1\":{\"183\":2}}],[\"字符串可以用单引号\",{\"1\":{\"156\":1}}],[\"字符串\",{\"0\":{\"156\":1,\"258\":1,\"323\":1},\"1\":{\"211\":1}}],[\"字节数\",{\"1\":{\"233\":1}}],[\"字节\",{\"1\":{\"221\":2}}],[\"字段3\",{\"1\":{\"193\":1}}],[\"字段列表\",{\"1\":{\"192\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"205\":2,\"207\":2,\"208\":2}}],[\"字段更新为\",{\"1\":{\"189\":1}}],[\"字段类型\",{\"1\":{\"185\":1}}],[\"字段类型为\",{\"1\":{\"185\":1}}],[\"字段名2\",{\"1\":{\"188\":2,\"189\":1}}],[\"字段名1\",{\"1\":{\"188\":2,\"189\":1}}],[\"字段名为\",{\"1\":{\"185\":1}}],[\"字段名\",{\"1\":{\"185\":3,\"200\":1,\"222\":1}}],[\"字段的类型\",{\"1\":{\"184\":1}}],[\"字段n注释\",{\"1\":{\"181\":1}}],[\"字段n类型\",{\"1\":{\"181\":1}}],[\"字段n\",{\"1\":{\"181\":1}}],[\"字段2注释\",{\"1\":{\"181\":1}}],[\"字段2类型\",{\"1\":{\"181\":1}}],[\"字段2\",{\"1\":{\"181\":1,\"193\":2,\"197\":1}}],[\"字段1注释\",{\"1\":{\"181\":1}}],[\"字段1类型\",{\"1\":{\"181\":1}}],[\"字段1\",{\"1\":{\"181\":1,\"193\":2,\"197\":1}}],[\"字段\",{\"1\":{\"172\":1,\"182\":1}}],[\"表明获取同步状态失败即所引用的线程获取锁失败\",{\"1\":{\"522\":1}}],[\"表明该类是不能被子类继承的\",{\"1\":{\"483\":1}}],[\"表明该值已经被其他线程改过了则该旧值\",{\"1\":{\"449\":1}}],[\"表的性能\",{\"1\":{\"399\":1}}],[\"表来说\",{\"1\":{\"399\":1}}],[\"表面上拼接字符串时\",{\"1\":{\"323\":1}}],[\"表达式\",{\"0\":{\"235\":1},\"1\":{\"245\":1}}],[\"表子查询\",{\"0\":{\"214\":1},\"1\":{\"210\":1}}],[\"表2\",{\"1\":{\"205\":1,\"207\":2,\"208\":2}}],[\"表1\",{\"1\":{\"205\":1,\"207\":2,\"208\":2}}],[\"表中元素数量与槽位数的比值\",{\"1\":{\"228\":1}}],[\"表中\",{\"1\":{\"189\":1}}],[\"表添加字段\",{\"1\":{\"185\":1}}],[\"表注释\",{\"1\":{\"181\":1}}],[\"表名列表\",{\"1\":{\"192\":1}}],[\"表名不存在\",{\"1\":{\"186\":1}}],[\"表名\",{\"1\":{\"181\":1,\"184\":2,\"185\":5,\"186\":1,\"188\":4,\"189\":1,\"190\":1,\"193\":4,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"200\":2,\"205\":1,\"222\":3}}],[\"表操作\",{\"0\":{\"179\":1}}],[\"表\",{\"1\":{\"172\":1,\"174\":1}}],[\"表示下一次共享式同步状态获取将会无条件传播下去\",{\"1\":{\"513\":1}}],[\"表示禁止重排序\",{\"1\":{\"469\":1}}],[\"表示其他线程竞争锁\",{\"1\":{\"458\":1}}],[\"表示当前线程阻塞\",{\"1\":{\"517\":1}}],[\"表示当前锁存在竞争\",{\"1\":{\"459\":1}}],[\"表示当前是偏向锁\",{\"1\":{\"454\":1}}],[\"表示当前数据容器\",{\"1\":{\"393\":1}}],[\"表示线程已经获得了锁\",{\"1\":{\"454\":1}}],[\"表示在\",{\"1\":{\"419\":1}}],[\"表示已经处理过该节点\",{\"1\":{\"401\":1}}],[\"表示为需要新建数组的长度\",{\"1\":{\"393\":1}}],[\"表示正在初始化\",{\"1\":{\"393\":1}}],[\"表示可以再次获取成功\",{\"1\":{\"359\":1}}],[\"表示能够对共享资源能够重复加锁\",{\"1\":{\"358\":1}}],[\"表示键值对\",{\"1\":{\"337\":1}}],[\"表示两个元素需要更换位置\",{\"1\":{\"333\":1}}],[\"表示泛型\",{\"1\":{\"327\":1}}],[\"表示字符串\",{\"1\":{\"261\":1}}],[\"表示\",{\"1\":{\"237\":1,\"280\":1}}],[\"表示存储桶是否存在\",{\"1\":{\"141\":1}}],[\"表示评测出错了\",{\"1\":{\"55\":1}}],[\"密码在\",{\"1\":{\"169\":1}}],[\"密码直接以明文形式出现在命令行\",{\"1\":{\"169\":1}}],[\"密码直接在\",{\"1\":{\"169\":1}}],[\"数字类型包装类都支持两个常量\",{\"1\":{\"338\":1}}],[\"数字\",{\"1\":{\"211\":1}}],[\"数值类型\",{\"1\":{\"183\":2}}],[\"数组正在进行扩容\",{\"1\":{\"399\":1}}],[\"数组进行初始化操作\",{\"1\":{\"399\":1}}],[\"数组还未初始化\",{\"1\":{\"399\":1}}],[\"数组+链表\",{\"1\":{\"399\":1}}],[\"数组为\",{\"1\":{\"399\":1}}],[\"数组是否初始化了\",{\"1\":{\"399\":1}}],[\"数组是存储数据的强而有力的手段\",{\"1\":{\"250\":1}}],[\"数组中的每一个桶\",{\"1\":{\"403\":1}}],[\"数组中的每个元素实际上是单链表的头结点或者红黑树的根节点\",{\"1\":{\"399\":1}}],[\"数组中\",{\"1\":{\"399\":1}}],[\"数组中索引为\",{\"1\":{\"395\":3}}],[\"数组中可以存放多个不同类型的值\",{\"1\":{\"160\":1}}],[\"数组降序排序排序\",{\"1\":{\"322\":1}}],[\"数组越界\",{\"1\":{\"302\":1}}],[\"数组不可变长\",{\"1\":{\"257\":1}}],[\"数组排序\",{\"1\":{\"257\":1}}],[\"数组下标从0开始\",{\"1\":{\"254\":1}}],[\"数组的索引\",{\"1\":{\"399\":1}}],[\"数组的时候会使用默认大小为\",{\"1\":{\"398\":1}}],[\"数组的工作\",{\"1\":{\"397\":1}}],[\"数组的长度\",{\"1\":{\"393\":1,\"397\":1}}],[\"数组的大小\",{\"1\":{\"393\":1}}],[\"数组的大小总是为\",{\"1\":{\"393\":1}}],[\"数组的范围遍历\",{\"0\":{\"256\":1}}],[\"数组的初始化\",{\"0\":{\"253\":1}}],[\"数组的定义方式和变量类似\",{\"1\":{\"252\":1}}],[\"数组的定义\",{\"0\":{\"252\":1}}],[\"数组长度\",{\"0\":{\"164\":1},\"1\":{\"397\":1}}],[\"数组用小括号表示\",{\"1\":{\"161\":1}}],[\"数组\",{\"0\":{\"160\":1,\"250\":1,\"322\":1},\"1\":{\"160\":1,\"273\":1,\"324\":1,\"327\":1,\"393\":1,\"394\":2,\"397\":1}}],[\"数据\",{\"1\":{\"221\":2,\"250\":1,\"403\":1}}],[\"数据结构中只需要经历两次磁盘\",{\"1\":{\"221\":1}}],[\"数据列表\",{\"1\":{\"198\":1}}],[\"数据类型\",{\"0\":{\"183\":1},\"1\":{\"200\":1}}],[\"数据控制语言\",{\"1\":{\"172\":1}}],[\"数据查询语言\",{\"1\":{\"172\":1}}],[\"数据操作语言\",{\"1\":{\"172\":1,\"187\":1}}],[\"数据定义语言\",{\"1\":{\"172\":1,\"174\":1}}],[\"数据存储高容错\",{\"1\":{\"134\":1}}],[\"数据来源\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"数据清洗中得出的平均工资\",{\"1\":{\"101\":1}}],[\"数据采集\",{\"0\":{\"79\":1}}],[\"数据已去重并保存为\",{\"1\":{\"75\":1}}],[\"数据可视化\",{\"0\":{\"99\":1},\"1\":{\"62\":1}}],[\"数据处理\",{\"0\":{\"74\":1},\"1\":{\"62\":1}}],[\"数据爬取\",{\"1\":{\"62\":1}}],[\"数据库实际上会添加唯一索引\",{\"1\":{\"222\":1}}],[\"数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构\",{\"1\":{\"221\":1}}],[\"数据库中间件\",{\"1\":{\"9\":1}}],[\"数据库支持的索引结构有很多\",{\"1\":{\"221\":1}}],[\"数据库系统提供的隔离机制\",{\"1\":{\"218\":1}}],[\"数据库自动生成\",{\"1\":{\"182\":1}}],[\"数据库不存在\",{\"1\":{\"176\":1}}],[\"数据库名\",{\"1\":{\"176\":1,\"177\":1,\"178\":1}}],[\"数据库操作\",{\"0\":{\"174\":1,\"187\":1,\"191\":1}}],[\"数据库操作阶段\",{\"1\":{\"173\":1}}],[\"数据库优化阶段\",{\"1\":{\"173\":1}}],[\"数据库设计阶段\",{\"1\":{\"173\":1}}],[\"数据库设计\",{\"0\":{\"173\":1}}],[\"数据库的\",{\"1\":{\"171\":1}}],[\"数据库之间\",{\"1\":{\"9\":1}}],[\"数据库\",{\"0\":{\"6\":1,\"534\":1},\"1\":{\"2\":1,\"172\":1,\"174\":1,\"178\":1}}],[\"说明同步队列是带头结点的链式存储结构\",{\"1\":{\"516\":1}}],[\"说明当前线程是第一个加入同步队列进行等待的线程\",{\"1\":{\"516\":1}}],[\"说明这个点已经被处理过了\",{\"1\":{\"401\":1}}],[\"说明正在进行扩容\",{\"1\":{\"399\":1}}],[\"说明发生了\",{\"1\":{\"399\":1}}],[\"说明还需要继续完成某些功能\",{\"1\":{\"275\":1}}],[\"说明\",{\"1\":{\"159\":1,\"172\":1,\"178\":1,\"195\":1,\"221\":1,\"301\":1,\"408\":1}}],[\"改变\",{\"1\":{\"450\":1}}],[\"改为了\",{\"1\":{\"470\":1}}],[\"改为\",{\"1\":{\"398\":1}}],[\"改为自定义变量\",{\"1\":{\"155\":1}}],[\"改动会影响原数组\",{\"1\":{\"327\":1}}],[\"改的效率\",{\"1\":{\"200\":1}}],[\"改操作\",{\"1\":{\"187\":1}}],[\"改成\",{\"1\":{\"34\":1}}],[\"局部变量的情况\",{\"1\":{\"478\":1}}],[\"局部变量已经进行了初始化则后面就不能再次进行更改\",{\"1\":{\"478\":1}}],[\"局部变量由程序员进行显式初始化\",{\"1\":{\"478\":1}}],[\"局部变量等数据信息\",{\"1\":{\"306\":1}}],[\"局部变量\",{\"0\":{\"478\":1},\"1\":{\"155\":1}}],[\"主内存和工作内存\",{\"1\":{\"467\":1}}],[\"主调函数的执行被暂时中断\",{\"1\":{\"266\":1}}],[\"主表列名\",{\"1\":{\"200\":2}}],[\"主表\",{\"1\":{\"200\":2}}],[\"主键字段\",{\"1\":{\"222\":1}}],[\"主键\",{\"1\":{\"182\":1}}],[\"主键自增\",{\"1\":{\"182\":1}}],[\"主键是一行数据的唯一标识\",{\"1\":{\"182\":1}}],[\"主键约束\",{\"1\":{\"182\":1}}],[\"主要有这两个方面的影响\",{\"1\":{\"466\":1}}],[\"主要有两种\",{\"1\":{\"428\":1}}],[\"主要集中在主内存和线程的工作内存而导致的内存可见性问题\",{\"1\":{\"441\":1}}],[\"主要设计上的变化有以下几点\",{\"1\":{\"403\":1}}],[\"主要使用\",{\"1\":{\"403\":1}}],[\"主要是遍历复制的过程\",{\"1\":{\"401\":1}}],[\"主要存放\",{\"1\":{\"394\":1}}],[\"主要逻辑请看注释\",{\"1\":{\"370\":1}}],[\"主要也就是\",{\"1\":{\"358\":1}}],[\"主要对集合进行操作\",{\"1\":{\"336\":1}}],[\"主要包含数学内的应用方法\",{\"1\":{\"335\":1}}],[\"主要包括三个阶段\",{\"1\":{\"173\":1}}],[\"主要用来定义类中所需包含的函数\",{\"1\":{\"285\":1}}],[\"主要为了帮助解释器识别变量边界\",{\"1\":{\"152\":1}}],[\"主题提供的脚手架工具创建项目\",{\"1\":{\"22\":1}}],[\"花括号是可选的\",{\"1\":{\"152\":1}}],[\"符号\",{\"1\":{\"151\":1,\"152\":2}}],[\"$$\",{\"1\":{\"159\":1}}],[\"$4\",{\"1\":{\"158\":1,\"159\":2}}],[\"$3\",{\"1\":{\"158\":1,\"159\":2}}],[\"$0\",{\"1\":{\"158\":2}}],[\"$2\",{\"1\":{\"158\":2,\"159\":2}}],[\"$1\",{\"1\":{\"158\":2,\"159\":2}}],[\"$name\",{\"1\":{\"152\":1,\"154\":1,\"156\":3}}],[\"$\",{\"1\":{\"151\":1,\"152\":4,\"156\":2,\"159\":5,\"162\":5,\"163\":4,\"164\":4}}],[\"格式化字符串\",{\"1\":{\"260\":1,\"324\":1}}],[\"格式化输出\",{\"1\":{\"237\":1}}],[\"格式的数据响应回给浏览器\",{\"1\":{\"198\":1}}],[\"格式\",{\"1\":{\"149\":1,\"162\":1,\"163\":1,\"183\":1}}],[\"每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程\",{\"1\":{\"518\":1}}],[\"每一个\",{\"1\":{\"346\":1}}],[\"每一个节点\",{\"1\":{\"221\":1}}],[\"每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",{\"1\":{\"494\":1}}],[\"每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作\",{\"1\":{\"494\":1}}],[\"每当掌握一个新功能时\",{\"1\":{\"238\":1}}],[\"每次只能通过一个线程\",{\"1\":{\"446\":1}}],[\"每次只有一个线程能够获取对象监视器锁\",{\"1\":{\"391\":1}}],[\"每次重新获取都会对同步状态进行加一的操作\",{\"1\":{\"359\":1}}],[\"每次插入新的行记录时\",{\"1\":{\"182\":1}}],[\"每调用一次就会创建一个新的对象\",{\"1\":{\"324\":1}}],[\"每页显示条数\",{\"1\":{\"198\":1}}],[\"每页显示记录数\",{\"1\":{\"198\":1}}],[\"每行中\",{\"1\":{\"148\":1}}],[\"每个节点拥有其前驱和后继节点\",{\"1\":{\"513\":1}}],[\"每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了\",{\"1\":{\"466\":1}}],[\"每个处理器可以运行一个线程\",{\"1\":{\"414\":1}}],[\"每个线程在原值上累加\",{\"1\":{\"461\":1}}],[\"每个线程都自加\",{\"1\":{\"494\":1}}],[\"每个线程都累加了\",{\"1\":{\"441\":1}}],[\"每个线程都有属于自己的工作内存\",{\"1\":{\"429\":1}}],[\"每个线程都有一个优先级\",{\"1\":{\"422\":1}}],[\"每个线程都会等待前一个线程结束才会继续运行\",{\"1\":{\"420\":1}}],[\"每个对象拥有一个计数器\",{\"1\":{\"443\":1}}],[\"每个对象都包含了数据本身以及元数据\",{\"1\":{\"133\":1}}],[\"每个桶由\",{\"1\":{\"391\":1}}],[\"每个方法都会新增一个带有\",{\"1\":{\"386\":1}}],[\"每个使用\",{\"1\":{\"385\":1}}],[\"每个类可以实现多个接口\",{\"1\":{\"288\":1}}],[\"每个类只能继承一个类\",{\"1\":{\"283\":1}}],[\"每个接口可以继承多个接口\",{\"1\":{\"287\":1}}],[\"每个源文件中\",{\"1\":{\"281\":1}}],[\"每个常用字符都对应一个\",{\"1\":{\"259\":1}}],[\"每个元素均匀的分布在哈希桶数组中\",{\"1\":{\"399\":1}}],[\"每个元素都是大小为4的数组\",{\"1\":{\"255\":1}}],[\"每个元素是含有4个整数的数组\",{\"1\":{\"255\":1}}],[\"每个哈希表的槽位\",{\"1\":{\"226\":1}}],[\"每个子节点也会存储\",{\"1\":{\"221\":1}}],[\"每个参数分别用双引号括起来的字符串\",{\"1\":{\"159\":1}}],[\"每个\",{\"1\":{\"139\":1,\"429\":1}}],[\"每个图表间隔5秒\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"每个城市对应的参数都在该网址\",{\"1\":{\"81\":1,\"88\":1}}],[\"单线程程序是按程序的顺序来执行的\",{\"1\":{\"430\":1,\"432\":1}}],[\"单线程\",{\"1\":{\"430\":1}}],[\"单例模式的定义\",{\"0\":{\"342\":1}}],[\"单例模式\",{\"0\":{\"341\":1}}],[\"单表查询的\",{\"1\":{\"205\":1}}],[\"单精度浮点数值\",{\"1\":{\"183\":1}}],[\"单引号字符串\",{\"1\":{\"156\":1}}],[\"单引号中的内容会原样输出\",{\"1\":{\"156\":1}}],[\"单引号与双引号的区别\",{\"1\":{\"156\":1}}],[\"单引号定义字符串\",{\"1\":{\"151\":1}}],[\"单行注释\",{\"0\":{\"148\":1},\"1\":{\"171\":1}}],[\"单位\",{\"1\":{\"103\":1,\"104\":1,\"107\":2}}],[\"单位有\",{\"1\":{\"76\":1}}],[\"~\",{\"1\":{\"146\":1,\"259\":2,\"422\":1}}],[\"~$\",{\"1\":{\"146\":5,\"155\":5,\"158\":2}}],[\"绝对路径下执行\",{\"1\":{\"146\":1}}],[\"使其能够发挥自身优势\",{\"1\":{\"430\":1}}],[\"使其可用\",{\"1\":{\"385\":1}}],[\"使线程意外终止\",{\"1\":{\"416\":1}}],[\"使得当前线程阻塞\",{\"1\":{\"520\":1}}],[\"使得后继节点的线程能够运行\",{\"1\":{\"513\":1}}],[\"使得该线程阻塞\",{\"1\":{\"517\":1}}],[\"使得该线程进入等待池中\",{\"1\":{\"421\":1}}],[\"使得该节点能够有机会获得\",{\"1\":{\"379\":1}}],[\"使得线程\",{\"1\":{\"380\":1}}],[\"使得多线程技术能够得到重视\",{\"1\":{\"346\":1}}],[\"使得数据的存储和检索更加灵活\",{\"1\":{\"227\":1}}],[\"使脚本具有可执行权限\",{\"1\":{\"146\":1}}],[\"使用同步器的模板方法实现自己的同步语义\",{\"1\":{\"508\":1}}],[\"使用锁时\",{\"1\":{\"448\":1}}],[\"使用了\",{\"1\":{\"399\":1}}],[\"使用了乐观锁\",{\"1\":{\"348\":1}}],[\"使用者可调用方法\",{\"1\":{\"378\":1}}],[\"使用最少线程\",{\"1\":{\"348\":1}}],[\"使用最少的线程和使用协程\",{\"1\":{\"348\":1}}],[\"使用二分查找算法在有序数组arr中查找值\",{\"1\":{\"336\":1}}],[\"使用稳定的快排队数组进行排序\",{\"1\":{\"322\":1}}],[\"使用灵活\",{\"1\":{\"311\":1}}],[\"使用arrays需要import\",{\"1\":{\"257\":1}}],[\"使用数组实现求斐波那契数列的第\",{\"1\":{\"254\":1}}],[\"使用数据库\",{\"0\":{\"177\":1}}],[\"使用final修饰\",{\"1\":{\"233\":1}}],[\"使用聚合函数查询是纵向查询\",{\"1\":{\"195\":1}}],[\"使用变量\",{\"0\":{\"152\":1},\"1\":{\"152\":1}}],[\"使用stream流读取文件\",{\"1\":{\"142\":1}}],[\"使用的存储桶\",{\"1\":{\"139\":1}}],[\"使用公有云的\",{\"1\":{\"133\":1}}],[\"使用上述命令将\",{\"1\":{\"129\":1}}],[\"使用文档\",{\"1\":{\"83\":1,\"90\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"119\":1,\"120\":1}}],[\"使用win+r键输入cmd进入dos界面\",{\"1\":{\"67\":1}}],[\"使用\",{\"0\":{\"27\":1},\"1\":{\"22\":1,\"44\":1,\"52\":1,\"134\":2,\"139\":1,\"153\":1,\"174\":1,\"200\":1,\"329\":2,\"349\":1,\"391\":1,\"399\":1,\"403\":2,\"432\":1,\"443\":1,\"451\":1,\"479\":1,\"484\":1,\"494\":1,\"507\":2,\"517\":1}}],[\"里的死循环\",{\"1\":{\"470\":1}}],[\"里缓存了该内存地址的数据无效\",{\"1\":{\"466\":1}}],[\"里是默认启用的\",{\"1\":{\"456\":1}}],[\"里是否存储着指向当前线程的偏向锁\",{\"1\":{\"454\":1}}],[\"里默认的存放的对象的\",{\"1\":{\"452\":1}}],[\"里到底装了多少东西其实是个不确定的数量\",{\"1\":{\"402\":1}}],[\"里面有\",{\"1\":{\"481\":1}}],[\"里面全是对应的每一个value\",{\"1\":{\"329\":1}}],[\"里面是访问策略\",{\"1\":{\"141\":1}}],[\"里实际运行一遍\",{\"1\":{\"146\":1}}],[\"脚本当前运行的进程id\",{\"1\":{\"159\":1}}],[\"脚本时\",{\"1\":{\"158\":1}}],[\"脚本输出\",{\"1\":{\"146\":4}}],[\"脚本示例\",{\"1\":{\"146\":1}}],[\"脚本有很多种\",{\"1\":{\"146\":1}}],[\"脚本可以直接在命令行中执行\",{\"1\":{\"146\":1}}],[\"概念\",{\"1\":{\"182\":1,\"200\":2}}],[\"概论\",{\"0\":{\"146\":1}}],[\"概述\",{\"0\":{\"132\":1,\"204\":1}}],[\"返回为止\",{\"1\":{\"516\":1}}],[\"返回为\",{\"1\":{\"419\":1}}],[\"返回的是异步执行的结果\",{\"1\":{\"413\":1}}],[\"返回当前获取读锁的次数\",{\"1\":{\"369\":1}}],[\"返回true\",{\"1\":{\"359\":1}}],[\"返回该pair的字符串表示\",{\"1\":{\"337\":1}}],[\"返回该pair的value值\",{\"1\":{\"337\":1}}],[\"返回该pair的key值\",{\"1\":{\"337\":1}}],[\"返回list1中最后一个等于list2的子列表的索引\",{\"1\":{\"336\":1}}],[\"返回list1中第一个等于list2的子列表的索引\",{\"1\":{\"336\":1}}],[\"返回集合中最小的元素\",{\"1\":{\"336\":1}}],[\"返回集合中最大的元素\",{\"1\":{\"336\":1}}],[\"返回a的b次方\",{\"1\":{\"335\":1}}],[\"返回a的绝对值\",{\"1\":{\"335\":1}}],[\"返回a和b的最小值\",{\"1\":{\"335\":1}}],[\"返回a和b的最大值\",{\"1\":{\"335\":1}}],[\"返回值大于等于\",{\"1\":{\"522\":1}}],[\"返回值大于0\",{\"1\":{\"333\":1}}],[\"返回值为栈顶元素e\",{\"1\":{\"330\":1}}],[\"返回值为元素e\",{\"1\":{\"330\":1}}],[\"返回队中元素个数\",{\"1\":{\"331\":1}}],[\"返回队头\",{\"1\":{\"293\":1}}],[\"返回栈中元素个数\",{\"1\":{\"330\":1}}],[\"返回栈顶元素\",{\"1\":{\"292\":1}}],[\"返回出栈元素e\",{\"1\":{\"330\":1}}],[\"返回这个映射的值\",{\"1\":{\"329\":1}}],[\"返回这个映射的键\",{\"1\":{\"329\":1}}],[\"返回map中中键值对<k\",{\"1\":{\"329\":1}}],[\"返回map中key对应的value\",{\"1\":{\"329\":2}}],[\"返回map\",{\"1\":{\"329\":1}}],[\"返回value值\",{\"1\":{\"329\":1}}],[\"返回有序集合中第一个元素\",{\"1\":{\"328\":1}}],[\"返回false\",{\"1\":{\"328\":1,\"359\":1}}],[\"返回动态数组所存元素个数\",{\"1\":{\"327\":1}}],[\"返回元素位置在index的元素e\",{\"1\":{\"327\":1}}],[\"返回元素数\",{\"1\":{\"294\":1,\"295\":1}}],[\"返回之前的内容\",{\"1\":{\"327\":1}}],[\"返回缓冲字符串长度\",{\"1\":{\"325\":1}}],[\"返回index位置的char\",{\"1\":{\"325\":1}}],[\"返回index位置的字符char\",{\"1\":{\"324\":1}}],[\"返回str最后出现的位置\",{\"1\":{\"324\":1}}],[\"返回str第一个出现的位置\",{\"1\":{\"324\":1}}],[\"返回从begin开始后面所有的字符片段\",{\"1\":{\"324\":1}}],[\"返回字符片段\",{\"1\":{\"324\":1}}],[\"返回字符串长度\",{\"1\":{\"324\":1}}],[\"返回与arr类型相同的一个数组\",{\"1\":{\"322\":1}}],[\"返回此\",{\"1\":{\"301\":1}}],[\"返回一个随机数\",{\"1\":{\"335\":1}}],[\"返回一个collection<v>\",{\"1\":{\"329\":1}}],[\"返回一个set\",{\"1\":{\"329\":1}}],[\"返回一个与构建起或缓冲器内容相同的字符串\",{\"1\":{\"325\":1}}],[\"返回一个新的字符串全部转成大写\",{\"1\":{\"324\":1}}],[\"返回一个新的字符串全部转成小写\",{\"1\":{\"324\":1}}],[\"返回一个新字符串string\",{\"1\":{\"324\":1}}],[\"返回一个字符串\",{\"1\":{\"322\":1}}],[\"返回一个包含堆栈层次的数组\",{\"1\":{\"301\":1}}],[\"返回一个\",{\"1\":{\"301\":1}}],[\"返回一个整型值\",{\"1\":{\"265\":1}}],[\"返回关于发生的异常的详细信息\",{\"1\":{\"301\":1}}],[\"返回关键字对应的值\",{\"1\":{\"295\":1}}],[\"返回小于等于key的最大元素\",{\"1\":{\"294\":1,\"295\":1}}],[\"返回大于等于key的最小元素\",{\"1\":{\"294\":1,\"295\":1}}],[\"返回类型为double\",{\"1\":{\"335\":1}}],[\"返回类型和\",{\"0\":{\"274\":1}}],[\"返回类型\",{\"1\":{\"264\":1}}],[\"返回长度\",{\"1\":{\"260\":1,\"291\":1,\"292\":1,\"293\":1}}],[\"返回数组长度\",{\"1\":{\"257\":1}}],[\"返回到上面的while循环中\",{\"1\":{\"401\":1}}],[\"返回到原始状态\",{\"1\":{\"218\":1}}],[\"返回到主页\",{\"1\":{\"81\":1}}],[\"返回\",{\"1\":{\"159\":2,\"260\":1,\"275\":1,\"359\":2,\"420\":1,\"449\":1,\"508\":1,\"517\":1,\"519\":1}}],[\"返回存储桶的列表\",{\"1\":{\"141\":1}}],[\"返回布尔值\",{\"1\":{\"141\":1}}],[\"操作失败\",{\"1\":{\"523\":1}}],[\"操作失败的重试\",{\"1\":{\"518\":1}}],[\"操作失败会在\",{\"1\":{\"516\":1}}],[\"操作失败会继续自旋\",{\"1\":{\"516\":1}}],[\"操作失败后会进行一定的尝试\",{\"1\":{\"449\":1}}],[\"操作重排序\",{\"1\":{\"497\":1}}],[\"操作从工作内存中得到的变量的值放入主内存的变量中\",{\"1\":{\"494\":1}}],[\"操作从主内存中得到的变量值放入工作内存中的变量副本\",{\"1\":{\"494\":1}}],[\"操作将\",{\"1\":{\"459\":1}}],[\"操作将对\",{\"1\":{\"432\":1}}],[\"操作来加锁和解锁\",{\"1\":{\"454\":1}}],[\"操作来确保\",{\"1\":{\"403\":1}}],[\"操作就可以保证其原子性\",{\"1\":{\"451\":1}}],[\"操作一个变量时\",{\"1\":{\"449\":1}}],[\"操作彼此不存在数据依赖性\",{\"1\":{\"433\":1}}],[\"操作之前\",{\"1\":{\"433\":1}}],[\"操作成功返回\",{\"1\":{\"433\":1}}],[\"操作可见\",{\"1\":{\"432\":1}}],[\"操作在不同的线程中执行\",{\"1\":{\"432\":1}}],[\"操作和\",{\"1\":{\"432\":1}}],[\"操作和一次\",{\"1\":{\"423\":1}}],[\"操作和上面的类似\",{\"1\":{\"401\":1}}],[\"操作有这样几个\",{\"1\":{\"409\":1}}],[\"操作直接放入\",{\"1\":{\"399\":1}}],[\"操作设置尾节点\",{\"1\":{\"516\":1}}],[\"操作设置\",{\"1\":{\"395\":1}}],[\"操作依赖于现代处理器指令集\",{\"1\":{\"393\":1}}],[\"操作的执行顺序在\",{\"1\":{\"433\":1}}],[\"操作的结果将对\",{\"1\":{\"432\":1}}],[\"操作的线程安全性\",{\"1\":{\"391\":1}}],[\"操作的注意事项\",{\"1\":{\"188\":1}}],[\"操作符\",{\"1\":{\"212\":1}}],[\"操作\",{\"0\":{\"141\":1,\"142\":1,\"217\":1,\"409\":2,\"447\":1},\"1\":{\"401\":1,\"409\":1,\"423\":1,\"433\":1,\"448\":1,\"494\":2,\"516\":1}}],[\"操作系统会分出一个个时间片\",{\"1\":{\"422\":1}}],[\"操作系统会考虑线程的优先级\",{\"1\":{\"414\":1}}],[\"操作系统会剥夺该线程的运行权\",{\"1\":{\"414\":1}}],[\"操作系统\",{\"0\":{\"7\":1,\"532\":1},\"1\":{\"2\":1}}],[\"那就会继续执行\",{\"1\":{\"520\":1}}],[\"那就只剩下为链表的形式的一种可能性了\",{\"1\":{\"400\":1}}],[\"那如果想阻止重排序要怎么办了\",{\"1\":{\"469\":1}}],[\"那线程\",{\"1\":{\"468\":1}}],[\"那这个对象就是线程安全的\",{\"1\":{\"427\":1}}],[\"那么根据\",{\"1\":{\"520\":1}}],[\"那么根据每个元素的地址值又会找到下面的子节点\",{\"1\":{\"221\":1}}],[\"那么当获取锁失败的时候会调用\",{\"1\":{\"517\":1}}],[\"那么紧接着会有下一个问题\",{\"1\":{\"516\":1}}],[\"那么带头节点的队列初始化时机是什么\",{\"1\":{\"516\":1}}],[\"那么是不是真的就像我们分析的一样了\",{\"1\":{\"516\":1}}],[\"那么如何理解这些指令了\",{\"1\":{\"494\":1}}],[\"那么程序默认会进入轻量级锁状态\",{\"1\":{\"456\":1}}],[\"那么程序员的负担就太重了\",{\"1\":{\"431\":1}}],[\"那么对象的锁怎么理解\",{\"1\":{\"452\":1}}],[\"那么我们能不能让每次通过的速度变快一点了\",{\"1\":{\"446\":1}}],[\"那么共享数据的线程安全问题怎样处理\",{\"1\":{\"441\":1}}],[\"那么编译器可以把这个\",{\"1\":{\"435\":1}}],[\"那么线程\",{\"1\":{\"433\":1,\"487\":1,\"494\":1}}],[\"那么什么情况下\",{\"1\":{\"430\":1}}],[\"那么这个标志就是存放在\",{\"1\":{\"452\":1}}],[\"那么这个正在执行的线程还需要获取该锁吗\",{\"1\":{\"443\":1}}],[\"那么这个锁可以被消除\",{\"1\":{\"435\":1}}],[\"那么这个类就应该被设计为单例类\",{\"1\":{\"342\":1}}],[\"那么这种重排序并不非法\",{\"1\":{\"432\":1}}],[\"那么这张纸条就是这两个线程间通信的共享变量\",{\"1\":{\"428\":1}}],[\"那么在效率上会有一定的提升\",{\"1\":{\"451\":1}}],[\"那么在\",{\"1\":{\"409\":1}}],[\"那么在数据库层面怎么去体现上述两者之间是一对一的关系呢\",{\"1\":{\"201\":1}}],[\"那么使用\",{\"1\":{\"399\":1}}],[\"那么接下来\",{\"1\":{\"399\":1}}],[\"那么怎样确定当前的这个\",{\"1\":{\"399\":1}}],[\"那么怎样根据\",{\"1\":{\"399\":1}}],[\"那么增加了一个\",{\"1\":{\"386\":1}}],[\"那么要想退出这个\",{\"1\":{\"378\":1}}],[\"那么要执行多表查询\",{\"1\":{\"205\":1}}],[\"那么关于这个实现过程\",{\"1\":{\"378\":1}}],[\"那么低\",{\"1\":{\"366\":1}}],[\"那么锁的获取顺序就应该符合请求上的绝对时间顺序\",{\"1\":{\"360\":1}}],[\"那么释放的时候处理思路是怎样的了\",{\"1\":{\"359\":1}}],[\"那么只有锁在被释放同样的\",{\"1\":{\"359\":1}}],[\"那么其他线程必须等待\",{\"1\":{\"354\":1}}],[\"那么其他线程需要这个资源就必须进行等待该资源的释放\",{\"1\":{\"353\":1}}],[\"那么真实系统环境下不能并行\",{\"1\":{\"352\":1}}],[\"那么就存在两种方式\",{\"1\":{\"428\":1}}],[\"那么就按照数值大小以及字典序排序即可\",{\"1\":{\"329\":1}}],[\"那么就得增加树的宽度\",{\"1\":{\"221\":1}}],[\"那么之前产生的子list将会失效\",{\"1\":{\"327\":1}}],[\"那么每个同学就是\",{\"1\":{\"280\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"432\":1}}],[\"那么第三层总元素大小就是\",{\"1\":{\"221\":1}}],[\"那么第二层即第二次\",{\"1\":{\"221\":1}}],[\"那么结合第二层每个元素通过指针域找到第三层的节点\",{\"1\":{\"221\":1}}],[\"那么会找到第三层\",{\"1\":{\"221\":1}}],[\"那么会造成效率极其低下\",{\"1\":{\"221\":1}}],[\"那么可以计算出一个节点可以存储的元素个数\",{\"1\":{\"221\":1}}],[\"那么\",{\"1\":{\"221\":1,\"342\":1,\"349\":1,\"358\":1,\"399\":1,\"428\":1,\"432\":1,\"433\":2,\"441\":2,\"448\":1,\"466\":1,\"479\":1,\"485\":1,\"513\":1}}],[\"那么一个用户有可能需要\",{\"1\":{\"221\":1}}],[\"那么查询\",{\"1\":{\"221\":1}}],[\"那么数据库的所有变化将会被回滚\",{\"1\":{\"218\":1}}],[\"那么数据库的所有变化将生效\",{\"1\":{\"218\":1}}],[\"那么计算结果为0\",{\"1\":{\"195\":1}}],[\"那么有没有线程安全问题呢\",{\"1\":{\"139\":1}}],[\"那曲\",{\"1\":{\"76\":1,\"77\":1}}],[\"链表就转换为红黑树\",{\"1\":{\"399\":1}}],[\"链表长度\",{\"1\":{\"327\":1}}],[\"链表\",{\"1\":{\"327\":1}}],[\"链地址法\",{\"1\":{\"226\":1}}],[\"链式编程\",{\"1\":{\"139\":1}}],[\"链接查看渲染后的题面\",{\"1\":{\"47\":1}}],[\"个语句是原子操作\",{\"1\":{\"494\":1}}],[\"个散列桶\",{\"1\":{\"399\":1}}],[\"个线程进行扩容操作\",{\"1\":{\"393\":1}}],[\"个线程的时候查看\",{\"1\":{\"377\":1}}],[\"个线程\",{\"1\":{\"377\":1,\"420\":1,\"441\":1,\"461\":1,\"494\":1,\"508\":1}}],[\"个以上的内核\",{\"1\":{\"346\":1}}],[\"个数按从小到大的顺序输出\",{\"1\":{\"254\":1}}],[\"个数\",{\"1\":{\"254\":1}}],[\"个数据块\",{\"1\":{\"134\":1}}],[\"个整数逆序输出\",{\"1\":{\"254\":1}}],[\"个整数\",{\"1\":{\"254\":1}}],[\"个元素\",{\"1\":{\"221\":5}}],[\"个指针\",{\"1\":{\"221\":1}}],[\"个\",{\"1\":{\"221\":1,\"403\":1}}],[\"个奇偶校验块\",{\"1\":{\"134\":1}}],[\"个人介绍\",{\"0\":{\"0\":1}}],[\"份奇偶校验块\",{\"1\":{\"134\":1}}],[\"份数据和\",{\"1\":{\"134\":1}}],[\"码作为其纠删码算法\",{\"1\":{\"134\":1}}],[\"纠删码\",{\"1\":{\"134\":1}}],[\"校验和\",{\"1\":{\"134\":1}}],[\"快速集成快速集成使用\",{\"1\":{\"134\":1}}],[\"快用python\",{\"1\":{\"65\":1}}],[\"目的是为了提高获得锁和释放锁的效率\",{\"1\":{\"452\":1}}],[\"目前为止了解即可\",{\"1\":{\"409\":1}}],[\"目前负数没有与之对应的字符\",{\"1\":{\"259\":1}}],[\"目前\",{\"1\":{\"134\":1}}],[\"目录\",{\"0\":{\"3\":1},\"1\":{\"22\":1}}],[\"兼容协议\",{\"1\":{\"134\":1}}],[\"兼容亚马逊\",{\"1\":{\"132\":1}}],[\"亚马逊云的\",{\"1\":{\"134\":1}}],[\"多核的\",{\"1\":{\"346\":1}}],[\"多线程中你真的了解\",{\"0\":{\"485\":1}}],[\"多线程就不能发挥优势\",{\"1\":{\"441\":1}}],[\"多线程情况下可能会出现哪些问题\",{\"1\":{\"434\":1}}],[\"多线程编程中最难以把握的就是临界区线程安全问题\",{\"1\":{\"349\":1}}],[\"多线程技术有这么多的好处\",{\"1\":{\"347\":1}}],[\"多线程\",{\"0\":{\"313\":1}}],[\"多线程与锁\",{\"0\":{\"312\":1}}],[\"多态\",{\"1\":{\"284\":1}}],[\"多维数组就是数组的数组\",{\"1\":{\"255\":1}}],[\"多维数组\",{\"0\":{\"255\":1}}],[\"多层循环\",{\"0\":{\"249\":1}}],[\"多路平衡搜索树\",{\"1\":{\"221\":1}}],[\"多个实例对象\",{\"1\":{\"442\":1}}],[\"多个线程肯定会相互协作完成一件事情\",{\"1\":{\"427\":1}}],[\"多个\",{\"1\":{\"375\":1}}],[\"多个并发的事务之间要相互隔离\",{\"1\":{\"218\":1}}],[\"多个用户并发的访问数据库时\",{\"1\":{\"218\":1}}],[\"多个条件任意一个成立\",{\"1\":{\"194\":1}}],[\"多个条件同时成立\",{\"1\":{\"194\":1}}],[\"多表查询时给表起别名\",{\"1\":{\"207\":1}}],[\"多表查询可以分为\",{\"1\":{\"206\":1}}],[\"多表查询\",{\"0\":{\"203\":1},\"1\":{\"205\":2}}],[\"多表设计\",{\"0\":{\"199\":1}}],[\"多对多的关系在开发中属于也比较常见的\",{\"1\":{\"202\":1}}],[\"多对多\",{\"0\":{\"202\":1},\"1\":{\"199\":1}}],[\"多对一\",{\"1\":{\"199\":1}}],[\"多选一\",{\"1\":{\"194\":1,\"212\":1}}],[\"多行注释\",{\"0\":{\"149\":1},\"1\":{\"171\":1}}],[\"多租户支持\",{\"1\":{\"134\":1}}],[\"多人合作时不会乱成一团\",{\"1\":{\"44\":1}}],[\"号称是目前速度最快的对象存储服务器\",{\"1\":{\"134\":1}}],[\"语义就要求线程在访问读写共享变量时只能\",{\"1\":{\"496\":1}}],[\"语义表示锁在同一时刻只能由一个线程进行获取\",{\"1\":{\"496\":1}}],[\"语义和\",{\"1\":{\"432\":1}}],[\"语义给编写单线程程序的程序员创造了一个幻境\",{\"1\":{\"432\":1}}],[\"语义保证单线程内程序的执行结果不被改变\",{\"1\":{\"432\":1}}],[\"语义是一回事\",{\"1\":{\"432\":1}}],[\"语义使程序员不必担心单线程中重排序的问题干扰他们\",{\"1\":{\"430\":1}}],[\"语义的编译器\",{\"1\":{\"430\":1}}],[\"语义的意思是\",{\"1\":{\"430\":1}}],[\"语义把单线程程序保护了起来\",{\"1\":{\"430\":1}}],[\"语义\",{\"1\":{\"430\":2}}],[\"语句返回值的类型必须与函数的返回类型相同\",{\"1\":{\"276\":1}}],[\"语句都必须返回一个值\",{\"1\":{\"276\":1}}],[\"语句退出循环\",{\"1\":{\"275\":1}}],[\"语句只能用在返回类型是\",{\"1\":{\"275\":1}}],[\"语句有两种形式\",{\"1\":{\"274\":1}}],[\"语句终止当前正在执行的函数并将控制权返回到调用该函数的地方\",{\"1\":{\"274\":1}}],[\"语句负责结束\",{\"1\":{\"265\":1}}],[\"语句类似\",{\"1\":{\"248\":1}}],[\"语句搭配\",{\"1\":{\"247\":1}}],[\"语句限制性循环体后检查条件\",{\"1\":{\"244\":1}}],[\"语句非常相似\",{\"1\":{\"244\":1}}],[\"语句是判断一次\",{\"1\":{\"243\":1}}],[\"语句内部也可以是\",{\"1\":{\"239\":1}}],[\"语句提交一次事务\",{\"1\":{\"217\":1}}],[\"语句全部执行失败\",{\"1\":{\"216\":1}}],[\"语句全部执行成功\",{\"1\":{\"216\":1}}],[\"语句失败\",{\"1\":{\"216\":1}}],[\"语句给数据库执行\",{\"1\":{\"216\":1}}],[\"语句\",{\"0\":{\"239\":1,\"241\":1,\"274\":1},\"1\":{\"205\":1,\"210\":1,\"217\":1,\"239\":2,\"240\":1,\"241\":1,\"243\":1,\"275\":2,\"276\":1,\"281\":2}}],[\"语句中如果不加\",{\"1\":{\"241\":1}}],[\"语句中嵌套\",{\"1\":{\"210\":1}}],[\"语句中表的先后顺序就可以了\",{\"1\":{\"208\":1}}],[\"语句中\",{\"1\":{\"193\":1}}],[\"语句不能删除某一个字段的值\",{\"1\":{\"190\":1}}],[\"语句不区分大小写\",{\"1\":{\"171\":1}}],[\"语句的条件可以有\",{\"1\":{\"190\":1}}],[\"语句根据其功能被分为四大类\",{\"1\":{\"172\":1}}],[\"语句可以省略\",{\"1\":{\"239\":1}}],[\"语句可以使用空格\",{\"1\":{\"171\":1}}],[\"语句可以单行或多行书写\",{\"1\":{\"171\":1}}],[\"语法糖来打开资源\",{\"1\":{\"304\":1}}],[\"语法基础\",{\"0\":{\"232\":1}}],[\"语法如下\",{\"1\":{\"193\":1}}],[\"语法结构如下\",{\"1\":{\"192\":1}}],[\"语法\",{\"0\":{\"145\":1,\"181\":1,\"192\":1,\"222\":1},\"1\":{\"176\":1,\"177\":1,\"178\":1,\"188\":1,\"189\":1,\"190\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"200\":1}}],[\"语言开发的一款高性能的分布式式存储方案的开源项目\",{\"1\":{\"134\":1}}],[\"语音mp3文件\",{\"1\":{\"132\":1}}],[\"语音数据\",{\"1\":{\"132\":1}}],[\"特性是先进先出\",{\"1\":{\"331\":1}}],[\"特别是在面对不理想的数据分布时\",{\"1\":{\"228\":1}}],[\"特别是在冲突解决策略不够高效时\",{\"1\":{\"228\":1}}],[\"特别是应用软件对于系统软件的集中的逻辑\",{\"1\":{\"9\":1}}],[\"特殊的\",{\"1\":{\"158\":1}}],[\"特点\",{\"0\":{\"134\":1}}],[\"当成功释放同步状态之后\",{\"1\":{\"523\":1}}],[\"当该节点的前驱节点是头结点且成功获取同步状态\",{\"1\":{\"522\":1}}],[\"当返回值为大于等于\",{\"1\":{\"522\":1}}],[\"当不满足条件时就会调用\",{\"1\":{\"518\":1}}],[\"当不支持请求的操作时\",{\"1\":{\"300\":1}}],[\"当后继节点的时候会调用\",{\"1\":{\"518\":1}}],[\"当共享资源被某个线程占有\",{\"1\":{\"513\":1}}],[\"当再次获取锁时才能从等待中返回\",{\"1\":{\"505\":1}}],[\"当锁被占用后\",{\"1\":{\"496\":1}}],[\"当锁处于这个状态下\",{\"1\":{\"459\":1}}],[\"当子类继承该父类的时候\",{\"1\":{\"483\":1}}],[\"当重写\",{\"1\":{\"481\":1}}],[\"当父类的方法被\",{\"1\":{\"481\":1}}],[\"当程序中其他地方使用该宏变量的地方\",{\"1\":{\"479\":1}}],[\"当且仅当\",{\"1\":{\"518\":1}}],[\"当且仅当冲突发生的时候再去尝试\",{\"1\":{\"393\":1}}],[\"当且仅有一次赋值\",{\"1\":{\"478\":1}}],[\"当处理器发现本地缓存失效后\",{\"1\":{\"466\":1}}],[\"当处理器发现自己缓存行对应的内存地址被修改\",{\"1\":{\"466\":1}}],[\"当处理器对这个数据进行修改操作的时候\",{\"1\":{\"466\":1}}],[\"当持有锁的线程释放锁之后会唤醒这些线程\",{\"1\":{\"459\":1}}],[\"当对一个共享变量执行操作时\",{\"1\":{\"451\":1}}],[\"当多个线程使用\",{\"1\":{\"449\":1}}],[\"当多个线程访问同一个对象时\",{\"1\":{\"427\":1}}],[\"当这个对象由同步块或者这个对象的同步方法调用时\",{\"1\":{\"443\":1}}],[\"当一个类不希望被继承时就可以使用\",{\"1\":{\"483\":1}}],[\"当一个类被\",{\"1\":{\"483\":1}}],[\"当一个\",{\"1\":{\"423\":1}}],[\"当一个线程访问同步块并获取锁时\",{\"1\":{\"454\":1}}],[\"当一个线程被重新激活\",{\"1\":{\"417\":1}}],[\"当一个线程试图获取一个内部的对象锁\",{\"1\":{\"415\":1}}],[\"当抛出\",{\"1\":{\"419\":1}}],[\"当超时等待时间到达后\",{\"1\":{\"417\":1}}],[\"当超时等待时当前线程不会阻塞\",{\"1\":{\"349\":1}}],[\"当所有其他线程都释放了这个锁\",{\"1\":{\"415\":1}}],[\"当线程获取独占式锁失败后就会将当前线程加入同步队列\",{\"1\":{\"516\":1}}],[\"当线程获取该对象锁后\",{\"1\":{\"443\":1}}],[\"当线程获取\",{\"1\":{\"443\":1}}],[\"当线程获取锁时会从主内存中获取共享变量的最新值\",{\"1\":{\"498\":1}}],[\"当线程获取锁时\",{\"1\":{\"417\":1}}],[\"当线程进入到\",{\"1\":{\"417\":1}}],[\"当线程出现资源竞争时\",{\"1\":{\"417\":1}}],[\"当线程等待另一个线程通知调度器出现某个条件时\",{\"1\":{\"415\":1}}],[\"当线程处于阻塞或等待状态时\",{\"1\":{\"415\":1}}],[\"当线程第一次调用\",{\"1\":{\"378\":1}}],[\"当选择下一个线程时\",{\"1\":{\"414\":1}}],[\"当时间片用完时\",{\"1\":{\"414\":1}}],[\"当我们对\",{\"1\":{\"479\":1}}],[\"当我们调用无参构造器时\",{\"1\":{\"408\":1}}],[\"当我们向二叉查找树保存数据时\",{\"1\":{\"221\":1}}],[\"当要统计全局时\",{\"1\":{\"403\":1}}],[\"当完成数据新节点插入之后\",{\"1\":{\"399\":1}}],[\"当链表长度大于\",{\"1\":{\"403\":1}}],[\"当链表长度太长\",{\"1\":{\"399\":1}}],[\"当链表的长度大于\",{\"1\":{\"399\":1}}],[\"当插入键值对时首先应该定位到要插入的桶\",{\"1\":{\"399\":1}}],[\"当出现哈希冲突的时候\",{\"1\":{\"399\":1}}],[\"当出现异常的运算条件时\",{\"1\":{\"300\":1}}],[\"当第一次向\",{\"1\":{\"397\":1}}],[\"当指定大小为\",{\"1\":{\"397\":1}}],[\"当值为\",{\"1\":{\"393\":1}}],[\"当值为正数时\",{\"1\":{\"393\":1}}],[\"当值为负数时\",{\"1\":{\"393\":1}}],[\"当\",{\"1\":{\"387\":1,\"399\":3,\"401\":1,\"403\":1,\"420\":1,\"443\":1,\"449\":2,\"468\":1,\"477\":1,\"517\":1,\"518\":1,\"523\":1}}],[\"当其他线程释放\",{\"1\":{\"380\":1}}],[\"当退出\",{\"1\":{\"378\":1}}],[\"当写锁被其他线程获取后\",{\"1\":{\"369\":1}}],[\"当读锁已经被读线程获取或者写锁已经被其他写线程获取\",{\"1\":{\"366\":1}}],[\"当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话\",{\"1\":{\"366\":1}}],[\"当货物到达后你收到通知去取就好\",{\"1\":{\"351\":1}}],[\"当被调用的方法完成后会通知调用者\",{\"1\":{\"351\":1}}],[\"当元素超过容量后会扩容\",{\"1\":{\"333\":1}}],[\"当只剩下守护线程时\",{\"1\":{\"315\":1}}],[\"当只有一条语句时\",{\"1\":{\"239\":1}}],[\"当试图使用\",{\"1\":{\"300\":1}}],[\"当试图将对象强制转换为不是实例的子类时\",{\"1\":{\"300\":1}}],[\"当调用构造器方法之后\",{\"1\":{\"397\":1}}],[\"当调用\",{\"1\":{\"300\":1,\"378\":1,\"417\":1,\"507\":1}}],[\"当应用程序试图将字符串转换成一种数值类型\",{\"1\":{\"300\":1}}],[\"当应用程序试图在需要对象的地方使用\",{\"1\":{\"300\":1}}],[\"当局部变量与全局变量重名时\",{\"1\":{\"270\":1}}],[\"当条件成立时\",{\"1\":{\"239\":1}}],[\"当冲突发生时\",{\"1\":{\"226\":1}}],[\"当根节点中可以存储\",{\"1\":{\"221\":1}}],[\"当数据量较大时\",{\"1\":{\"198\":1}}],[\"当进行删除全部数据操作时\",{\"1\":{\"190\":1}}],[\"当前系统时间是\",{\"1\":{\"520\":1}}],[\"当前队列的尾节点不为\",{\"1\":{\"516\":1}}],[\"当前同步队列的尾节点为\",{\"1\":{\"516\":1}}],[\"当前同步队列尾节点为null\",{\"1\":{\"516\":1}}],[\"当前同步状态需要加上\",{\"1\":{\"369\":1}}],[\"当前尾节点是否为null\",{\"1\":{\"516\":1}}],[\"当前节点的前驱节点是头结点并且成功获得同步状态时\",{\"1\":{\"518\":1}}],[\"当前节点所指向的线程能够获取锁\",{\"1\":{\"516\":1}}],[\"当前节点能否获取独占式锁\",{\"1\":{\"516\":1}}],[\"当前节点进入等待队列中\",{\"1\":{\"513\":1}}],[\"当前节点\",{\"1\":{\"513\":2}}],[\"当前节点hash小于0说明为树节点\",{\"1\":{\"400\":1}}],[\"当前时间片用完后就会发生线程调度\",{\"1\":{\"422\":1}}],[\"当前数组中第i个元素为null\",{\"1\":{\"401\":1}}],[\"当前是否正在扩容\",{\"1\":{\"399\":1}}],[\"当前为红黑树\",{\"1\":{\"399\":1}}],[\"当前为链表\",{\"1\":{\"399\":1}}],[\"当前正在扩容\",{\"1\":{\"399\":1}}],[\"当前条件不满足等待\",{\"1\":{\"381\":1}}],[\"当前调用\",{\"1\":{\"379\":1}}],[\"当前写状态是否为0\",{\"1\":{\"367\":1}}],[\"当前线程在超时时间内被中断\",{\"1\":{\"520\":1}}],[\"当前线程成功获取了锁\",{\"1\":{\"520\":1}}],[\"当前线程能够获得锁该方法执行结束退出\",{\"1\":{\"517\":1}}],[\"当前线程可以获取同时将状态更改为\",{\"1\":{\"508\":1}}],[\"当前线程可获取写锁\",{\"1\":{\"366\":1}}],[\"当前线程必须获得了锁才能进行等待\",{\"1\":{\"505\":1}}],[\"当前线程便尝试使用自旋来获取锁\",{\"1\":{\"458\":1}}],[\"当前线程获得锁出队列\",{\"1\":{\"520\":1}}],[\"当前线程获得锁\",{\"1\":{\"458\":1}}],[\"当前线程获取读锁\",{\"1\":{\"369\":1}}],[\"当前线程获取读锁失败返回\",{\"1\":{\"369\":1}}],[\"当前线程获取写锁\",{\"1\":{\"366\":1}}],[\"当前线程获取写锁失败\",{\"1\":{\"366\":1}}],[\"当前线程\",{\"1\":{\"420\":1}}],[\"当前线程是唯一的或是第一个发起扩容的线程\",{\"1\":{\"402\":1}}],[\"当前线程不是唯一的或不是第一个发起扩容的线程\",{\"1\":{\"402\":1}}],[\"当前线程进入到等待状态\",{\"1\":{\"378\":2}}],[\"当前线程进入等待状态直到被通知\",{\"1\":{\"375\":2}}],[\"当前线程进入等待状态\",{\"1\":{\"375\":1}}],[\"当前线程请求资源失败\",{\"1\":{\"360\":1}}],[\"当前页数据列表\",{\"1\":{\"198\":1}}],[\"当前页码\",{\"1\":{\"198\":1}}],[\"当前路径下执行\",{\"1\":{\"146\":1}}],[\"当前源\",{\"1\":{\"22\":1}}],[\"当然在\",{\"1\":{\"451\":1}}],[\"当然也可以选择挂起线程\",{\"1\":{\"449\":1}}],[\"当然也包含表1和表2交集部分的数据\",{\"1\":{\"208\":2}}],[\"当然是根据\",{\"1\":{\"399\":1}}],[\"当然\",{\"1\":{\"133\":1}}],[\"企业可以快速搭建自己的内部对象存储服务\",{\"1\":{\"133\":1}}],[\"利用同步器实现锁的语义\",{\"1\":{\"506\":1}}],[\"利用程序顺序规则\",{\"1\":{\"433\":1}}],[\"利用cas方法更新basecount的值\",{\"1\":{\"402\":1}}],[\"利用cas锁进行更新\",{\"1\":{\"402\":1}}],[\"利用红黑树快速增删改查的特点提高\",{\"1\":{\"399\":1}}],[\"利用\",{\"1\":{\"133\":1,\"348\":1,\"395\":1,\"479\":1,\"484\":1}}],[\"腾讯云对象存储\",{\"1\":{\"133\":1}}],[\"进一步知道了\",{\"1\":{\"441\":1}}],[\"进一步减小了锁粒度\",{\"1\":{\"403\":1}}],[\"进一步说明\",{\"1\":{\"377\":1}}],[\"进去看是不是符合我们的猜想\",{\"1\":{\"377\":1}}],[\"进行入队操作\",{\"1\":{\"518\":1}}],[\"进行重试\",{\"1\":{\"516\":1}}],[\"进行等待时会先释放锁\",{\"1\":{\"505\":1}}],[\"进行了重排序的话\",{\"1\":{\"497\":1}}],[\"进行访问就可以出现这样的操作顺序\",{\"1\":{\"494\":1}}],[\"进行下一次尝试\",{\"1\":{\"451\":1}}],[\"进行通信\",{\"1\":{\"445\":1}}],[\"进行加一的操作\",{\"1\":{\"494\":1}}],[\"进行加一操作后\",{\"1\":{\"445\":1}}],[\"进行加一\",{\"1\":{\"444\":1}}],[\"进行加锁的时候线程切换的是\",{\"1\":{\"417\":1}}],[\"进行获取\",{\"1\":{\"443\":1}}],[\"进行同步\",{\"1\":{\"443\":1}}],[\"进行包装然后\",{\"1\":{\"413\":1}}],[\"进行扩容\",{\"1\":{\"401\":1}}],[\"进行一次\",{\"1\":{\"399\":1}}],[\"进行初始化\",{\"1\":{\"399\":1}}],[\"进行判断\",{\"1\":{\"398\":1,\"497\":1}}],[\"进行再一次封装\",{\"1\":{\"394\":1}}],[\"进行修饰的\",{\"1\":{\"394\":1}}],[\"进行线程安全的控制\",{\"1\":{\"391\":1}}],[\"进行纵向计算\",{\"1\":{\"195\":1}}],[\"进行数据读写\",{\"1\":{\"133\":1}}],[\"进入终端\",{\"1\":{\"128\":1}}],[\"进入到\",{\"1\":{\"128\":1,\"443\":1}}],[\"进入选择安装方式\",{\"1\":{\"67\":1}}],[\"进入网址后\",{\"1\":{\"45\":1}}],[\"进入\",{\"1\":{\"22\":1}}],[\"或停止自旋\",{\"1\":{\"518\":1}}],[\"或多或少是由于硬件设计者无计可施了导致的\",{\"1\":{\"346\":1}}],[\"或实例\",{\"1\":{\"342\":1}}],[\"或从小到大\",{\"1\":{\"221\":1}}],[\"或\",{\"1\":{\"133\":1,\"146\":1,\"194\":4,\"240\":1}}],[\"或者能够确保只有一个线程修改变量的值\",{\"1\":{\"494\":1}}],[\"或者能隐式地转换函数的返回类型\",{\"1\":{\"276\":1}}],[\"或者在调用方进行任何其他的协调操作\",{\"1\":{\"427\":1}}],[\"或者在等待时被中断会做中断处理\",{\"1\":{\"378\":1}}],[\"或者是字符串\",{\"1\":{\"329\":1}}],[\"或者超出字符串的大小\",{\"1\":{\"300\":1}}],[\"或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程\",{\"1\":{\"300\":1}}],[\"或者\",{\"1\":{\"55\":1,\"152\":1,\"153\":1,\"194\":1,\"364\":1,\"380\":1,\"417\":1,\"430\":1}}],[\"它将一些方法开放给子类进行重写\",{\"1\":{\"507\":1}}],[\"它将变成非阻塞状态\",{\"1\":{\"415\":1}}],[\"它简化了锁的实现方式\",{\"1\":{\"506\":1}}],[\"它定义了使用者与锁交互的接口\",{\"1\":{\"506\":1}}],[\"它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用\",{\"1\":{\"506\":1}}],[\"它仅仅保存的是一个引用\",{\"1\":{\"479\":1}}],[\"它提供了与\",{\"1\":{\"504\":1}}],[\"它把工作内存中一个变量的值传送给主内存中以便随后的\",{\"1\":{\"494\":1}}],[\"它把工作内存中一个变量的值传递给执行引擎\",{\"1\":{\"494\":1}}],[\"它把\",{\"1\":{\"494\":2}}],[\"它把一个从执行引擎接收到的值赋给工作内存的变量\",{\"1\":{\"494\":1}}],[\"它把一个变量的值从主内存传输到线程的工作内存中\",{\"1\":{\"494\":1}}],[\"它把一个变量标识为一个线程独占的状态\",{\"1\":{\"494\":1}}],[\"它把一个处于锁定状态的变量释放出来\",{\"1\":{\"494\":1}}],[\"它假设所有线程访问共享资源的时候不会出现冲突\",{\"1\":{\"448\":1}}],[\"它最大的特征就是在同一时刻只有一个线程能够获得对象的监视器\",{\"1\":{\"446\":1}}],[\"它避免\",{\"1\":{\"436\":1}}],[\"它会首先暂停拥有偏向锁的线程\",{\"1\":{\"455\":1}}],[\"它会完成整个系统的业务操作\",{\"1\":{\"423\":1}}],[\"它会使当前线程让出\",{\"1\":{\"422\":1}}],[\"它不一定始终保持运行\",{\"1\":{\"414\":1}}],[\"它的子类必须重写\",{\"1\":{\"506\":1}}],[\"它的实现主要依赖一个\",{\"1\":{\"506\":1}}],[\"它的容量是原来的两倍\",{\"1\":{\"401\":1}}],[\"它的每个元素是含有20个数组的数组\",{\"1\":{\"255\":1}}],[\"它们之间执行顺序可以重排序\",{\"1\":{\"430\":1}}],[\"它们之间的关系可以用下面一个图来表现得更加贴切\",{\"1\":{\"380\":1}}],[\"它们都是独占式获取锁\",{\"1\":{\"364\":1}}],[\"它们属于类相关的概念\",{\"1\":{\"265\":1}}],[\"它强调没有一个线程可以阻塞其他线程\",{\"1\":{\"353\":1}}],[\"它只是基于认为观测数据后\",{\"1\":{\"346\":1}}],[\"它表示了一个运行中的线程是否被其他线程进行了中断操作\",{\"1\":{\"419\":1}}],[\"它表示了该键在哈希表中存储的位置\",{\"1\":{\"226\":1}}],[\"它表示函数不返回任何值\",{\"1\":{\"269\":1}}],[\"它作用于一个整型参数\",{\"1\":{\"265\":1}}],[\"它对数据库中的数据的改变就是永久的\",{\"1\":{\"218\":1}}],[\"它对数据库的改变将是永久性的\",{\"1\":{\"218\":1}}],[\"它是系统的守护者\",{\"1\":{\"423\":1}}],[\"它是暂时不活动的\",{\"1\":{\"415\":1}}],[\"它是一个不可变类\",{\"1\":{\"474\":1}}],[\"它是一个不可分割的工作单位\",{\"1\":{\"216\":1}}],[\"它是一个可交互性的网页\",{\"1\":{\"85\":1}}],[\"它是对一列的值进行计算\",{\"1\":{\"195\":1}}],[\"它以对象为单位来处理\",{\"1\":{\"133\":1}}],[\"非阻塞式响应中断能立即返回\",{\"1\":{\"505\":1}}],[\"非公平锁\",{\"1\":{\"360\":1}}],[\"非空返回true\",{\"1\":{\"332\":1}}],[\"非空约束\",{\"1\":{\"182\":1}}],[\"非结构性修改\",{\"1\":{\"327\":1}}],[\"非结构化数据\",{\"1\":{\"132\":1}}],[\"非检查性异常\",{\"1\":{\"300\":1}}],[\"非运行时异常是\",{\"1\":{\"299\":1}}],[\"非静态成员变量\",{\"1\":{\"270\":1}}],[\"非叶子节点都是由\",{\"1\":{\"221\":1}}],[\"非叶子节点\",{\"1\":{\"221\":2}}],[\"非\",{\"1\":{\"194\":1,\"240\":1}}],[\"非常方便\",{\"1\":{\"139\":1}}],[\"非常方便使用\",{\"1\":{\"134\":1}}],[\"非常适合存储大容量的数据\",{\"1\":{\"132\":1}}],[\"电影\",{\"1\":{\"132\":1}}],[\"视频数据\",{\"1\":{\"132\":1}}],[\"各个线程会将共享变量从主内存中拷贝到工作内存\",{\"1\":{\"465\":1}}],[\"各种锁的比较\",{\"0\":{\"460\":1}}],[\"各种视频\",{\"1\":{\"132\":1}}],[\"各种图片\",{\"1\":{\"132\":1}}],[\"各省份平均工资\",{\"1\":{\"104\":1,\"107\":1}}],[\"图中每一个箭头两个节点就代码一个\",{\"1\":{\"467\":1}}],[\"图片摘自网络\",{\"1\":{\"401\":1}}],[\"图像数据\",{\"1\":{\"132\":1}}],[\"图木舒克\",{\"1\":{\"76\":1,\"77\":1}}],[\"音频形式存储的数据\",{\"1\":{\"132\":1}}],[\"社交媒体文章\",{\"1\":{\"132\":1}}],[\"社区版\",{\"1\":{\"68\":1}}],[\"卸载服务\",{\"1\":{\"129\":1}}],[\"搭建自己专属的对象存储服务器\",{\"1\":{\"133\":1}}],[\"搭建\",{\"1\":{\"129\":1}}],[\"管理后台\",{\"1\":{\"128\":1}}],[\"管理计算资源和网络通信\",{\"1\":{\"9\":1}}],[\"登录\",{\"1\":{\"128\":1}}],[\"容量为之前的两倍\",{\"1\":{\"401\":1}}],[\"容量不足的时候\",{\"1\":{\"401\":1}}],[\"容易引发数据库的死锁问题\",{\"1\":{\"200\":1}}],[\"容易出现依赖冲突\",{\"1\":{\"23\":1}}],[\"容器化\",{\"1\":{\"134\":1}}],[\"容器\",{\"1\":{\"127\":1}}],[\"启动线程b\",{\"1\":{\"433\":1}}],[\"启动\",{\"1\":{\"127\":1,\"128\":1}}],[\"拉链转换成红黑树\",{\"1\":{\"399\":1}}],[\"拉链法\",{\"1\":{\"399\":1}}],[\"拉取\",{\"1\":{\"127\":1}}],[\"拉萨\",{\"1\":{\"76\":1,\"77\":1}}],[\"镜像\",{\"1\":{\"127\":2}}],[\"无任何引用方便\",{\"1\":{\"517\":1}}],[\"无非就是类似对对象的一个标志\",{\"1\":{\"452\":1}}],[\"无非就是一个死循环\",{\"1\":{\"451\":1}}],[\"无锁状态\",{\"1\":{\"452\":1}}],[\"无锁操作是使用\",{\"1\":{\"448\":1}}],[\"无锁操作以保证\",{\"1\":{\"391\":1}}],[\"无锁并发编程\",{\"1\":{\"348\":1}}],[\"无返回值函数\",{\"0\":{\"275\":1}}],[\"无法结束\",{\"1\":{\"243\":1}}],[\"无符号\",{\"1\":{\"183\":1}}],[\"无论是标准输出还是错误输出\",{\"1\":{\"126\":1}}],[\"无锡\",{\"1\":{\"76\":1,\"77\":1}}],[\"重新计算超时时间\",{\"1\":{\"520\":1}}],[\"重新调整堆\",{\"1\":{\"333\":1}}],[\"重载\",{\"0\":{\"482\":1}}],[\"重排序的总结\",{\"1\":{\"488\":1}}],[\"重排序到构造函数之外\",{\"1\":{\"487\":1}}],[\"重排序规则表\",{\"1\":{\"469\":1}}],[\"重排序在多线程中不注意的话也容易存在一些问题\",{\"1\":{\"437\":1}}],[\"重排序可以分为两类\",{\"1\":{\"435\":1}}],[\"重排序以及\",{\"1\":{\"435\":1}}],[\"重排序\",{\"0\":{\"430\":1}}],[\"重写方法\",{\"1\":{\"508\":1}}],[\"重写的\",{\"1\":{\"507\":1}}],[\"重写\",{\"0\":{\"481\":1},\"1\":{\"413\":1}}],[\"重hash\",{\"1\":{\"400\":1}}],[\"重哈希\",{\"1\":{\"399\":1}}],[\"重点方法讲解\",{\"0\":{\"396\":1}}],[\"重量级锁\",{\"1\":{\"391\":1}}],[\"重入性\",{\"1\":{\"364\":1}}],[\"重入性的实现了\",{\"1\":{\"359\":1}}],[\"重入性的实现原理\",{\"0\":{\"359\":1},\"1\":{\"358\":1}}],[\"重入锁的释放必须得等到同步状态为\",{\"1\":{\"359\":1}}],[\"重入锁\",{\"1\":{\"358\":1}}],[\"重启之后数据亦然存在\",{\"1\":{\"218\":1}}],[\"重命名为\",{\"1\":{\"129\":1}}],[\"重定向到标准输出\",{\"1\":{\"126\":1}}],[\"重定向到\",{\"1\":{\"126\":1}}],[\"重庆\",{\"1\":{\"76\":2,\"77\":2}}],[\"重庆市\",{\"1\":{\"76\":1,\"77\":1}}],[\"该同步组件只能在同一时刻被线程占用\",{\"1\":{\"508\":1}}],[\"该组件已经被线程占用返回\",{\"1\":{\"508\":1}}],[\"该代码依然存在线程安全的问题\",{\"1\":{\"490\":1}}],[\"该代码的\",{\"1\":{\"444\":1}}],[\"该对象的\",{\"1\":{\"488\":1,\"490\":1}}],[\"该实例的实例变量是不可改变的\",{\"1\":{\"484\":1}}],[\"该实参能自动转换成int类型\",{\"1\":{\"267\":1}}],[\"该初始值在编译时就能够唯一指定\",{\"1\":{\"479\":1}}],[\"该变量就会成为一个\",{\"1\":{\"479\":1}}],[\"该怎么办了\",{\"1\":{\"468\":1}}],[\"该线程就进入同步状态\",{\"1\":{\"443\":1}}],[\"该线程就会被阻塞\",{\"1\":{\"415\":1}}],[\"该图可以看出\",{\"1\":{\"443\":1}}],[\"该节点\",{\"1\":{\"408\":1}}],[\"该构造器源码为\",{\"1\":{\"397\":1}}],[\"该成员变量的获取是在静态代码块中\",{\"1\":{\"393\":1}}],[\"该属性用来控制\",{\"1\":{\"393\":1}}],[\"该类提供了一些可以直接操控内存和线程的底层操作\",{\"1\":{\"393\":1}}],[\"该类基本上所有的方法都采用\",{\"1\":{\"391\":1}}],[\"该类的方法并不是很多\",{\"1\":{\"385\":1}}],[\"该类是\",{\"1\":{\"377\":1,\"409\":1}}],[\"该方法源码如下\",{\"1\":{\"520\":1}}],[\"该方法源码为\",{\"1\":{\"366\":1,\"378\":1,\"379\":2}}],[\"该方法是用来阻塞当前线程的\",{\"1\":{\"517\":1}}],[\"该方法是获取读锁被获取的次数\",{\"1\":{\"366\":1}}],[\"该方法在上面已经讲过了\",{\"1\":{\"399\":1}}],[\"该方法主要是将\",{\"1\":{\"399\":1}}],[\"该方法会调用\",{\"1\":{\"520\":1}}],[\"该方法会在三种情况下才会返回\",{\"1\":{\"520\":1}}],[\"该方法会唤醒该节点的后继节点所包装的线程\",{\"1\":{\"518\":1}}],[\"该方法会唤醒在同步队列中的下一个节点\",{\"1\":{\"512\":1}}],[\"该方法会清除中断标志位\",{\"1\":{\"419\":1}}],[\"该方法会将调用构造器方法时指定的大小转换成一个\",{\"1\":{\"397\":1}}],[\"该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列\",{\"1\":{\"379\":1}}],[\"该方法用来设置\",{\"1\":{\"395\":1}}],[\"该方法用来获取\",{\"1\":{\"395\":1}}],[\"该方法只不过是将等待队列中的每一个节点都移入到同步队列中\",{\"1\":{\"379\":1}}],[\"该方法的关键是会调用\",{\"1\":{\"517\":1}}],[\"该方法的源码为\",{\"1\":{\"378\":1,\"517\":1,\"522\":1}}],[\"该方法的作用是在自旋过程中线程不断尝试获取同步状态\",{\"1\":{\"378\":1}}],[\"该方法相较于前面\",{\"1\":{\"95\":1}}],[\"该锁未完全释放返回\",{\"1\":{\"359\":1}}],[\"该锁能被当前线程获取\",{\"1\":{\"359\":1}}],[\"该锁才算是完全释放成功\",{\"1\":{\"359\":1}}],[\"该干嘛就干嘛去了\",{\"1\":{\"351\":1}}],[\"该注解只能用于函数\",{\"1\":{\"307\":2}}],[\"该行不会被统计在其中\",{\"1\":{\"195\":1}}],[\"该命令也会继续执行\",{\"1\":{\"126\":1}}],[\"信息\",{\"1\":{\"394\":1}}],[\"信号的线程\",{\"1\":{\"413\":1}}],[\"信号\",{\"1\":{\"126\":1}}],[\"信阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"命令执行效果如下\",{\"1\":{\"178\":1}}],[\"命令注册系统服务\",{\"1\":{\"129\":1}}],[\"命令\",{\"1\":{\"126\":1}}],[\"命令解释\",{\"1\":{\"126\":2,\"169\":1}}],[\">3c\",{\"1\":{\"451\":1}}],[\">2b\",{\"1\":{\"451\":1}}],[\">a\",{\"1\":{\"430\":1,\"451\":1}}],[\">c\",{\"1\":{\"430\":2}}],[\">b\",{\"1\":{\"430\":1,\"451\":1}}],[\">>>\",{\"1\":{\"366\":1,\"397\":7,\"398\":2,\"399\":1,\"401\":4,\"402\":1}}],[\">=\",{\"1\":{\"194\":1,\"239\":6,\"240\":4,\"254\":1,\"397\":2,\"399\":5,\"401\":5,\"402\":2,\"522\":1}}],[\">\",{\"1\":{\"126\":2,\"129\":1,\"141\":1,\"142\":1,\"194\":1,\"196\":2,\"239\":11,\"254\":1,\"276\":1,\"277\":2,\"310\":2,\"324\":2,\"366\":1,\"370\":1,\"377\":1,\"379\":1,\"387\":1,\"398\":2,\"399\":1,\"400\":1,\"401\":4,\"402\":1,\"445\":2,\"508\":1,\"517\":2,\"518\":1,\"520\":1}}],[\"最熟悉的\",{\"1\":{\"505\":1}}],[\"最新值为\",{\"1\":{\"470\":1}}],[\"最终正确的结果为\",{\"1\":{\"461\":1}}],[\"最主要的问题是\",{\"1\":{\"449\":1}}],[\"最常用的也应该是\",{\"1\":{\"399\":1}}],[\"最常见的是\",{\"1\":{\"210\":1}}],[\"最长不超过\",{\"1\":{\"386\":1}}],[\"最长不会超过50\",{\"1\":{\"183\":1}}],[\"最小\",{\"1\":{\"333\":1}}],[\"最小值\",{\"1\":{\"195\":1}}],[\"最后唤醒暂停的线程\",{\"1\":{\"455\":1}}],[\"最后用一个示意图来进行总结\",{\"1\":{\"401\":1}}],[\"最后将\",{\"1\":{\"397\":1}}],[\"最后定义类\",{\"1\":{\"281\":1}}],[\"最后一个元素\",{\"1\":{\"328\":1}}],[\"最后一个元素代表方法调用堆栈的栈底\",{\"1\":{\"301\":1}}],[\"最后一个字段后面没有逗号\",{\"1\":{\"181\":1}}],[\"最后一页的下一页的标签为\",{\"1\":{\"92\":1}}],[\"最重要的是理解代码的执行顺序\",{\"1\":{\"263\":1}}],[\"最大\",{\"1\":{\"333\":1}}],[\"最大的问题就是在数据量大的情况下\",{\"1\":{\"221\":1}}],[\"最大值\",{\"1\":{\"194\":1,\"195\":1}}],[\"最简单的形式\",{\"1\":{\"211\":1}}],[\"最简单的\",{\"1\":{\"126\":1}}],[\"控制不同线程间操作发生的相对顺序\",{\"1\":{\"429\":1}}],[\"控制当走到第\",{\"1\":{\"377\":1}}],[\"控制数据库的访问权限\",{\"1\":{\"172\":1}}],[\"控制台的监听地址和端口\",{\"1\":{\"126\":1}}],[\"控制表格位置\",{\"1\":{\"105\":2}}],[\"服务进行配置和操作\",{\"1\":{\"139\":1}}],[\"服务器地址和端口\",{\"1\":{\"139\":1}}],[\"服务器\",{\"1\":{\"126\":1,\"128\":1,\"129\":1,\"134\":1,\"169\":2}}],[\"服务器的所有正常输出\",{\"1\":{\"126\":1}}],[\"服务\",{\"1\":{\"126\":1,\"128\":1,\"129\":1,\"133\":2}}],[\"所示\",{\"1\":{\"507\":1}}],[\"所修饰的\",{\"1\":{\"481\":1}}],[\"所读取到的\",{\"1\":{\"444\":1}}],[\"所有线程均可访问到\",{\"1\":{\"428\":1}}],[\"所有现代桌面和服务器操作系统都是用抢占式调度\",{\"1\":{\"414\":1}}],[\"所有counter的值求和\",{\"1\":{\"402\":1}}],[\"所有调用\",{\"1\":{\"377\":1}}],[\"所有获取锁失败的线程的尾插入到同步队列\",{\"1\":{\"377\":1}}],[\"所有普通成员变量\",{\"1\":{\"282\":1}}],[\"所有\",{\"1\":{\"282\":1}}],[\"所有对象均可以访问\",{\"1\":{\"282\":1}}],[\"所有具有相同哈希值的元素都存储在这个链表中\",{\"1\":{\"226\":1}}],[\"所有的操作都是无序的\",{\"1\":{\"497\":1}}],[\"所有的操作都是有序的\",{\"1\":{\"497\":1}}],[\"所有的读线程和其他的写线程都会被阻塞\",{\"1\":{\"364\":1}}],[\"所有的线程都会尝试地往前运行\",{\"1\":{\"353\":1}}],[\"所有的数据都存储在叶子节点上\",{\"1\":{\"221\":2}}],[\"所有的\",{\"1\":{\"216\":1}}],[\"所查询到的数据列表\",{\"1\":{\"198\":1}}],[\"所谓约束就是作用在表中字段上的规则\",{\"1\":{\"182\":1}}],[\"所在的目录\",{\"1\":{\"128\":1}}],[\"所在目录下启动\",{\"1\":{\"126\":1}}],[\"所以当其他线程尝试竞争偏向锁时\",{\"1\":{\"455\":1}}],[\"所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁\",{\"1\":{\"448\":1}}],[\"所以不能将新值\",{\"1\":{\"449\":1}}],[\"所以将释放资源等操作不要放在\",{\"1\":{\"423\":1}}],[\"所以要复杂的多\",{\"1\":{\"401\":1}}],[\"所以等待队列的头节点必然会是等待时间最长的节点\",{\"1\":{\"379\":1}}],[\"所以在\",{\"1\":{\"348\":1,\"489\":1}}],[\"所以\",{\"1\":{\"348\":1,\"349\":1,\"466\":1,\"489\":1,\"513\":1}}],[\"所以此时对形参的修改会影响实参的初始值\",{\"1\":{\"273\":1}}],[\"所以该操作等价于fact\",{\"1\":{\"267\":1}}],[\"所以该网站不能像前面俩一样爬取\",{\"1\":{\"95\":1}}],[\"所以一个第三层一个节点大概可以存储\",{\"1\":{\"221\":1}}],[\"所以为了减少红黑树的高度\",{\"1\":{\"221\":1}}],[\"所以各个表结构之间也存在着各种联系\",{\"1\":{\"199\":1}}],[\"所以接下来讲解\",{\"1\":{\"146\":1}}],[\"所以基于对象的形式\",{\"1\":{\"133\":1}}],[\"所以我们可以通过chromiumpage\",{\"1\":{\"96\":1}}],[\"所以我们使用\",{\"1\":{\"85\":1,\"92\":1}}],[\"所以对应的url\",{\"1\":{\"82\":1}}],[\"指令开放给我们使用\",{\"1\":{\"494\":1}}],[\"指令肯定有神奇的地方\",{\"1\":{\"466\":1}}],[\"指令\",{\"1\":{\"443\":3,\"451\":1,\"498\":1}}],[\"指令级并行的重排序\",{\"1\":{\"430\":1}}],[\"指令后\",{\"1\":{\"409\":1}}],[\"指令实现\",{\"1\":{\"393\":1,\"449\":1}}],[\"指向的头结点不为\",{\"1\":{\"518\":1}}],[\"指向刚分配的内存地址\",{\"1\":{\"497\":1}}],[\"指向同一个节点\",{\"1\":{\"408\":1}}],[\"指向当前的\",{\"1\":{\"378\":1}}],[\"指向它\",{\"1\":{\"324\":2}}],[\"指的是单线程程序和正确同步的多线程程序\",{\"1\":{\"432\":1,\"435\":1}}],[\"指的是\",{\"1\":{\"351\":1}}],[\"指的是你将要放置你的项目所在的文件路径\",{\"1\":{\"22\":1}}],[\"指示索引或者为负\",{\"1\":{\"300\":1}}],[\"指示存在安全侵犯\",{\"1\":{\"300\":1}}],[\"指示某排序索引\",{\"1\":{\"300\":1}}],[\"指针会指向一个\",{\"1\":{\"408\":1}}],[\"指针引用新的\",{\"1\":{\"394\":1}}],[\"指针域\",{\"1\":{\"221\":1}}],[\"指针\",{\"1\":{\"221\":1,\"393\":1,\"408\":1}}],[\"指明\",{\"1\":{\"146\":1}}],[\"指定容量的空数组列表\",{\"1\":{\"327\":1}}],[\"指定注解可以用在哪些地方\",{\"1\":{\"308\":1}}],[\"指定注解的作用范围\",{\"1\":{\"308\":1}}],[\"指定列下相同的数据归为一类\",{\"1\":{\"196\":1}}],[\"指定的顺序来执行的\",{\"1\":{\"432\":1}}],[\"指定的字段顺序需要与值的顺序是一一对应的\",{\"1\":{\"188\":1}}],[\"指定的长度为最大占用长度\",{\"1\":{\"183\":1}}],[\"指定字段\",{\"1\":{\"188\":1}}],[\"指定长度多长\",{\"1\":{\"183\":1}}],[\"指定文件路径\",{\"1\":{\"142\":1}}],[\"指定\",{\"1\":{\"126\":1}}],[\"指定数据存放位置\",{\"1\":{\"126\":1}}],[\"指定minio密码\",{\"1\":{\"126\":1}}],[\"指定minio的用户名\",{\"1\":{\"126\":1}}],[\"岗位技能词云\",{\"1\":{\"119\":1,\"121\":1}}],[\"岗位词云统计\",{\"0\":{\"117\":1},\"1\":{\"120\":1,\"121\":1}}],[\"词云图\",{\"0\":{\"119\":1},\"2\":{\"124\":1}}],[\"词云\",{\"1\":{\"118\":1}}],[\"饼图\",{\"0\":{\"112\":1},\"2\":{\"124\":1}}],[\"纵向排列\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"纵坐标\",{\"1\":{\"103\":1,\"104\":1}}],[\"9是\",{\"1\":{\"259\":1}}],[\"90\",{\"1\":{\"259\":1}}],[\"9000\",{\"1\":{\"127\":2,\"128\":1,\"139\":1}}],[\"9001\",{\"1\":{\"126\":3,\"127\":3,\"128\":1}}],[\"900px\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1}}],[\"9\",{\"0\":{\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":1,\"303\":1,\"304\":1},\"1\":{\"245\":1,\"255\":1,\"256\":1}}],[\"9999\",{\"1\":{\"183\":2}}],[\"967\",{\"1\":{\"183\":2}}],[\"9616\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"9e0ebfcd82d7\",{\"1\":{\"146\":5,\"155\":5,\"158\":2}}],[\"9<\",{\"1\":{\"138\":1}}],[\"6版本关键要素\",{\"1\":{\"391\":1}}],[\"66\",{\"1\":{\"259\":1}}],[\"6\",{\"0\":{\"156\":1,\"197\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"207\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"214\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":2,\"271\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"302\":1,\"402\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":1,\"422\":1,\"434\":1,\"435\":1,\"436\":1,\"437\":1,\"470\":1,\"490\":1},\"1\":{\"134\":3,\"221\":1,\"235\":1,\"239\":1,\"241\":1,\"245\":1,\"255\":1,\"256\":1,\"386\":1,\"391\":1,\"399\":2,\"412\":1,\"420\":1,\"444\":1,\"452\":1,\"456\":1,\"488\":1,\"508\":1}}],[\"60\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"239\":1}}],[\"60000\",{\"1\":{\"101\":1,\"107\":1}}],[\"65535\",{\"1\":{\"183\":2}}],[\"65\",{\"1\":{\"105\":1,\"107\":1,\"183\":2}}],[\"柱状图\",{\"0\":{\"104\":1},\"2\":{\"124\":1}}],[\"展示了偏向锁撤销的过程\",{\"1\":{\"455\":1}}],[\"展示了偏向锁获取的过程\",{\"1\":{\"455\":1}}],[\"展示所有数据中最大的一项\",{\"1\":{\"103\":1}}],[\"展开所有代码\",{\"1\":{\"71\":1}}],[\"展开当前代码s\",{\"1\":{\"71\":1}}],[\"横坐标\",{\"1\":{\"103\":1,\"104\":1}}],[\"折线图\",{\"0\":{\"103\":1},\"2\":{\"124\":1}}],[\"折叠所有代码\",{\"1\":{\"71\":1}}],[\"折叠当前代码\",{\"1\":{\"71\":1}}],[\"折叠\",{\"1\":{\"71\":1}}],[\"相同时\",{\"1\":{\"449\":1}}],[\"相同的节点\",{\"1\":{\"399\":2}}],[\"相同\",{\"1\":{\"393\":1,\"399\":1}}],[\"相同返回true\",{\"1\":{\"324\":1}}],[\"相较于\",{\"1\":{\"391\":1,\"519\":1}}],[\"相对于武断而直接的结束线程\",{\"1\":{\"419\":1}}],[\"相对于\",{\"1\":{\"391\":1}}],[\"相对来说\",{\"1\":{\"183\":1}}],[\"相与\",{\"1\":{\"366\":1}}],[\"相当于\",{\"1\":{\"401\":1}}],[\"相当于每个\",{\"1\":{\"377\":1}}],[\"相当于给了key在map中的一个初试值\",{\"1\":{\"329\":1}}],[\"相当于返回原数组的一个片段\",{\"1\":{\"327\":1}}],[\"相当于子查询结果是一张表\",{\"1\":{\"210\":1}}],[\"相当于查询\",{\"1\":{\"206\":1}}],[\"相当于文件\",{\"1\":{\"139\":1}}],[\"相当于存放文件的顶层文件夹\",{\"1\":{\"139\":1}}],[\"相当于横纵坐标\",{\"1\":{\"102\":1}}],[\"相关的一些方法\",{\"0\":{\"402\":1}}],[\"相关联的\",{\"1\":{\"378\":1}}],[\"相关信息\",{\"1\":{\"67\":1,\"68\":1}}],[\"相关配置文档请见\",{\"1\":{\"1\":1}}],[\"若检测出被中断直接抛出被中断异常\",{\"1\":{\"520\":1}}],[\"若失败则先调用\",{\"1\":{\"515\":1}}],[\"若失败的话就抛出异常\",{\"1\":{\"378\":1}}],[\"若没有找到就返回\",{\"1\":{\"400\":1}}],[\"若找到则返回节点的\",{\"1\":{\"400\":1}}],[\"若不是\",{\"1\":{\"400\":1}}],[\"若是则直接返回\",{\"1\":{\"400\":1}}],[\"若当前已经有一个线程正在初始化即\",{\"1\":{\"398\":1}}],[\"若当前变量实际值\",{\"1\":{\"393\":2}}],[\"若已经初始化了\",{\"1\":{\"393\":1}}],[\"若被占有\",{\"1\":{\"359\":1}}],[\"若成功入堆返回值true\",{\"1\":{\"333\":1}}],[\"若成功添加则返回true\",{\"1\":{\"328\":1}}],[\"若队空返回true\",{\"1\":{\"331\":1}}],[\"若栈空返回true\",{\"1\":{\"330\":1}}],[\"若map为空返回true\",{\"1\":{\"329\":1}}],[\"若map中没有该key\",{\"1\":{\"329\":2}}],[\"若集合为空返回true\",{\"1\":{\"328\":1}}],[\"若集合中没有元素e\",{\"1\":{\"328\":1}}],[\"若集合中有元素e则返回false\",{\"1\":{\"328\":1}}],[\"若存在元素e\",{\"1\":{\"328\":1}}],[\"若删除成功返回true\",{\"1\":{\"328\":1}}],[\"若需要知道具体数据作用\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"119\":1,\"120\":1}}],[\"若网络一栏无文件\",{\"1\":{\"81\":1}}],[\"直至\",{\"1\":{\"517\":1}}],[\"直至成功\",{\"1\":{\"378\":1,\"516\":1}}],[\"直至被\",{\"1\":{\"378\":1}}],[\"直到被等待对象\",{\"1\":{\"420\":1}}],[\"直到链表尾插入这个结点\",{\"1\":{\"399\":1}}],[\"直到第一次插入数据的时候才会进行初始化操作\",{\"1\":{\"393\":1}}],[\"直到\",{\"1\":{\"386\":1}}],[\"直到获得了\",{\"1\":{\"378\":1}}],[\"直到仓库人员跟你把货物送过来\",{\"1\":{\"351\":1}}],[\"直接调用\",{\"1\":{\"413\":1}}],[\"直接调用红黑树的插入方法进行插入新的节点\",{\"1\":{\"399\":1}}],[\"直接针对的是\",{\"1\":{\"403\":1}}],[\"直接跳过\",{\"1\":{\"401\":1}}],[\"直接上源码\",{\"1\":{\"398\":1}}],[\"直接看\",{\"1\":{\"386\":1}}],[\"直接退出\",{\"1\":{\"275\":1}}],[\"直接简写为\",{\"1\":{\"198\":1}}],[\"直接点击\",{\"1\":{\"190\":1}}],[\"直接点击install安装即可\",{\"1\":{\"70\":1}}],[\"直聘\",{\"2\":{\"98\":1}}],[\"把一个变量从主内存中复制到工作内存中就需要执行\",{\"1\":{\"494\":1}}],[\"把这个对象赋值给成员变量\",{\"1\":{\"487\":1}}],[\"把当前\",{\"1\":{\"402\":1}}],[\"把处理的结果分别放在\",{\"1\":{\"401\":1}}],[\"把他们分别放在\",{\"1\":{\"401\":1}}],[\"把控制循环次数的变量从循环体中剥离\",{\"1\":{\"245\":1}}],[\"把两个数相乘\",{\"1\":{\"234\":1}}],[\"把两个数相加\",{\"1\":{\"234\":1}}],[\"把相同的数据进行合并输出\",{\"1\":{\"196\":1}}],[\"把json字符串转为json字典数据\",{\"1\":{\"96\":1}}],[\"把最底下add\",{\"1\":{\"67\":1}}],[\"页面中一个工作的信息包含在\",{\"1\":{\"96\":1}}],[\"页面中勾选了\",{\"1\":{\"50\":1}}],[\"比较交换的过程可以通俗的理解为\",{\"1\":{\"449\":1}}],[\"比较运算符\",{\"1\":{\"194\":2}}],[\"比较麻烦\",{\"1\":{\"95\":1}}],[\"比如当前时间是\",{\"1\":{\"520\":1}}],[\"比如能响应中断以及超时等待等特性\",{\"1\":{\"519\":1}}],[\"比如对主内存中的\",{\"1\":{\"494\":1}}],[\"比如在上例\",{\"1\":{\"487\":1}}],[\"比如在\",{\"1\":{\"481\":1}}],[\"比如在图像处理领域\",{\"1\":{\"346\":1}}],[\"比如获得锁的线程被阻塞住了\",{\"1\":{\"459\":1}}],[\"比如一个很简单的\",{\"1\":{\"466\":1}}],[\"比如一个很经典的问题就是\",{\"1\":{\"437\":1}}],[\"比如一个旧值\",{\"1\":{\"451\":1}}],[\"比如一个线程占有了临界区资源\",{\"1\":{\"353\":1}}],[\"比如上面的\",{\"1\":{\"435\":1}}],[\"比如上面计算圆面积的代码\",{\"1\":{\"430\":1}}],[\"比如数据依赖性\",{\"1\":{\"430\":1}}],[\"比如数据脏读\",{\"1\":{\"349\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"423\":1}}],[\"比如getreadholdcount\",{\"1\":{\"369\":1}}],[\"比如如何保证线程安全\",{\"1\":{\"349\":1}}],[\"比如任务很少\",{\"1\":{\"348\":1}}],[\"比如\",{\"1\":{\"202\":1,\"297\":1,\"346\":1,\"351\":1,\"375\":1,\"386\":1,\"391\":1,\"397\":1,\"403\":1,\"407\":2,\"474\":1,\"494\":1,\"520\":1}}],[\"比如社交评论\",{\"1\":{\"132\":1}}],[\"比如还有城市\",{\"1\":{\"76\":1}}],[\"突破验证\",{\"1\":{\"95\":1}}],[\"例外就是\",{\"1\":{\"494\":1}}],[\"例题\",{\"1\":{\"240\":1,\"247\":1,\"248\":1}}],[\"例子中通过\",{\"1\":{\"508\":1}}],[\"例子\",{\"1\":{\"95\":1}}],[\"例如用来配置应用程序的任何切面\",{\"1\":{\"306\":1}}],[\"例如标记过时的功能\",{\"1\":{\"306\":1}}],[\"例如对数组\",{\"1\":{\"300\":1}}],[\"例如在一间教室中\",{\"1\":{\"280\":1}}],[\"例如求\",{\"1\":{\"245\":1}}],[\"例如薪资\",{\"1\":{\"76\":1}}],[\"例如\",{\"1\":{\"48\":1,\"149\":1,\"151\":1,\"158\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"260\":1,\"273\":1,\"300\":1,\"435\":1}}],[\"例如我的是d\",{\"1\":{\"34\":1}}],[\"例如要切换到\",{\"1\":{\"22\":1}}],[\"作用于工作内存的变量\",{\"1\":{\"494\":1}}],[\"作用于工作内存中的变量\",{\"1\":{\"494\":3}}],[\"作用于主内存的变量\",{\"1\":{\"494\":2}}],[\"作用于主内存中的变量\",{\"1\":{\"494\":2}}],[\"作用与\",{\"1\":{\"248\":1}}],[\"作用\",{\"1\":{\"182\":1}}],[\"作用不大\",{\"1\":{\"95\":1}}],[\"作为新的\",{\"1\":{\"401\":1}}],[\"作为可执行文件\",{\"1\":{\"146\":1}}],[\"作为一款基于\",{\"1\":{\"134\":1}}],[\"作为\",{\"1\":{\"27\":1,\"377\":1,\"393\":1}}],[\"搜索性能会打折扣\",{\"1\":{\"221\":1}}],[\"搜索\",{\"1\":{\"127\":1}}],[\"搜索框中搜索city\",{\"1\":{\"81\":1}}],[\"搜全文\",{\"1\":{\"95\":1}}],[\"搜公司\",{\"1\":{\"95\":1}}],[\"职业关键字\",{\"1\":{\"95\":1}}],[\"职位\",{\"1\":{\"75\":1,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":1}}],[\"故其具有有序性\",{\"1\":{\"497\":1}}],[\"故\",{\"1\":{\"496\":1}}],[\"故在这里只教程如何爬取内容\",{\"1\":{\"94\":1}}],[\"故我们在此一并处理\",{\"1\":{\"76\":1}}],[\"等方法\",{\"1\":{\"508\":1}}],[\"等线程处于\",{\"1\":{\"508\":1}}],[\"等同步组件主要专注于实现同步语义\",{\"1\":{\"507\":1}}],[\"等基友赶上来后\",{\"1\":{\"420\":1}}],[\"等以及用户自定义的\",{\"1\":{\"299\":1}}],[\"等采用引用传递\",{\"1\":{\"273\":1}}],[\"等于\",{\"1\":{\"194\":1,\"239\":1}}],[\"等各种复杂工作负载以及成为\",{\"1\":{\"134\":1}}],[\"等\",{\"1\":{\"133\":2,\"265\":1,\"297\":1,\"299\":1,\"407\":1,\"507\":1}}],[\"等信息在一块\",{\"1\":{\"94\":1}}],[\"等待通知等等一些底层的实现处理\",{\"1\":{\"512\":1}}],[\"等待通知机制\",{\"0\":{\"374\":1}}],[\"等待和唤醒这些底层操作\",{\"1\":{\"507\":1}}],[\"等待和唤醒等底层操作\",{\"1\":{\"506\":1}}],[\"等待下一次获取资源\",{\"1\":{\"421\":1}}],[\"等待\",{\"1\":{\"412\":1}}],[\"等待方\",{\"1\":{\"380\":1}}],[\"等待队列中的下一个节点\",{\"1\":{\"513\":1}}],[\"等待队列为空队列\",{\"1\":{\"378\":1}}],[\"等待队列是一个单向队列\",{\"1\":{\"377\":2}}],[\"等待队列\",{\"0\":{\"377\":1}}],[\"等待线程执行结束\",{\"1\":{\"315\":1}}],[\"等待监听到的请求响应\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"等待自动下载\",{\"1\":{\"23\":1}}],[\"但在同步队列中进行等待的时候可以检测中断\",{\"1\":{\"512\":1}}],[\"但在实际应用中\",{\"1\":{\"226\":1}}],[\"但由于存在重排序的问题\",{\"1\":{\"497\":1}}],[\"但这个对象属性是可以改变的\",{\"1\":{\"479\":1}}],[\"但这种转换方式依然是通过\",{\"1\":{\"407\":1}}],[\"但操作完不知道何时会写到内存\",{\"1\":{\"466\":1}}],[\"但它同时不容易被正确理解\",{\"1\":{\"465\":1}}],[\"但它并不用返回当前hashmap的元素个数\",{\"1\":{\"402\":1}}],[\"但整个付款的时间大大缩短\",{\"1\":{\"446\":1}}],[\"但他们仍然是属于同一个类依然会被锁住\",{\"1\":{\"442\":1}}],[\"但总的来说\",{\"1\":{\"437\":1}}],[\"但与此同时利用定义中的第二条\",{\"1\":{\"433\":1}}],[\"但\",{\"1\":{\"432\":1,\"441\":1,\"494\":1}}],[\"但如果线程数多于处理器的数目\",{\"1\":{\"414\":1}}],[\"但实际上做了两件事情\",{\"1\":{\"487\":1}}],[\"但实际上\",{\"1\":{\"413\":1}}],[\"但最好使用\",{\"1\":{\"330\":1}}],[\"但不能降级\",{\"1\":{\"391\":1}}],[\"但不能添加任何元素\",{\"1\":{\"329\":1}}],[\"但不建议这么做\",{\"1\":{\"332\":1}}],[\"但不要对其进行改动\",{\"1\":{\"327\":1}}],[\"但从index开始从后往前找\",{\"1\":{\"324\":1}}],[\"但从index开始找\",{\"1\":{\"324\":1}}],[\"但其实\",{\"1\":{\"323\":1}}],[\"但注解可以被编译或运行\",{\"1\":{\"306\":1}}],[\"但该对象的类无法实现\",{\"1\":{\"300\":1}}],[\"但该字符串不能转换为适当格式时\",{\"1\":{\"300\":1}}],[\"但可以是多列\",{\"1\":{\"210\":1}}],[\"但可以是多行\",{\"1\":{\"210\":1}}],[\"但对于数据传输的安全性和及时性有较高要求的业务来说\",{\"1\":{\"133\":1}}],[\"但关闭会话服务会停止\",{\"1\":{\"126\":1}}],[\"但我们翻到第二页的时候\",{\"1\":{\"89\":1}}],[\"但是却拥有了锁获取和释放的可操作性\",{\"1\":{\"504\":1}}],[\"但是这里其实是有一个前提条件的\",{\"1\":{\"490\":1}}],[\"但是这些类都不是线程安全的类\",{\"1\":{\"407\":1}}],[\"但是有一些处理器会重排序\",{\"1\":{\"487\":1}}],[\"但是它在应用程序启动几秒钟之后才激活\",{\"1\":{\"456\":1}}],[\"但是实际上的确发生了变化\",{\"1\":{\"451\":1}}],[\"但是该线程还是会执行\",{\"1\":{\"423\":1}}],[\"但是该文件的省份为缩写\",{\"1\":{\"76\":1}}],[\"但是当\",{\"1\":{\"423\":1}}],[\"但是由于它是支持并发扩容的\",{\"1\":{\"401\":1}}],[\"但是位运算比取模运算的效率要高很多\",{\"1\":{\"399\":1}}],[\"但是注意许可不可重入\",{\"1\":{\"385\":1}}],[\"但是每个线程使用时\",{\"1\":{\"354\":1}}],[\"但是创建了很多的线程\",{\"1\":{\"348\":1}}],[\"但是如果是自定义的实体类对象\",{\"1\":{\"329\":1}}],[\"但是如果高并发访问\",{\"1\":{\"221\":1}}],[\"但是不能省略\",{\"1\":{\"268\":1}}],[\"但是在写线程访问时\",{\"1\":{\"364\":1}}],[\"但是在\",{\"1\":{\"221\":1}}],[\"但是对于用户的身份信息查询频率很低\",{\"1\":{\"201\":1}}],[\"但是\",{\"1\":{\"95\":1,\"346\":1,\"414\":1,\"422\":1,\"466\":1,\"481\":1,\"490\":1}}],[\"但是同上操作在最后一页下一页的按钮为\",{\"1\":{\"85\":1}}],[\"参考文章\",{\"1\":{\"403\":1}}],[\"参考智联招聘的city\",{\"1\":{\"76\":1}}],[\"参照\",{\"1\":{\"375\":1}}],[\"参照页面原型以及需求文档设计数据库表结构\",{\"1\":{\"173\":1}}],[\"参数关闭偏向锁\",{\"1\":{\"456\":1}}],[\"参数来关闭延迟\",{\"1\":{\"456\":1}}],[\"参数可为字符串常量\",{\"1\":{\"324\":1}}],[\"参数可以是字符串常量\",{\"1\":{\"324\":1}}],[\"参数列表必须不同\",{\"1\":{\"307\":1}}],[\"参数传递\",{\"0\":{\"271\":1}}],[\"参数之后直接指定\",{\"1\":{\"169\":1}}],[\"参数不加\",{\"1\":{\"169\":2}}],[\"参数\",{\"1\":{\"159\":1}}],[\"参数有3个\",{\"1\":{\"88\":1}}],[\"基本数据类型的重排序规则在这里还是使用\",{\"1\":{\"488\":1}}],[\"基本数据类型\",{\"0\":{\"479\":1},\"1\":{\"488\":1}}],[\"基本一致\",{\"1\":{\"367\":1}}],[\"基本上所有方法的实现\",{\"1\":{\"505\":1}}],[\"基本上与\",{\"1\":{\"378\":1}}],[\"基本上一致\",{\"1\":{\"360\":1}}],[\"基本上分为三种\",{\"1\":{\"199\":1}}],[\"基本介绍\",{\"0\":{\"358\":1}}],[\"基本类型的最大值和最小值\",{\"0\":{\"338\":1}}],[\"基本思想\",{\"1\":{\"245\":1}}],[\"基本\",{\"1\":{\"239\":1}}],[\"基本信息\",{\"1\":{\"201\":1}}],[\"基本信息+身份信息\",{\"1\":{\"201\":1}}],[\"基本查询\",{\"0\":{\"193\":1},\"1\":{\"192\":1}}],[\"基本的题目就算创建完成了\",{\"1\":{\"57\":1}}],[\"基础上增加了超时等待的功能\",{\"1\":{\"512\":1}}],[\"基础上增加了超时等待功能\",{\"1\":{\"512\":1}}],[\"基础知识\",{\"0\":{\"167\":1,\"231\":1}}],[\"基础\",{\"0\":{\"168\":1},\"2\":{\"166\":1,\"224\":1,\"230\":1,\"320\":1}}],[\"基础url\",{\"1\":{\"88\":1}}],[\"基于\",{\"1\":{\"132\":1,\"134\":1}}],[\"同生共死\",{\"1\":{\"494\":1}}],[\"同第二种\",{\"1\":{\"375\":1}}],[\"同上\",{\"1\":{\"324\":3}}],[\"同步队列是一个双向队列\",{\"1\":{\"513\":1}}],[\"同步队列\",{\"0\":{\"513\":1},\"1\":{\"512\":1}}],[\"同步队列以及执行线程状态之间的关系\",{\"1\":{\"443\":1}}],[\"同步器会调用\",{\"1\":{\"518\":1}}],[\"同步器是面向锁的实现者\",{\"1\":{\"506\":1}}],[\"同步器是实现锁\",{\"1\":{\"506\":1}}],[\"同步器是用来构建锁和其他同步组件的基础框架\",{\"1\":{\"506\":1}}],[\"同步器既支持独占式获取同步状态\",{\"1\":{\"506\":1}}],[\"同步器自身没有实现任何同步接口\",{\"1\":{\"506\":1}}],[\"同步块执行完成或者遇到异常是锁会自动释放\",{\"1\":{\"504\":1}}],[\"同步组件的实现者通过使用\",{\"1\":{\"512\":1}}],[\"同步组件的实现聚合了同步器\",{\"1\":{\"366\":1}}],[\"同步组件专注于对当前同步状态的逻辑判断\",{\"1\":{\"508\":1}}],[\"同步组件实现者的角度\",{\"1\":{\"508\":1}}],[\"同步组件以及\",{\"1\":{\"508\":1}}],[\"同步组件语义的实现依赖于\",{\"1\":{\"508\":1}}],[\"同步组件通过重写\",{\"1\":{\"508\":1}}],[\"同步组件通过\",{\"1\":{\"507\":1}}],[\"同步组件\",{\"1\":{\"507\":1}}],[\"同步组件主要是通过重写\",{\"1\":{\"359\":1}}],[\"同步状态减去写状态\",{\"1\":{\"367\":1}}],[\"同步状态减1\",{\"1\":{\"359\":1}}],[\"同步状态的高\",{\"1\":{\"366\":1,\"369\":1}}],[\"同步状态的低\",{\"1\":{\"366\":1}}],[\"同步状态加\",{\"1\":{\"359\":1}}],[\"同步语义的学习\",{\"1\":{\"358\":1}}],[\"同步方法调用一开始\",{\"1\":{\"351\":1}}],[\"同步和异步通常用来形容一次方法调用\",{\"1\":{\"351\":1}}],[\"同步vs异步\",{\"0\":{\"351\":1}}],[\"同步的过程会消耗时间\",{\"1\":{\"330\":1}}],[\"同步\",{\"0\":{\"317\":1}}],[\"同一个类的实例\",{\"1\":{\"284\":1}}],[\"同一个包或者子类中可以访问\",{\"1\":{\"282\":1}}],[\"同时在\",{\"1\":{\"520\":1}}],[\"同时在新建一个同步组件时需要把握的两个关键点是\",{\"1\":{\"508\":1}}],[\"同时很明显\",{\"1\":{\"516\":1}}],[\"同时实现包括获取锁失败的线程进行入队\",{\"1\":{\"513\":1}}],[\"同时该线程可以调用\",{\"1\":{\"419\":1}}],[\"同时\",{\"1\":{\"407\":1,\"435\":1,\"485\":1,\"518\":1}}],[\"同时可以看出等待队列是一个不带头结点的链式队列\",{\"1\":{\"378\":1}}],[\"同时还有一点需要注意的是\",{\"1\":{\"377\":1}}],[\"同时还有一个方法值得我们注意\",{\"1\":{\"366\":1}}],[\"同时还能够为该应用程序提供相关的服务的软件\",{\"1\":{\"9\":1}}],[\"同时也能够获取读锁\",{\"1\":{\"364\":1}}],[\"同时进行\",{\"1\":{\"352\":1}}],[\"同时却也降低了\",{\"1\":{\"220\":1}}],[\"同样来看一段代码\",{\"1\":{\"479\":1}}],[\"同样根据\",{\"1\":{\"467\":1}}],[\"同样是需要排队\",{\"1\":{\"446\":1}}],[\"同样都是当前线程会交出处理器资源\",{\"1\":{\"422\":1}}],[\"同样可以调用\",{\"1\":{\"419\":1}}],[\"同样可以通过中断的方式实现线程间的简单交互\",{\"1\":{\"419\":1}}],[\"同样可以通过\",{\"1\":{\"349\":1}}],[\"同样\",{\"1\":{\"391\":1,\"428\":1}}],[\"同样的在\",{\"1\":{\"498\":1}}],[\"同样的\",{\"1\":{\"375\":1,\"377\":1}}],[\"同样先计算键的哈希值\",{\"1\":{\"226\":1}}],[\"同样我们也可以通过外键来体现一对一之间的关系\",{\"1\":{\"201\":1}}],[\"同样表示字符串\",{\"1\":{\"151\":1}}],[\"同理\",{\"1\":{\"88\":1}}],[\"属于编译器重排序\",{\"1\":{\"430\":1}}],[\"属于收费版\",{\"1\":{\"68\":1}}],[\"属性length\",{\"1\":{\"257\":1}}],[\"属性\",{\"1\":{\"86\":1,\"93\":1,\"306\":1}}],[\"技能要求和福利\",{\"1\":{\"94\":1}}],[\"技能\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"118\":2,\"121\":1}}],[\"领域\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":1}}],[\"学生\",{\"1\":{\"280\":1}}],[\"学生与课程的关系\",{\"1\":{\"202\":1}}],[\"学生和课程的关系\",{\"1\":{\"202\":1}}],[\"学生和老师的关系\",{\"1\":{\"202\":1}}],[\"学习者应该掌握的\",{\"1\":{\"346\":1}}],[\"学习循环语句只需要抓住一点\",{\"1\":{\"242\":1}}],[\"学习编程语言语法是次要的\",{\"1\":{\"242\":1}}],[\"学习语言最好的方式就是实践\",{\"1\":{\"238\":1}}],[\"学习技巧\",{\"1\":{\"146\":1}}],[\"学习笔记\",{\"0\":{\"12\":1},\"2\":{\"17\":1,\"40\":1,\"63\":1}}],[\"学历\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":1,\"201\":1}}],[\"滚动到页面底部\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":2}}],[\"根据超时时间和当前时间计算出截止时间\",{\"1\":{\"520\":1}}],[\"根据当前获得同步状态成功与否做了两件事情\",{\"1\":{\"515\":1}}],[\"根据当前节点个数进行调整\",{\"1\":{\"399\":1}}],[\"根据重排序规则\",{\"1\":{\"487\":1}}],[\"根据运算得到当前遍历的数组的位置\",{\"1\":{\"401\":1}}],[\"根据是否初始化和是否正在扩容有几种情况\",{\"1\":{\"393\":1}}],[\"根据\",{\"1\":{\"366\":1,\"442\":1,\"444\":1}}],[\"根据公平性\",{\"1\":{\"360\":1}}],[\"根据计算树的高度大概是\",{\"1\":{\"221\":1}}],[\"根据子查询结果的不同分为\",{\"1\":{\"210\":1}}],[\"根据业务功能的实现\",{\"1\":{\"173\":1}}],[\"根据页面元素可以得到\",{\"1\":{\"96\":1}}],[\"根据关键词和城市编码生成正确的url\",{\"1\":{\"84\":1,\"86\":1,\"91\":1,\"93\":1}}],[\"根据返回的网址\",{\"1\":{\"23\":1}}],[\"默认存储结构为\",{\"1\":{\"452\":1}}],[\"默认优先级为\",{\"1\":{\"422\":1}}],[\"默认情况下\",{\"1\":{\"422\":1}}],[\"默认超过\",{\"1\":{\"399\":1}}],[\"默认大小为16\",{\"1\":{\"397\":1}}],[\"默认选择的是非公平锁\",{\"1\":{\"360\":1}}],[\"默认实现小根堆\",{\"1\":{\"333\":1}}],[\"默认按元素的排序规则排序\",{\"1\":{\"333\":1}}],[\"默认是小根堆\",{\"1\":{\"293\":1}}],[\"默认为\",{\"1\":{\"286\":1}}],[\"默认保留6位小数\",{\"1\":{\"237\":2}}],[\"默认\",{\"1\":{\"217\":1,\"364\":1}}],[\"默认值\",{\"1\":{\"197\":1}}],[\"默认值为全国\",{\"1\":{\"84\":1,\"86\":1,\"91\":1,\"93\":1}}],[\"默认约束\",{\"1\":{\"182\":1}}],[\"默认连接的端口号是\",{\"1\":{\"169\":1}}],[\"默认连接的是本地\",{\"1\":{\"169\":1}}],[\"默认变量\",{\"0\":{\"157\":1}}],[\"默认用户名和密码都是\",{\"1\":{\"128\":1}}],[\"默认均为\",{\"1\":{\"126\":1}}],[\"默认把所有的勾选上即可\",{\"1\":{\"67\":1}}],[\"zero\",{\"1\":{\"508\":2}}],[\"zeus\",{\"1\":{\"288\":2,\"289\":1}}],[\"z\",{\"1\":{\"236\":1,\"259\":2}}],[\"zsh\",{\"1\":{\"146\":1}}],[\"zipdateformat>\",{\"1\":{\"129\":1}}],[\"zoom=1\",{\"1\":{\"102\":1,\"107\":1}}],[\"zh\",{\"0\":{\"528\":1}}],[\"zhaopin\",{\"1\":{\"88\":1,\"91\":1,\"93\":2}}],[\"zhipin\",{\"1\":{\"82\":1,\"84\":1,\"86\":2}}],[\"zhilian\",{\"1\":{\"75\":3,\"93\":4}}],[\"zpdata\",{\"1\":{\"84\":2,\"85\":1,\"86\":2}}],[\"zpcommon\",{\"1\":{\"84\":1,\"86\":1}}],[\"访问静态变量最好通过类名\",{\"1\":{\"282\":1}}],[\"访问string中的字符\",{\"1\":{\"260\":1}}],[\"访问数组元素\",{\"0\":{\"254\":1}}],[\"访问\",{\"1\":{\"134\":1}}],[\"访问的是\",{\"1\":{\"84\":2}}],[\"访问在线网页\",{\"1\":{\"84\":1}}],[\"访问网址\",{\"1\":{\"81\":1}}],[\"复制到锁记录中\",{\"1\":{\"458\":1}}],[\"复制到自己指定的目录\",{\"1\":{\"129\":1}}],[\"复制search\",{\"1\":{\"82\":1}}],[\"复制当前行到下一行\",{\"1\":{\"71\":1}}],[\"标量子查询\",{\"0\":{\"211\":1},\"1\":{\"210\":1}}],[\"标度\",{\"1\":{\"183\":2}}],[\"标准兼容\",{\"1\":{\"134\":1}}],[\"标准件\",{\"1\":{\"9\":1}}],[\"标题\",{\"1\":{\"102\":1,\"103\":1,\"104\":1}}],[\"标签\",{\"1\":{\"96\":1}}],[\"标头\",{\"1\":{\"82\":1}}],[\"就数据结构而言\",{\"1\":{\"513\":1}}],[\"就能够读到\",{\"1\":{\"487\":1}}],[\"就能够迅速感知\",{\"1\":{\"467\":1}}],[\"就算写回到内存\",{\"1\":{\"466\":1}}],[\"就导致最终的计算结果不是正确的\",{\"1\":{\"461\":1}}],[\"就可能会出现\",{\"1\":{\"461\":1}}],[\"就可以判断是否已经超时了\",{\"1\":{\"520\":1}}],[\"就可以说是\",{\"1\":{\"465\":1}}],[\"就可以保证内存可见性\",{\"1\":{\"461\":1}}],[\"就可以执行i\",{\"1\":{\"401\":1}}],[\"就可以直接用\",{\"1\":{\"399\":1}}],[\"就可以通过\",{\"1\":{\"399\":1}}],[\"就可以进行拆分利用多线程的技术完成\",{\"1\":{\"346\":1}}],[\"就可以达到\",{\"1\":{\"346\":1}}],[\"就可以找到\",{\"1\":{\"221\":1}}],[\"就可以很方便的解决上述问题\",{\"1\":{\"200\":1}}],[\"就可以查询到当前所处的数据库\",{\"1\":{\"175\":1}}],[\"就可以添加一组对拍\",{\"1\":{\"53\":1}}],[\"就可以测试\",{\"1\":{\"49\":1}}],[\"就知道如何解决了\",{\"1\":{\"461\":1}}],[\"就知道同步队列是一个带头结点的链式队列\",{\"1\":{\"378\":1}}],[\"就变成了\",{\"1\":{\"451\":1}}],[\"就具有使每个线程依次排队操作共享变量的功能\",{\"1\":{\"441\":1}}],[\"就好像通过共享变量在进行隐式通信\",{\"1\":{\"429\":1}}],[\"就从抽象层次定义了这种方式\",{\"1\":{\"429\":1}}],[\"就以这个生活场景为例\",{\"1\":{\"428\":1}}],[\"就和它的名字一样\",{\"1\":{\"423\":1}}],[\"就两人携手并进\",{\"1\":{\"420\":1}}],[\"就不会被其他线程所干扰\",{\"1\":{\"494\":1}}],[\"就不会再恢复到轻量级锁状态\",{\"1\":{\"459\":1}}],[\"就不会清除标志位\",{\"1\":{\"419\":1}}],[\"就不能保证其原子性\",{\"1\":{\"451\":1}}],[\"就不能再使用表名来指定对应的字段了\",{\"1\":{\"207\":1}}],[\"就构造一个反序链表\",{\"1\":{\"401\":1}}],[\"就在原\",{\"1\":{\"401\":1}}],[\"就在任何场景下就一定适用么\",{\"1\":{\"347\":1}}],[\"就向后遍历查找节点\",{\"1\":{\"400\":1}}],[\"就把这个链表转换成红黑树\",{\"1\":{\"399\":1}}],[\"就会报错\",{\"1\":{\"483\":1}}],[\"就会从内存中重读该变量数据\",{\"1\":{\"466\":1}}],[\"就会将当前处理器的缓存行设置成无效状态\",{\"1\":{\"466\":1}}],[\"就会实现缓存一致性协议\",{\"1\":{\"466\":1}}],[\"就会向处理器发送一条\",{\"1\":{\"466\":1}}],[\"就会退出所以不会出现死循环的情况\",{\"1\":{\"423\":1}}],[\"就会调用\",{\"1\":{\"399\":1}}],[\"就会造成数的高度比较高\",{\"1\":{\"221\":1}}],[\"就覆盖旧值\",{\"1\":{\"399\":1}}],[\"就直接将待插入的键值对追加到链表的末尾即可\",{\"1\":{\"399\":1}}],[\"就直接覆盖即可\",{\"1\":{\"399\":1}}],[\"就直接抛出异常\",{\"1\":{\"397\":1}}],[\"就说明当前\",{\"1\":{\"399\":1}}],[\"就像网购\",{\"1\":{\"351\":1}}],[\"就需要扩容\",{\"1\":{\"399\":2}}],[\"就需要自己自定义排序方式\",{\"1\":{\"329\":1}}],[\"就需要通过该指令\",{\"1\":{\"177\":1}}],[\"就被称为元注解\",{\"1\":{\"308\":1}}],[\"就要解决两个问题\",{\"1\":{\"359\":1}}],[\"就要立即将这个功能应用到实践中\",{\"1\":{\"238\":1}}],[\"就要付出较高的公网带宽传输成本\",{\"1\":{\"133\":1}}],[\"就有可能读到的是普通变量\",{\"1\":{\"487\":1}}],[\"就有了很大的变化\",{\"1\":{\"391\":1}}],[\"就有\",{\"1\":{\"221\":1}}],[\"就满足这种要求\",{\"1\":{\"221\":1}}],[\"就进行事务的回滚\",{\"1\":{\"216\":1}}],[\"就占用多少个字符\",{\"1\":{\"183\":1}}],[\"就是\",{\"1\":{\"484\":1}}],[\"就是目前来说最新的值了\",{\"1\":{\"449\":1}}],[\"就是两种情况\",{\"1\":{\"399\":1}}],[\"就是线程安全的\",{\"1\":{\"391\":1}}],[\"就是当前线程被中断或者调用\",{\"1\":{\"378\":1}}],[\"就是通过尾插入的方式将当前线程封装的\",{\"1\":{\"378\":1}}],[\"就是最后一层子节点\",{\"1\":{\"221\":1}}],[\"就是不再像红黑树一样每个节点只能保存一个数据\",{\"1\":{\"221\":1}}],[\"就是使用索引可以提高查询的效率\",{\"1\":{\"220\":1}}],[\"就是来保证数据库当中数据的正确性\",{\"1\":{\"182\":1}}],[\"就是城市的参数文件\",{\"1\":{\"81\":1}}],[\"按gbk转换\",{\"1\":{\"324\":1}}],[\"按gbk编码转换\",{\"1\":{\"324\":1}}],[\"按utf\",{\"1\":{\"324\":3}}],[\"按系统默认编码转换\",{\"1\":{\"324\":1}}],[\"按照推荐的方式\",{\"1\":{\"508\":1}}],[\"按照\",{\"1\":{\"488\":1}}],[\"按照之前的\",{\"1\":{\"399\":1}}],[\"按照之前对\",{\"1\":{\"369\":1}}],[\"按照等待队列是先进先出\",{\"1\":{\"379\":1}}],[\"按照所预测的速度\",{\"1\":{\"346\":1}}],[\"按照某一列或者某几列\",{\"1\":{\"196\":1}}],[\"按照列去统计有多少行数据\",{\"1\":{\"195\":1}}],[\"按照职业将对应图表添加到时间线上\",{\"1\":{\"106\":1}}],[\"按f12打开开发者工具\",{\"1\":{\"81\":1}}],[\"按钮来查看题面\",{\"1\":{\"47\":1}}],[\"打个比方\",{\"1\":{\"446\":1}}],[\"打印\",{\"1\":{\"249\":1}}],[\"打印到一个\",{\"1\":{\"249\":1}}],[\"打开官网前程无忧\",{\"1\":{\"94\":1}}],[\"打开官网智联招聘\",{\"1\":{\"88\":1}}],[\"打开官网boss直聘\",{\"1\":{\"81\":1}}],[\"打开文件时发生错误\",{\"1\":{\"86\":1,\"93\":1}}],[\"打开开发者工具\",{\"1\":{\"82\":1}}],[\"打包成功后\",{\"1\":{\"57\":1}}],[\"✅️简单demo编写\",{\"0\":{\"96\":1}}],[\"✅️源代码如下\",{\"0\":{\"86\":1,\"93\":1}}],[\"✅️代码编写\",{\"0\":{\"83\":1,\"90\":1}}],[\"✅️招聘信息获取\",{\"0\":{\"82\":1,\"89\":1}}],[\"✅️url获取\",{\"0\":{\"81\":1,\"88\":1,\"95\":1}}],[\"✅️️数据处理\",{\"0\":{\"76\":1}}],[\"✅️️数据合并\",{\"0\":{\"75\":1}}],[\"✅️️pycharm\",{\"0\":{\"70\":1,\"71\":1}}],[\"✅️️安装包下载\",{\"0\":{\"69\":1}}],[\"✅️️运行安装包\",{\"0\":{\"67\":1}}],[\"薪资\",{\"1\":{\"77\":1,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":1}}],[\"台湾\",{\"1\":{\"76\":2,\"77\":2}}],[\"台州\",{\"1\":{\"76\":1,\"77\":1}}],[\"澳门\",{\"1\":{\"76\":2,\"77\":2}}],[\"澳门特别行政区\",{\"1\":{\"76\":1,\"77\":1}}],[\"香港\",{\"1\":{\"76\":2,\"77\":2}}],[\"香港特别行政区\",{\"1\":{\"76\":1,\"77\":1}}],[\"琼中黎族苗族自治县\",{\"1\":{\"76\":1,\"77\":1}}],[\"琼海\",{\"1\":{\"76\":1,\"77\":1}}],[\"陵水黎族自治县\",{\"1\":{\"76\":1,\"77\":1}}],[\"乐东黎族自治县\",{\"1\":{\"76\":1,\"77\":1}}],[\"乐山\",{\"1\":{\"76\":1,\"77\":1}}],[\"澄迈\",{\"1\":{\"76\":1,\"77\":1}}],[\"屯昌\",{\"1\":{\"76\":1,\"77\":1}}],[\"定位节点时要先定位到具体的\",{\"1\":{\"403\":1}}],[\"定制排序\",{\"1\":{\"329\":1}}],[\"定长字符串\",{\"1\":{\"183\":1}}],[\"定义了一个继承\",{\"1\":{\"508\":1}}],[\"定义了一些变量和一个内部类\",{\"1\":{\"402\":1}}],[\"定义成类\",{\"1\":{\"280\":1}}],[\"定义在类中的变量为成员变量\",{\"1\":{\"270\":1}}],[\"定义外键关联另外一张表\",{\"1\":{\"200\":1}}],[\"定义操作所有关系型数据库的统一标准\",{\"1\":{\"170\":1}}],[\"定义\",{\"0\":{\"161\":1,\"432\":1},\"1\":{\"433\":1}}],[\"定义环境变量\",{\"1\":{\"155\":1}}],[\"定义变量\",{\"0\":{\"151\":1},\"1\":{\"151\":1,\"155\":1}}],[\"定义热力图的最大值和最小值\",{\"1\":{\"102\":1}}],[\"定义热力图中的颜色\",{\"1\":{\"102\":1}}],[\"定义的最小值\",{\"1\":{\"101\":1}}],[\"定义的最大值\",{\"1\":{\"101\":1}}],[\"定安\",{\"1\":{\"76\":1,\"77\":1}}],[\"定西\",{\"1\":{\"76\":1,\"77\":1}}],[\"五\",{\"0\":{\"258\":1}}],[\"五指山\",{\"1\":{\"76\":1,\"77\":1}}],[\"五家渠\",{\"1\":{\"76\":1,\"77\":1}}],[\"儋州\",{\"1\":{\"76\":1,\"77\":1}}],[\"钦州\",{\"1\":{\"76\":1,\"77\":1}}],[\"百色\",{\"1\":{\"76\":1,\"77\":1}}],[\"百科\",{\"1\":{\"41\":1}}],[\"贺州\",{\"1\":{\"76\":1,\"77\":1}}],[\"梧州\",{\"1\":{\"76\":1,\"77\":1}}],[\"桂林\",{\"1\":{\"76\":1,\"77\":1}}],[\"来保证引用对象之间的原子性\",{\"1\":{\"451\":1}}],[\"来保证可见性\",{\"1\":{\"403\":1}}],[\"来解决\",{\"1\":{\"451\":1}}],[\"来解决或者通过\",{\"1\":{\"429\":1}}],[\"来看看\",{\"1\":{\"443\":1}}],[\"来控制优先级\",{\"1\":{\"422\":1}}],[\"来感知其他线程对其自身的中断操作\",{\"1\":{\"419\":1}}],[\"来新建线程\",{\"1\":{\"413\":1}}],[\"来计算\",{\"1\":{\"403\":1}}],[\"来确定\",{\"1\":{\"403\":1}}],[\"来实现减小锁粒度\",{\"1\":{\"403\":2}}],[\"来说之后的操作就会是错的\",{\"1\":{\"497\":1}}],[\"来说是可见的\",{\"1\":{\"467\":1}}],[\"来说\",{\"1\":{\"391\":1,\"402\":1,\"508\":1}}],[\"来说条件满足\",{\"1\":{\"381\":1}}],[\"来关联属于一这方的主键\",{\"1\":{\"200\":1}}],[\"来避免这个问题\",{\"1\":{\"176\":1}}],[\"来连接\",{\"1\":{\"169\":1}}],[\"来判断是否进行下一页\",{\"1\":{\"85\":1,\"92\":1}}],[\"来获取最后一个元素\",{\"1\":{\"85\":1,\"92\":1}}],[\"来宾\",{\"1\":{\"76\":1,\"77\":1}}],[\"来批量生成脚本\",{\"1\":{\"52\":1}}],[\"柳州\",{\"1\":{\"76\":1,\"77\":1}}],[\"崇左\",{\"1\":{\"76\":1,\"77\":1}}],[\"楚雄彝族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"迪庆藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"怒江傈僳族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"丽江\",{\"1\":{\"76\":1,\"77\":1}}],[\"丽水\",{\"1\":{\"76\":1,\"77\":1}}],[\"昭通\",{\"1\":{\"76\":1,\"77\":1}}],[\"玉林\",{\"1\":{\"76\":1,\"77\":1}}],[\"玉溪\",{\"1\":{\"76\":1,\"77\":1}}],[\"玉树藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"曲靖\",{\"1\":{\"76\":1,\"77\":1}}],[\"云存储和\",{\"1\":{\"134\":1}}],[\"云存储服务接口\",{\"1\":{\"132\":1}}],[\"云原生应用程序需要更高的吞吐量和更低的延迟\",{\"1\":{\"134\":1}}],[\"云原生\",{\"1\":{\"134\":1}}],[\"云南\",{\"1\":{\"76\":16,\"77\":16}}],[\"云浮\",{\"1\":{\"76\":1,\"77\":1}}],[\"昆明\",{\"1\":{\"76\":1,\"77\":1}}],[\"昆玉市\",{\"1\":{\"76\":1,\"77\":1}}],[\"汕尾\",{\"1\":{\"76\":1,\"77\":1}}],[\"汕头\",{\"1\":{\"76\":1,\"77\":1}}],[\"茂名\",{\"1\":{\"76\":1,\"77\":1}}],[\"揭阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"阳江\",{\"1\":{\"76\":1,\"77\":1}}],[\"阳泉\",{\"1\":{\"76\":1,\"77\":1}}],[\"东方\",{\"1\":{\"76\":1,\"77\":1}}],[\"东沙群岛\",{\"1\":{\"76\":1,\"77\":1}}],[\"东莞\",{\"1\":{\"76\":1,\"77\":1}}],[\"东营\",{\"1\":{\"76\":1,\"77\":1}}],[\"潮州\",{\"1\":{\"76\":1,\"77\":1}}],[\"湛江\",{\"1\":{\"76\":1,\"77\":1}}],[\"肇庆\",{\"1\":{\"76\":1,\"77\":1}}],[\"佛山\",{\"1\":{\"76\":1,\"77\":1}}],[\"珠海\",{\"1\":{\"76\":1,\"77\":1}}],[\"深入理解\",{\"0\":{\"511\":1}}],[\"深入理解java虚拟机\",{\"1\":{\"427\":1}}],[\"深入理解读写锁\",{\"0\":{\"363\":1}}],[\"深入浅出concurrenthashmap1\",{\"1\":{\"403\":1}}],[\"深圳\",{\"1\":{\"76\":1,\"77\":1}}],[\"深度学习\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"梅州\",{\"1\":{\"76\":1,\"77\":1}}],[\"惠州\",{\"1\":{\"76\":1,\"77\":1}}],[\"韶关\",{\"1\":{\"76\":1,\"77\":1}}],[\"凉山彝族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"德宏傣族景颇族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"德阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"德州\",{\"1\":{\"76\":1,\"77\":1}}],[\"雅安\",{\"1\":{\"76\":1,\"77\":1}}],[\"眉山\",{\"1\":{\"76\":1,\"77\":1}}],[\"资阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"资源共享\",{\"1\":{\"9\":1}}],[\"内存语义进行了分析\",{\"1\":{\"498\":1}}],[\"内存语义\",{\"1\":{\"469\":1}}],[\"内存屏障分类表\",{\"1\":{\"469\":1}}],[\"内存屏障分为四类见下图\",{\"1\":{\"469\":1}}],[\"内存地址存放的实际值\",{\"1\":{\"449\":1}}],[\"内存抽象模型的\",{\"1\":{\"445\":1}}],[\"内存系统的重排序\",{\"1\":{\"430\":1}}],[\"内存模型只是要求上述两个操作是顺序执行的并不是连续执行的\",{\"1\":{\"494\":1}}],[\"内存模型中说过\",{\"1\":{\"497\":1}}],[\"内存模型中定义了\",{\"1\":{\"494\":1}}],[\"内存模型中我们知道\",{\"1\":{\"485\":1}}],[\"内存模型就是一弱内存数据模型\",{\"1\":{\"485\":1}}],[\"内存模型为了能让处理器和编译器底层发挥他们的最大优势\",{\"1\":{\"485\":1}}],[\"内存模型告诉我们\",{\"1\":{\"465\":1}}],[\"内存模型的一些知识\",{\"1\":{\"441\":1}}],[\"内存模型向程序员做出的保证\",{\"1\":{\"432\":1}}],[\"内存模型将向程序员保证\",{\"1\":{\"432\":1}}],[\"内存模型是共享内存的并发模型\",{\"1\":{\"428\":1}}],[\"内存模型\",{\"1\":{\"427\":1,\"435\":1,\"467\":1}}],[\"内存模型及\",{\"0\":{\"426\":1}}],[\"内部维护了一个等待队列\",{\"1\":{\"377\":1}}],[\"内部维护了一个同步队列\",{\"1\":{\"377\":1}}],[\"内部也是使用同样的方式\",{\"1\":{\"377\":1}}],[\"内置异常方法\",{\"0\":{\"301\":1}}],[\"内置异常类\",{\"0\":{\"300\":1}}],[\"内置数据类型\",{\"1\":{\"233\":1}}],[\"内完成插入\",{\"1\":{\"227\":1}}],[\"内连接从语法上可以分为\",{\"1\":{\"207\":1}}],[\"内连接查询\",{\"1\":{\"207\":1}}],[\"内连接\",{\"0\":{\"207\":1},\"1\":{\"206\":1}}],[\"内容如下\",{\"1\":{\"129\":1,\"146\":1}}],[\"内江\",{\"1\":{\"76\":1,\"77\":1}}],[\"内蒙古\",{\"1\":{\"76\":12,\"77\":12}}],[\"内蒙古自治区\",{\"1\":{\"76\":1,\"77\":1}}],[\"泸州\",{\"1\":{\"76\":1,\"77\":1}}],[\"广西\",{\"1\":{\"76\":14,\"77\":14}}],[\"广西壮族自治区\",{\"1\":{\"76\":1,\"77\":1}}],[\"广东\",{\"1\":{\"76\":22,\"77\":22}}],[\"广州\",{\"1\":{\"76\":1,\"77\":1}}],[\"广元\",{\"1\":{\"76\":1,\"77\":1}}],[\"广安\",{\"1\":{\"76\":1,\"77\":1}}],[\"遂宁\",{\"1\":{\"76\":1,\"77\":1}}],[\"达州\",{\"1\":{\"76\":1,\"77\":1}}],[\"绵阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"攀枝花\",{\"1\":{\"76\":1,\"77\":1}}],[\"四\",{\"0\":{\"250\":1}}],[\"四大特性\",{\"0\":{\"218\":1}}],[\"四个参数\",{\"1\":{\"95\":1}}],[\"四川\",{\"1\":{\"76\":21,\"77\":21}}],[\"四平\",{\"1\":{\"76\":1,\"77\":1}}],[\"黔西南布依族苗族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"黔南布依族苗族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"黔东南苗族侗族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"六\",{\"0\":{\"263\":1}}],[\"六盘水\",{\"1\":{\"76\":1,\"77\":1}}],[\"六安\",{\"1\":{\"76\":1,\"77\":1}}],[\"贵港\",{\"1\":{\"76\":1,\"77\":1}}],[\"贵州\",{\"1\":{\"76\":9,\"77\":9}}],[\"贵阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"湘西土家族苗族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"湘潭\",{\"1\":{\"76\":1,\"77\":1}}],[\"永州\",{\"1\":{\"76\":1,\"77\":1}}],[\"怀化\",{\"1\":{\"76\":1,\"77\":1}}],[\"岳阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"邵阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"娄底\",{\"1\":{\"76\":1,\"77\":1}}],[\"益阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"郴州\",{\"1\":{\"76\":1,\"77\":1}}],[\"衡阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"衡水\",{\"1\":{\"76\":1,\"77\":1}}],[\"株洲\",{\"1\":{\"76\":1,\"77\":1}}],[\"鹰潭\",{\"1\":{\"76\":1,\"77\":1}}],[\"萍乡\",{\"1\":{\"76\":1,\"77\":1}}],[\"景德镇\",{\"1\":{\"76\":1,\"77\":1}}],[\"赣州\",{\"1\":{\"76\":1,\"77\":1}}],[\"吉安\",{\"1\":{\"76\":1,\"77\":1}}],[\"吉林\",{\"1\":{\"76\":10,\"77\":10}}],[\"宜宾\",{\"1\":{\"76\":1,\"77\":1}}],[\"宜春\",{\"1\":{\"76\":1,\"77\":1}}],[\"宜昌\",{\"1\":{\"76\":1,\"77\":1}}],[\"抚州\",{\"1\":{\"76\":1,\"77\":1}}],[\"抚顺\",{\"1\":{\"76\":1,\"77\":1}}],[\"江门\",{\"1\":{\"76\":1,\"77\":1}}],[\"江西\",{\"1\":{\"76\":11,\"77\":11}}],[\"江苏\",{\"1\":{\"76\":13,\"77\":13}}],[\"三条性质\",{\"1\":{\"467\":1}}],[\"三大性质总结\",{\"0\":{\"493\":1}}],[\"三大性质\",{\"1\":{\"467\":1}}],[\"三个实现类\",{\"1\":{\"328\":1}}],[\"三个元素\",{\"1\":{\"255\":1}}],[\"三\",{\"0\":{\"242\":1}}],[\"三沙\",{\"1\":{\"76\":1,\"77\":1}}],[\"三亚\",{\"1\":{\"76\":1,\"77\":1}}],[\"三明\",{\"1\":{\"76\":1,\"77\":1}}],[\"三门峡\",{\"1\":{\"76\":1,\"77\":1}}],[\"龙岩\",{\"1\":{\"76\":1,\"77\":1}}],[\"漳州\",{\"1\":{\"76\":1,\"77\":1}}],[\"泉州\",{\"1\":{\"76\":1,\"77\":1}}],[\"莆田\",{\"1\":{\"76\":1,\"77\":1}}],[\"厦门\",{\"1\":{\"76\":1,\"77\":1}}],[\"福利\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2}}],[\"福建\",{\"1\":{\"76\":9,\"77\":9}}],[\"福州\",{\"1\":{\"76\":1,\"77\":1}}],[\"池州\",{\"1\":{\"76\":1,\"77\":1}}],[\"铜仁\",{\"1\":{\"76\":1,\"77\":1}}],[\"铜陵\",{\"1\":{\"76\":1,\"77\":1}}],[\"铜川\",{\"1\":{\"76\":1,\"77\":1}}],[\"滁州\",{\"1\":{\"76\":1,\"77\":1}}],[\"亳州\",{\"1\":{\"76\":1,\"77\":1}}],[\"阜阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"阜新\",{\"1\":{\"76\":1,\"77\":1}}],[\"宿州\",{\"1\":{\"76\":1,\"77\":1}}],[\"宿迁\",{\"1\":{\"76\":1,\"77\":1}}],[\"马鞍山\",{\"1\":{\"76\":1,\"77\":1}}],[\"淮北\",{\"1\":{\"76\":1,\"77\":1}}],[\"淮南\",{\"1\":{\"76\":1,\"77\":1}}],[\"淮安\",{\"1\":{\"76\":1,\"77\":1}}],[\"芜湖\",{\"1\":{\"76\":1,\"77\":1}}],[\"蚌埠\",{\"1\":{\"76\":1,\"77\":1}}],[\"合肥\",{\"1\":{\"76\":1,\"77\":1}}],[\"合并两个\",{\"1\":{\"75\":1}}],[\"舟山\",{\"1\":{\"76\":1,\"77\":1}}],[\"衢州\",{\"1\":{\"76\":1,\"77\":1}}],[\"金华\",{\"1\":{\"76\":1,\"77\":1}}],[\"金昌\",{\"1\":{\"76\":1,\"77\":1}}],[\"温州\",{\"1\":{\"76\":1,\"77\":1}}],[\"绍兴\",{\"1\":{\"76\":1,\"77\":1}}],[\"宁德\",{\"1\":{\"76\":1,\"77\":1}}],[\"宁波\",{\"1\":{\"76\":1,\"77\":1}}],[\"宁夏\",{\"1\":{\"76\":5,\"77\":5}}],[\"宁夏回族自治区\",{\"1\":{\"76\":1,\"77\":1}}],[\"嘉兴\",{\"1\":{\"76\":1,\"77\":1}}],[\"嘉峪关\",{\"1\":{\"76\":1,\"77\":1}}],[\"湖南\",{\"1\":{\"76\":14,\"77\":14}}],[\"湖州\",{\"1\":{\"76\":1,\"77\":1}}],[\"湖北\",{\"1\":{\"76\":17,\"77\":17}}],[\"浙江\",{\"1\":{\"76\":11,\"77\":11}}],[\"杭州\",{\"1\":{\"76\":1,\"77\":1}}],[\"神农架\",{\"1\":{\"76\":1,\"77\":1}}],[\"潜江\",{\"1\":{\"76\":1,\"77\":1}}],[\"仙桃\",{\"1\":{\"76\":1,\"77\":1}}],[\"恩施土家族苗族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"荆门\",{\"1\":{\"76\":1,\"77\":1}}],[\"荆州\",{\"1\":{\"76\":1,\"77\":1}}],[\"咸宁\",{\"1\":{\"76\":1,\"77\":1}}],[\"咸阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"黄山\",{\"1\":{\"76\":1,\"77\":1}}],[\"黄石\",{\"1\":{\"76\":1,\"77\":1}}],[\"黄冈\",{\"1\":{\"76\":1,\"77\":1}}],[\"黄南藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"孝感\",{\"1\":{\"76\":1,\"77\":1}}],[\"鄂州\",{\"1\":{\"76\":1,\"77\":1}}],[\"鄂尔多斯\",{\"1\":{\"76\":1,\"77\":1}}],[\"襄阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"武汉\",{\"1\":{\"76\":1,\"77\":1}}],[\"武威\",{\"1\":{\"76\":1,\"77\":1}}],[\"泰州\",{\"1\":{\"76\":1,\"77\":1}}],[\"泰安\",{\"1\":{\"76\":1,\"77\":1}}],[\"连接条件\",{\"1\":{\"207\":1,\"208\":2}}],[\"连接查询\",{\"1\":{\"206\":1}}],[\"连接\",{\"0\":{\"169\":1}}],[\"连接信息\",{\"1\":{\"139\":1}}],[\"连接到远程仓库\",{\"1\":{\"26\":1}}],[\"连云港\",{\"1\":{\"76\":1,\"77\":1}}],[\"徐州\",{\"1\":{\"76\":1,\"77\":1}}],[\"盐城\",{\"1\":{\"76\":1,\"77\":1}}],[\"扬州\",{\"1\":{\"76\":1,\"77\":1}}],[\"苏州\",{\"1\":{\"76\":1,\"77\":1}}],[\"镇江\",{\"1\":{\"76\":1,\"77\":1}}],[\"南宁\",{\"1\":{\"76\":1,\"77\":1}}],[\"南充\",{\"1\":{\"76\":1,\"77\":1}}],[\"南昌\",{\"1\":{\"76\":1,\"77\":1}}],[\"南平\",{\"1\":{\"76\":1,\"77\":1}}],[\"南通\",{\"1\":{\"76\":1,\"77\":1}}],[\"南京\",{\"1\":{\"76\":1,\"77\":1}}],[\"南阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"驻马店\",{\"1\":{\"76\":1,\"77\":1}}],[\"漯河\",{\"1\":{\"76\":1,\"77\":1}}],[\"濮阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"鹤壁\",{\"1\":{\"76\":1,\"77\":1}}],[\"鹤岗\",{\"1\":{\"76\":1,\"77\":1}}],[\"焦作\",{\"1\":{\"76\":1,\"77\":1}}],[\"商丘\",{\"1\":{\"76\":1,\"77\":1}}],[\"商洛\",{\"1\":{\"76\":1,\"77\":1}}],[\"洛阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"平台的具体实现必须要按照\",{\"1\":{\"432\":1}}],[\"平时为\",{\"1\":{\"393\":1}}],[\"平衡树\",{\"1\":{\"294\":1,\"295\":1}}],[\"平衡二叉树\",{\"1\":{\"221\":1}}],[\"平均值\",{\"1\":{\"195\":1}}],[\"平顶山\",{\"1\":{\"76\":1,\"77\":1}}],[\"平凉\",{\"1\":{\"76\":1,\"77\":1}}],[\"许昌\",{\"1\":{\"76\":1,\"77\":1}}],[\"河池\",{\"1\":{\"76\":1,\"77\":1}}],[\"河源\",{\"1\":{\"76\":1,\"77\":1}}],[\"河南\",{\"1\":{\"76\":18,\"77\":18}}],[\"河北\",{\"1\":{\"76\":11,\"77\":11}}],[\"郑州\",{\"1\":{\"76\":1,\"77\":1}}],[\"吴忠\",{\"1\":{\"76\":1,\"77\":1}}],[\"银川\",{\"1\":{\"76\":1,\"77\":1}}],[\"甘孜藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"甘南藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"甘肃\",{\"1\":{\"76\":14,\"77\":14}}],[\"陇南\",{\"1\":{\"76\":1,\"77\":1}}],[\"酒泉\",{\"1\":{\"76\":1,\"77\":1}}],[\"张三\",{\"1\":{\"189\":2}}],[\"张家界\",{\"1\":{\"76\":1,\"77\":1}}],[\"张家口\",{\"1\":{\"76\":1,\"77\":1}}],[\"张掖\",{\"1\":{\"76\":1,\"77\":1}}],[\"庆阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"兰州\",{\"1\":{\"76\":1,\"77\":1}}],[\"果洛藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"海南\",{\"1\":{\"76\":19,\"77\":19}}],[\"海南藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"海口\",{\"1\":{\"76\":1,\"77\":1}}],[\"海西蒙古族藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"海北藏族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"海东\",{\"1\":{\"76\":1,\"77\":1}}],[\"青海\",{\"1\":{\"76\":8,\"77\":8}}],[\"青岛\",{\"1\":{\"76\":1,\"77\":1}}],[\"林芝\",{\"1\":{\"76\":1,\"77\":1}}],[\"昌江黎族自治县\",{\"1\":{\"76\":1,\"77\":1}}],[\"昌都\",{\"1\":{\"76\":1,\"77\":1}}],[\"昌吉回族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"胡杨河市\",{\"1\":{\"76\":1,\"77\":1}}],[\"可响应中断式锁可调用方法\",{\"1\":{\"519\":1}}],[\"可中断\",{\"0\":{\"524\":1}}],[\"可中断式获取锁\",{\"0\":{\"519\":1}}],[\"可中断的获取锁以及超时获取锁等多种\",{\"1\":{\"504\":1}}],[\"可实际上\",{\"1\":{\"494\":1}}],[\"可使用锁或者\",{\"1\":{\"488\":1}}],[\"可使用在代码块和方法中\",{\"1\":{\"442\":1}}],[\"可无论运行多少次\",{\"1\":{\"441\":1}}],[\"可见即线程\",{\"1\":{\"444\":1}}],[\"可见性是指当一个线程修改了共享变量后\",{\"1\":{\"498\":1}}],[\"可见性\",{\"0\":{\"493\":1,\"498\":1},\"1\":{\"465\":1,\"467\":2}}],[\"可见性三个方面进行考虑\",{\"1\":{\"437\":1}}],[\"可见性带来的问题\",{\"1\":{\"349\":1}}],[\"可见\",{\"1\":{\"432\":1,\"433\":1,\"444\":1,\"467\":1,\"488\":1}}],[\"可运行线程\",{\"0\":{\"414\":1}}],[\"可运行\",{\"1\":{\"412\":1}}],[\"可用容量\",{\"1\":{\"393\":1}}],[\"可想而知\",{\"1\":{\"391\":1}}],[\"可传入一个\",{\"1\":{\"360\":1}}],[\"可能有以下的执行顺序\",{\"1\":{\"497\":1}}],[\"可能的执行时序如图所示\",{\"1\":{\"490\":1}}],[\"可能会被重排序到构造函数之外\",{\"1\":{\"487\":1}}],[\"可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展\",{\"1\":{\"346\":1}}],[\"可能出在数据\",{\"1\":{\"437\":1}}],[\"可能需要额外的逻辑或使用其他数据结构\",{\"1\":{\"228\":1}}],[\"可为string\",{\"1\":{\"324\":1}}],[\"可嵌套\",{\"1\":{\"159\":1}}],[\"可选\",{\"1\":{\"139\":1}}],[\"可视化管理界面\",{\"1\":{\"134\":1}}],[\"可拓展\",{\"1\":{\"134\":1}}],[\"可拓展性的特点\",{\"1\":{\"133\":1}}],[\"可修改\",{\"1\":{\"126\":1}}],[\"可克达拉市\",{\"1\":{\"76\":1,\"77\":1}}],[\"可以清楚地知道两点\",{\"1\":{\"513\":1}}],[\"可以归纳总结为这么几点\",{\"1\":{\"507\":1}}],[\"可以大致认为基本数据类型的访问读写具备原子性\",{\"1\":{\"494\":1}}],[\"可以作为扩展知识面掌握下\",{\"1\":{\"494\":1}}],[\"可以重排序\",{\"1\":{\"490\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"430\":1}}],[\"可以确保线程\",{\"1\":{\"488\":1}}],[\"可以进行赋值\",{\"1\":{\"478\":1}}],[\"可以分为成员变量以及方法局部变量\",{\"1\":{\"476\":1}}],[\"可以修饰变量\",{\"1\":{\"474\":1}}],[\"可以说是支撑起整个\",{\"1\":{\"450\":1}}],[\"可以用在方法上也可以使用在代码块中\",{\"1\":{\"442\":1}}],[\"可以这样理解二者的关系\",{\"1\":{\"506\":1}}],[\"可以这样理解\",{\"1\":{\"432\":1}}],[\"可以引申到线程间通信机制\",{\"1\":{\"428\":1}}],[\"可以引入另外一种数据结构\",{\"1\":{\"221\":1}}],[\"可以通俗的理解成接力\",{\"1\":{\"420\":1}}],[\"可以通过同步机制\",{\"1\":{\"429\":1}}],[\"可以通过\",{\"1\":{\"413\":1,\"432\":1,\"456\":1}}],[\"可以通过最上方的\",{\"1\":{\"47\":1}}],[\"可以理解成占位符\",{\"1\":{\"401\":1}}],[\"可以理解为\",{\"1\":{\"9\":1,\"393\":1,\"397\":1}}],[\"可以看出要想理解\",{\"1\":{\"505\":1}}],[\"可以看出被\",{\"1\":{\"482\":1}}],[\"可以看出来当前等待对象\",{\"1\":{\"420\":1}}],[\"可以看出\",{\"1\":{\"419\":1,\"484\":1}}],[\"可以看出这些方法实际上是通过调用\",{\"1\":{\"409\":1}}],[\"可以看出在处理器指令集能够支持\",{\"1\":{\"409\":1}}],[\"可以看这篇文章\",{\"1\":{\"408\":1,\"508\":1}}],[\"可以看下这里乘以\",{\"1\":{\"398\":1}}],[\"可以看到\",{\"1\":{\"516\":1}}],[\"可以看到上一页和下一页的按钮标签名称都为\",{\"1\":{\"92\":1}}],[\"可以看到下一页的按钮标签名称为\",{\"1\":{\"85\":1}}],[\"可以依次向上升级锁状态\",{\"1\":{\"391\":1}}],[\"可以指定线程对象唤醒指定的线程\",{\"1\":{\"387\":1}}],[\"可以持有多个等待队列\",{\"1\":{\"377\":1}}],[\"可以发现\",{\"1\":{\"377\":1}}],[\"可以发现有两个参数\",{\"1\":{\"81\":1}}],[\"可以被多个线程使用\",{\"1\":{\"354\":1}}],[\"可以有效的减少一部分不必要的锁竞争带来的上下文切换\",{\"1\":{\"348\":1}}],[\"可以有两种形式\",{\"1\":{\"169\":1}}],[\"可以减少上下文切换的时间\",{\"1\":{\"348\":1}}],[\"可以参照\",{\"1\":{\"348\":1}}],[\"可以参考这篇\",{\"1\":{\"403\":1}}],[\"可以参考\",{\"1\":{\"52\":1}}],[\"可以删除元素\",{\"1\":{\"329\":1}}],[\"可以删除变量\",{\"1\":{\"154\":1}}],[\"可以动态创建和使用对象\",{\"1\":{\"311\":1}}],[\"可以提前从循环中退出\",{\"1\":{\"247\":1}}],[\"可以定义多个变量\",{\"1\":{\"245\":1}}],[\"可以不加大括号\",{\"1\":{\"245\":1}}],[\"可以不指定排序方式asc\",{\"1\":{\"197\":1}}],[\"可以简单理解为循环版的\",{\"1\":{\"243\":1}}],[\"可以简写为\",{\"1\":{\"234\":5}}],[\"可以控制在小于等于\",{\"1\":{\"221\":1}}],[\"可以存储多个\",{\"1\":{\"221\":1}}],[\"可以选择平衡二叉树或者是红黑树来解决上述问题\",{\"1\":{\"221\":1}}],[\"可以是声明语句\",{\"1\":{\"245\":1}}],[\"可以是多列\",{\"1\":{\"213\":1}}],[\"可以是多行\",{\"1\":{\"212\":1}}],[\"可以是正解也可以是错解\",{\"1\":{\"54\":1}}],[\"可以\",{\"1\":{\"196\":1}}],[\"可以查看指定表的字段\",{\"1\":{\"184\":1}}],[\"可以加上参数\",{\"1\":{\"178\":1}}],[\"可以向脚本传递参数\",{\"1\":{\"158\":1}}],[\"可以取变量\",{\"1\":{\"156\":1}}],[\"可以将\",{\"1\":{\"280\":1}}],[\"可以将这张大表拆分成两张小表\",{\"1\":{\"201\":1}}],[\"可以将变量变为只读\",{\"1\":{\"153\":1}}],[\"可以将测试点设置为样例\",{\"1\":{\"52\":1}}],[\"可以换成其它任意字符串\",{\"1\":{\"149\":1}}],[\"可以在网上随便搜搜即可\",{\"1\":{\"399\":1}}],[\"可以在类的所有成员函数中调用\",{\"1\":{\"270\":1}}],[\"可以在创建表\",{\"1\":{\"182\":1}}],[\"可以在\",{\"1\":{\"146\":1}}],[\"可以多个线程共同使用一个\",{\"1\":{\"139\":1}}],[\"可以丢失任意\",{\"1\":{\"134\":1}}],[\"可以直接输出\",{\"1\":{\"261\":1}}],[\"可以直接跳到当前循环体的结尾\",{\"1\":{\"248\":1}}],[\"可以直接通过浏览器登录系统\",{\"1\":{\"134\":1}}],[\"可以直接修改package\",{\"1\":{\"23\":1}}],[\"可以使用stringbuilder和stringbuffer\",{\"1\":{\"262\":1}}],[\"可以使用各种类型的键\",{\"1\":{\"227\":1}}],[\"可以使用各种公有云提供的\",{\"1\":{\"133\":1}}],[\"可以使用\",{\"1\":{\"134\":1,\"176\":1,\"190\":1,\"275\":1,\"348\":1}}],[\"可以自定义修改\",{\"1\":{\"126\":1}}],[\"可以自己选择安装的路径\",{\"1\":{\"67\":1}}],[\"可以都勾选上\",{\"1\":{\"70\":1}}],[\"可以方便地对拍\",{\"1\":{\"44\":1}}],[\"可以为空\",{\"1\":{\"245\":2}}],[\"可以为\",{\"1\":{\"44\":1}}],[\"可以管理\",{\"1\":{\"41\":1}}],[\"北海\",{\"1\":{\"76\":1,\"77\":1}}],[\"北屯市\",{\"1\":{\"76\":1,\"77\":1}}],[\"北京\",{\"1\":{\"76\":2,\"77\":2}}],[\"北京市\",{\"1\":{\"76\":1,\"77\":1}}],[\"铁门关\",{\"1\":{\"76\":1,\"77\":1}}],[\"铁岭\",{\"1\":{\"76\":1,\"77\":1}}],[\"石嘴山\",{\"1\":{\"76\":1,\"77\":1}}],[\"石河子\",{\"1\":{\"76\":1,\"77\":1}}],[\"石家庄\",{\"1\":{\"76\":1,\"77\":1}}],[\"塔城地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"喀什地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"克孜勒苏柯尔克孜自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"克拉玛依\",{\"1\":{\"76\":1,\"77\":1}}],[\"阿坝藏族羌族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"阿里地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"阿拉尔\",{\"1\":{\"76\":1,\"77\":1}}],[\"阿拉善盟\",{\"1\":{\"76\":1,\"77\":1}}],[\"阿勒泰地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"阿克苏地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"哈希函数的选择\",{\"1\":{\"228\":1}}],[\"哈希函数会为每个键生成一个唯一的哈希值\",{\"1\":{\"226\":1}}],[\"哈希函数\",{\"1\":{\"226\":1}}],[\"哈希表是一种非常实用的数据结构\",{\"1\":{\"228\":1}}],[\"哈希表不保证元素的顺序\",{\"1\":{\"228\":1}}],[\"哈希表通常需要预留一定比例的空闲空间\",{\"1\":{\"228\":1}}],[\"哈希表通过以下几种方法来处理冲突\",{\"1\":{\"226\":1}}],[\"哈希表支持键值对的存储方式\",{\"1\":{\"227\":1}}],[\"哈希表可以根据需要动态调整大小\",{\"1\":{\"227\":1}}],[\"哈希表可以在常数时间\",{\"1\":{\"227\":1}}],[\"哈希表会在表中寻找下一个空闲位置来存储元素\",{\"1\":{\"226\":1}}],[\"哈希表使用一个哈希函数来计算键的哈希值\",{\"1\":{\"226\":1}}],[\"哈希表的工作原理\",{\"0\":{\"226\":1}}],[\"哈希表\",{\"0\":{\"225\":1},\"1\":{\"226\":1,\"294\":1,\"295\":1}}],[\"哈密\",{\"1\":{\"76\":1,\"77\":1}}],[\"哈尔滨\",{\"1\":{\"76\":1,\"77\":1}}],[\"吐鲁番\",{\"1\":{\"76\":1,\"77\":1}}],[\"伊犁哈萨克自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"伊春\",{\"1\":{\"76\":1,\"77\":1}}],[\"博客\",{\"1\":{\"132\":1}}],[\"博客搭建\",{\"0\":{\"15\":1}}],[\"博尔塔拉蒙古自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"巴中\",{\"1\":{\"76\":1,\"77\":1}}],[\"巴音郭楞蒙古自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"巴彦淖尔\",{\"1\":{\"76\":1,\"77\":1}}],[\"聊城\",{\"1\":{\"76\":1,\"77\":1}}],[\"枣庄\",{\"1\":{\"76\":1,\"77\":1}}],[\"威海\",{\"1\":{\"76\":1,\"77\":1}}],[\"滨州\",{\"1\":{\"76\":1,\"77\":1}}],[\"菏泽\",{\"1\":{\"76\":1,\"77\":1}}],[\"临界区用来表示一种公共资源或者说是共享数据\",{\"1\":{\"354\":1}}],[\"临界区\",{\"0\":{\"354\":1}}],[\"临高\",{\"1\":{\"76\":1,\"77\":1}}],[\"临沧\",{\"1\":{\"76\":1,\"77\":1}}],[\"临夏回族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"临沂\",{\"1\":{\"76\":1,\"77\":1}}],[\"临汾\",{\"1\":{\"76\":1,\"77\":1}}],[\"济源\",{\"1\":{\"76\":1,\"77\":1}}],[\"济宁\",{\"1\":{\"76\":1,\"77\":1}}],[\"济南\",{\"1\":{\"76\":1,\"77\":1}}],[\"潍坊\",{\"1\":{\"76\":1,\"77\":1}}],[\"烟台\",{\"1\":{\"76\":1,\"77\":1}}],[\"淄博\",{\"1\":{\"76\":1,\"77\":1}}],[\"山南\",{\"1\":{\"76\":1,\"77\":1}}],[\"山东\",{\"1\":{\"76\":16,\"77\":16}}],[\"山西\",{\"1\":{\"76\":11,\"77\":11}}],[\"宝鸡\",{\"1\":{\"76\":1,\"77\":1}}],[\"汉中\",{\"1\":{\"76\":1,\"77\":1}}],[\"渭南\",{\"1\":{\"76\":1,\"77\":1}}],[\"榆林\",{\"1\":{\"76\":1,\"77\":1}}],[\"延安\",{\"1\":{\"76\":1,\"77\":1}}],[\"延边朝鲜族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"陕西\",{\"1\":{\"76\":10,\"77\":10}}],[\"西双版纳傣族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"西宁\",{\"1\":{\"76\":1,\"77\":1}}],[\"西藏\",{\"1\":{\"76\":7,\"77\":7}}],[\"西藏自治区\",{\"1\":{\"76\":1,\"77\":1}}],[\"西安\",{\"1\":{\"76\":1,\"77\":1}}],[\"吕梁\",{\"1\":{\"76\":1,\"77\":1}}],[\"忻州\",{\"1\":{\"76\":1,\"77\":1}}],[\"朔州\",{\"1\":{\"76\":1,\"77\":1}}],[\"运算结果并不依赖于变量的当前值\",{\"1\":{\"494\":1}}],[\"运算等价于对长度\",{\"1\":{\"399\":1}}],[\"运算时会将其当做整数\",{\"1\":{\"259\":1}}],[\"运算符\",{\"0\":{\"234\":1},\"1\":{\"234\":1}}],[\"运城\",{\"1\":{\"76\":1,\"77\":1}}],[\"运行中的线程有时需要暂停\",{\"1\":{\"414\":1}}],[\"运行时异常都是\",{\"1\":{\"299\":1}}],[\"运行时异常和非运行时异常的区别\",{\"0\":{\"299\":1}}],[\"运行时环境\",{\"1\":{\"30\":1}}],[\"运行结果不同\",{\"1\":{\"284\":1}}],[\"运行方式\",{\"1\":{\"146\":1}}],[\"运行公开的读\",{\"1\":{\"141\":1}}],[\"运行jupyter\",{\"1\":{\"99\":1}}],[\"运行脚本后即可得到下述的各个数据\",{\"1\":{\"52\":1}}],[\"运行安装包\",{\"0\":{\"32\":1}}],[\"运行环境搭建\",{\"0\":{\"29\":1},\"1\":{\"16\":1}}],[\"运行和集成的平台\",{\"1\":{\"9\":1}}],[\"晋城\",{\"1\":{\"76\":1,\"77\":1}}],[\"晋中\",{\"1\":{\"76\":1,\"77\":1}}],[\"长度\",{\"1\":{\"185\":3}}],[\"长度不定\",{\"1\":{\"183\":1}}],[\"长文本数据\",{\"1\":{\"183\":1}}],[\"长沙\",{\"1\":{\"76\":1,\"77\":1}}],[\"长治\",{\"1\":{\"76\":1,\"77\":1}}],[\"长春\",{\"1\":{\"76\":1,\"77\":1}}],[\"太原\",{\"1\":{\"76\":1,\"77\":1}}],[\"秦皇岛\",{\"1\":{\"76\":1,\"77\":1}}],[\"邯郸\",{\"1\":{\"76\":1,\"77\":1}}],[\"邢台\",{\"1\":{\"76\":1,\"77\":1}}],[\"沧州\",{\"1\":{\"76\":1,\"77\":1}}],[\"廊坊\",{\"1\":{\"76\":1,\"77\":1}}],[\"唐山\",{\"1\":{\"76\":1,\"77\":1}}],[\"兴安盟\",{\"1\":{\"76\":1,\"77\":1}}],[\"锡林郭勒盟\",{\"1\":{\"76\":1,\"77\":1}}],[\"乌鲁木齐\",{\"1\":{\"76\":1,\"77\":1}}],[\"乌兰察布\",{\"1\":{\"76\":1,\"77\":1}}],[\"乌海\",{\"1\":{\"76\":1,\"77\":1}}],[\"呼伦贝尔\",{\"1\":{\"76\":1,\"77\":1}}],[\"呼和浩特\",{\"1\":{\"76\":1,\"77\":1}}],[\"赤峰\",{\"1\":{\"76\":1,\"77\":1}}],[\"葫芦岛\",{\"1\":{\"76\":1,\"77\":1}}],[\"朝阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"营口\",{\"1\":{\"76\":1,\"77\":1}}],[\"锦州\",{\"1\":{\"76\":1,\"77\":1}}],[\"丹东\",{\"1\":{\"76\":1,\"77\":1}}],[\"鞍山\",{\"1\":{\"76\":1,\"77\":1}}],[\"辽阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"辽宁\",{\"1\":{\"76\":14,\"77\":14}}],[\"辽源\",{\"1\":{\"76\":1,\"77\":1}}],[\"沈阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"白沙黎族自治县\",{\"1\":{\"76\":1,\"77\":1}}],[\"白银\",{\"1\":{\"76\":1,\"77\":1}}],[\"白杨市\",{\"1\":{\"76\":1,\"77\":1}}],[\"白山\",{\"1\":{\"76\":1,\"77\":1}}],[\"白城\",{\"1\":{\"76\":1,\"77\":1}}],[\"松原\",{\"1\":{\"76\":1,\"77\":1}}],[\"通俗点说\",{\"1\":{\"508\":1}}],[\"通信是指线程之间以何种机制来交换信息\",{\"1\":{\"428\":1}}],[\"通知后\",{\"1\":{\"421\":1}}],[\"通知方\",{\"1\":{\"380\":1}}],[\"通知\",{\"1\":{\"379\":1}}],[\"通知机制使用\",{\"1\":{\"385\":1}}],[\"通知机制\",{\"1\":{\"375\":3,\"380\":1}}],[\"通常来说如果\",{\"1\":{\"516\":1}}],[\"通常显示使用\",{\"1\":{\"504\":1}}],[\"通常每个类中的成员变量可以分为类变量\",{\"1\":{\"477\":1}}],[\"通常也可以利用\",{\"1\":{\"413\":1}}],[\"通常我们可以使用在\",{\"1\":{\"391\":1}}],[\"通常使用\",{\"1\":{\"364\":1}}],[\"通常可以用如下方式避免死锁的情况\",{\"1\":{\"349\":1}}],[\"通常减少上下文切换可以采用无锁并发编程\",{\"1\":{\"348\":1}}],[\"通常情况下\",{\"1\":{\"275\":1}}],[\"通常是用来做单表的拆分\",{\"1\":{\"201\":1}}],[\"通常封装到\",{\"1\":{\"198\":1}}],[\"通常通过基于\",{\"1\":{\"133\":1}}],[\"通配符\",{\"1\":{\"193\":1}}],[\"通用语法\",{\"0\":{\"171\":1}}],[\"通辽\",{\"1\":{\"76\":1,\"77\":1}}],[\"通化\",{\"1\":{\"76\":1,\"77\":1}}],[\"通过调用\",{\"1\":{\"520\":1}}],[\"通过可重写的方法\",{\"1\":{\"508\":1}}],[\"通过之前对\",{\"1\":{\"498\":1}}],[\"通过这个现象我们就可以看出来被\",{\"1\":{\"481\":1}}],[\"通过这个实验我们就可以看出来当\",{\"1\":{\"479\":1}}],[\"通过这个关系我们可以得出什么\",{\"1\":{\"444\":1}}],[\"通过上面的讨论大概能了解\",{\"1\":{\"446\":1}}],[\"通过上面的例子我们能够看出\",{\"1\":{\"479\":1}}],[\"通过上面的例子\",{\"1\":{\"428\":1}}],[\"通过主内存中的共享变量和线程\",{\"1\":{\"445\":1}}],[\"通过传递性规则进一步推导的\",{\"1\":{\"444\":1}}],[\"通过传入其他参数\",{\"1\":{\"324\":1}}],[\"通过读写共享变量实现两个线程间协作\",{\"1\":{\"428\":1}}],[\"通过一个整型成员变量\",{\"1\":{\"422\":1}}],[\"通过线程池创建\",{\"1\":{\"413\":1}}],[\"通过实现callable接口\",{\"1\":{\"413\":1}}],[\"通过实现\",{\"1\":{\"413\":2}}],[\"通过继承\",{\"1\":{\"413\":1}}],[\"通过持有头尾指针管理同步队列\",{\"1\":{\"513\":1}}],[\"通过持有头尾指针进行管理队列\",{\"1\":{\"408\":1}}],[\"通过持有等待队列的头尾指针来管理等待队列\",{\"1\":{\"377\":1}}],[\"通过看节点的\",{\"1\":{\"400\":1}}],[\"通过注释就很清楚了\",{\"1\":{\"397\":1}}],[\"通过底层\",{\"1\":{\"393\":1}}],[\"通过分别调用这两个方法然后\",{\"1\":{\"386\":1}}],[\"通过分析之后可以看出\",{\"1\":{\"443\":1}}],[\"通过分析\",{\"1\":{\"359\":1,\"377\":1}}],[\"通过使用\",{\"1\":{\"380\":1}}],[\"通过我们的猜想然后进行实验验证\",{\"1\":{\"377\":1}}],[\"通过获取自增\",{\"1\":{\"358\":1}}],[\"通过并发编程的形式可以将多核cpu的计算能力发挥到极致\",{\"1\":{\"346\":1}}],[\"通过引用找到变量的真正地址\",{\"1\":{\"273\":1}}],[\"通过下标访问数组\",{\"1\":{\"254\":1}}],[\"通过索引列对数据进行排序\",{\"1\":{\"220\":1}}],[\"通过逻辑外键\",{\"1\":{\"200\":1}}],[\"通过指令\",{\"1\":{\"175\":1}}],[\"通过数据库的优化来提高数据库的访问性能\",{\"1\":{\"173\":1}}],[\"通过数学算法将数据分割成多个数据块和校验块\",{\"1\":{\"134\":1}}],[\"通过直接爬取网页元素\",{\"1\":{\"95\":1}}],[\"通过对比两个网址\",{\"1\":{\"81\":1}}],[\"通过\",{\"1\":{\"47\":1,\"57\":2,\"377\":2,\"380\":1,\"399\":1,\"470\":1,\"508\":1,\"520\":1}}],[\"大多数情况下\",{\"1\":{\"453\":1}}],[\"大多数类型都能用作函数的返回类型\",{\"1\":{\"269\":1}}],[\"大家都去排队\",{\"1\":{\"446\":1}}],[\"大家可以尝试编写代码\",{\"1\":{\"95\":1}}],[\"大概有个了解\",{\"1\":{\"428\":1}}],[\"大师为我们提供了大量实用\",{\"1\":{\"503\":1}}],[\"大师为我们准备了\",{\"1\":{\"407\":1}}],[\"大师不遗余力的为我们创造了一些线程安全的并发容器\",{\"1\":{\"391\":1}}],[\"大部分只是读数据\",{\"1\":{\"364\":1}}],[\"大根堆\",{\"1\":{\"333\":1}}],[\"大根堆写法\",{\"1\":{\"293\":1}}],[\"大括号可以省略\",{\"1\":{\"239\":1}}],[\"大于等于\",{\"1\":{\"194\":1,\"239\":1}}],[\"大于\",{\"1\":{\"194\":1,\"239\":1}}],[\"大整数值\",{\"1\":{\"183\":3}}],[\"大小为10的数组\",{\"1\":{\"255\":1}}],[\"大小为3的数组\",{\"1\":{\"255\":1}}],[\"大小\",{\"1\":{\"183\":3}}],[\"大理白族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"大同\",{\"1\":{\"76\":1,\"77\":1}}],[\"大连\",{\"1\":{\"76\":1,\"77\":1}}],[\"大兴安岭地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"大庆\",{\"1\":{\"76\":1,\"77\":1}}],[\"双重检验锁\",{\"1\":{\"437\":1}}],[\"双端队列\",{\"0\":{\"332\":1},\"1\":{\"330\":1}}],[\"双链表\",{\"1\":{\"291\":1,\"293\":1}}],[\"双精度浮点数值\",{\"1\":{\"183\":1}}],[\"双引号字符串\",{\"1\":{\"156\":1}}],[\"双引号中的内容可以执行\",{\"1\":{\"156\":1}}],[\"双引号定义字符串\",{\"1\":{\"151\":1}}],[\"双河市\",{\"1\":{\"76\":1,\"77\":1}}],[\"双鸭山\",{\"1\":{\"76\":1,\"77\":1}}],[\"双击进行下一步即可\",{\"1\":{\"70\":1}}],[\"双击下载好的安装包\",{\"1\":{\"67\":1}}],[\"鸡西\",{\"1\":{\"76\":1,\"77\":1}}],[\"黑色的代表根据程序顺序规则推导出来\",{\"1\":{\"467\":1}}],[\"黑色的是通过程序顺序规则推导出来\",{\"1\":{\"444\":1}}],[\"黑河\",{\"1\":{\"76\":1,\"77\":1}}],[\"黑龙江\",{\"1\":{\"76\":13,\"77\":13}}],[\"绥化\",{\"1\":{\"76\":1,\"77\":1}}],[\"佳木斯\",{\"1\":{\"76\":1,\"77\":1}}],[\"牡丹江\",{\"1\":{\"76\":1,\"77\":1}}],[\"齐齐哈尔\",{\"1\":{\"76\":1,\"77\":1}}],[\"省\",{\"1\":{\"76\":1,\"77\":1}}],[\"新建线程\",{\"0\":{\"413\":1}}],[\"新建\",{\"1\":{\"401\":1,\"412\":1}}],[\"新建forwardingnode引用\",{\"1\":{\"401\":1}}],[\"新建node数组\",{\"1\":{\"401\":1}}],[\"新建了\",{\"1\":{\"377\":1,\"508\":1}}],[\"新建一个\",{\"1\":{\"146\":1}}],[\"新建一个node\",{\"1\":{\"34\":1}}],[\"新增的\",{\"1\":{\"304\":1}}],[\"新表名\",{\"1\":{\"185\":1}}],[\"新字段名\",{\"1\":{\"185\":1}}],[\"新数据类型\",{\"1\":{\"185\":1}}],[\"新闻报道\",{\"1\":{\"132\":1}}],[\"新余\",{\"1\":{\"76\":1,\"77\":1}}],[\"新乡\",{\"1\":{\"76\":1,\"77\":1}}],[\"新星市\",{\"1\":{\"76\":1,\"77\":1}}],[\"新疆\",{\"1\":{\"76\":26,\"77\":26}}],[\"新疆维吾尔自治区\",{\"1\":{\"76\":1,\"77\":1}}],[\"正如前面所言\",{\"1\":{\"432\":1}}],[\"正在执行占有锁而其他thread\",{\"1\":{\"508\":1}}],[\"正在进行扩容操作\",{\"1\":{\"399\":1}}],[\"正在进行初始化的线程会调用\",{\"1\":{\"398\":1}}],[\"正在等待被\",{\"1\":{\"349\":1}}],[\"正是因为这些优点\",{\"1\":{\"346\":1}}],[\"正是在畅想未来的时候\",{\"1\":{\"346\":1}}],[\"正确同步的多线程程序是按\",{\"1\":{\"432\":1}}],[\"正确\",{\"1\":{\"267\":1,\"268\":1}}],[\"正数表示大于\",{\"1\":{\"260\":1}}],[\"正则表达式进行替换\",{\"1\":{\"84\":1}}],[\"正则表达式获取数字\",{\"1\":{\"76\":1}}],[\"正解未\",{\"1\":{\"44\":1}}],[\"天门\",{\"1\":{\"76\":1,\"77\":1}}],[\"天水\",{\"1\":{\"76\":1,\"77\":1}}],[\"天津\",{\"1\":{\"76\":2,\"77\":2}}],[\"天津市\",{\"1\":{\"76\":1,\"77\":1}}],[\"天\",{\"1\":{\"76\":1,\"77\":1}}],[\"x86\",{\"1\":{\"489\":4}}],[\"xx\",{\"1\":{\"456\":2}}],[\"xxx\",{\"1\":{\"324\":5}}],[\"xml\",{\"1\":{\"129\":3,\"306\":1}}],[\"x64\",{\"1\":{\"129\":1}}],[\"xaxis\",{\"1\":{\"103\":1,\"104\":3,\"107\":4}}],[\"x\",{\"1\":{\"76\":7,\"77\":7,\"102\":6,\"104\":7,\"107\":13,\"111\":6,\"112\":6,\"115\":12,\"155\":1,\"233\":2,\"235\":5,\"236\":1,\"239\":4,\"243\":2,\"244\":3,\"256\":2,\"260\":1,\"270\":5,\"272\":5,\"276\":2,\"282\":9,\"283\":2,\"302\":2,\"303\":2,\"402\":6}}],[\"万用户\",{\"1\":{\"221\":1}}],[\"万条数据\",{\"1\":{\"221\":1}}],[\"万宁\",{\"1\":{\"76\":1,\"77\":1}}],[\"万\",{\"1\":{\"76\":2,\"77\":1}}],[\"千万条数据\",{\"1\":{\"221\":1}}],[\"千\",{\"1\":{\"76\":2,\"77\":1}}],[\"元老级的\",{\"1\":{\"449\":1}}],[\"元注解\",{\"0\":{\"308\":1}}],[\"元素\",{\"1\":{\"395\":1}}],[\"元素就不必实现\",{\"1\":{\"333\":1}}],[\"元素按自然顺序排序\",{\"1\":{\"328\":1}}],[\"元素乱序\",{\"1\":{\"328\":1}}],[\"元素的值均为0\",{\"1\":{\"253\":1}}],[\"元素分别是0\",{\"1\":{\"253\":1}}],[\"元素之间用空格隔开\",{\"1\":{\"161\":1}}],[\"元\",{\"1\":{\"76\":1,\"103\":1,\"104\":1,\"107\":2}}],[\"月\",{\"1\":{\"76\":1,\"104\":1,\"107\":1}}],[\"周口\",{\"1\":{\"76\":1,\"77\":1}}],[\"周\",{\"1\":{\"76\":2,\"77\":1}}],[\"日常我们在网站中看到的各种各样的分页条\",{\"1\":{\"198\":1}}],[\"日期等\",{\"1\":{\"211\":1}}],[\"日期值\",{\"1\":{\"183\":1}}],[\"日期时间类型\",{\"1\":{\"183\":2}}],[\"日期有\",{\"1\":{\"76\":1}}],[\"日志文件\",{\"1\":{\"132\":1}}],[\"日喀则\",{\"1\":{\"76\":1,\"77\":1}}],[\"日照\",{\"1\":{\"76\":1,\"77\":1}}],[\"日\",{\"1\":{\"76\":2,\"77\":1}}],[\"时才会执行方法\",{\"1\":{\"517\":1}}],[\"时才会继续\",{\"1\":{\"419\":1}}],[\"时能够将内存进行回收\",{\"1\":{\"517\":1}}],[\"时进行入队操作\",{\"1\":{\"516\":1}}],[\"时进行了补充\",{\"1\":{\"386\":1}}],[\"时就会调用已经被\",{\"1\":{\"507\":1}}],[\"时就会为\",{\"1\":{\"497\":1}}],[\"时非阻塞同步\",{\"1\":{\"451\":1}}],[\"时检查发现旧值并没有变化依然为\",{\"1\":{\"451\":1}}],[\"时需要考虑两个关键因素\",{\"1\":{\"435\":1}}],[\"时候\",{\"1\":{\"419\":1}}],[\"时候不加锁\",{\"1\":{\"403\":1}}],[\"时在多线程情况下扩容会出现\",{\"1\":{\"391\":1}}],[\"时遗漏了这一点\",{\"1\":{\"386\":1}}],[\"时都会调用\",{\"1\":{\"385\":1}}],[\"时知道同步队列是一个双向队列\",{\"1\":{\"377\":1}}],[\"时为非公平锁\",{\"1\":{\"360\":1}}],[\"时为公平锁\",{\"1\":{\"360\":1}}],[\"时锁才算成功释放\",{\"1\":{\"359\":1}}],[\"时间片当前线程依然会继续运行\",{\"1\":{\"422\":1}}],[\"时间片才会继续执行\",{\"1\":{\"421\":1}}],[\"时间片就会继续执行\",{\"1\":{\"421\":1}}],[\"时间片\",{\"1\":{\"398\":1,\"422\":1}}],[\"时间片一般是几十毫秒\",{\"1\":{\"348\":1}}],[\"时间片是\",{\"1\":{\"348\":1}}],[\"时间戳\",{\"1\":{\"183\":1}}],[\"时间值或持续时间\",{\"1\":{\"183\":1}}],[\"时间轴\",{\"2\":{\"124\":1}}],[\"时间轴的宽度\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"时间线\",{\"0\":{\"106\":1,\"114\":1,\"120\":1}}],[\"时\",{\"1\":{\"76\":2,\"77\":1,\"300\":2,\"393\":1,\"397\":1,\"399\":2,\"516\":1,\"517\":1}}],[\"智联招聘\",{\"0\":{\"87\":1},\"1\":{\"75\":1,\"93\":1,\"102\":1,\"107\":1,\"111\":1,\"115\":1},\"2\":{\"98\":1}}],[\"智能跳到下一行\",{\"1\":{\"71\":1}}],[\"关联\",{\"1\":{\"378\":1}}],[\"关联另外一方的主键\",{\"1\":{\"201\":1}}],[\"关系如下图所示\",{\"1\":{\"467\":1}}],[\"关系如图所示\",{\"1\":{\"444\":1}}],[\"关系后我们现在就来进一步分析\",{\"1\":{\"468\":1}}],[\"关系后\",{\"1\":{\"445\":1}}],[\"关系可知线程\",{\"1\":{\"444\":1}}],[\"关系并不代表了最终的执行顺序\",{\"1\":{\"433\":1}}],[\"关系给编写正确同步的多线程程序的程序员创造了一个幻境\",{\"1\":{\"432\":1}}],[\"关系保证正确同步的多线程程序的执行结果不被改变\",{\"1\":{\"432\":1}}],[\"关系本质上和\",{\"1\":{\"432\":1}}],[\"关系来执行的结果一致\",{\"1\":{\"432\":1}}],[\"关系指定的顺序来执行\",{\"1\":{\"432\":1}}],[\"关系向程序员提供跨线程的内存可见性保证\",{\"1\":{\"432\":1}}],[\"关系\",{\"0\":{\"444\":1,\"467\":1},\"1\":{\"202\":1,\"432\":3,\"433\":1,\"444\":3,\"467\":2}}],[\"关键信息请看注释\",{\"1\":{\"519\":1}}],[\"关键核心在于对队列同步器\",{\"1\":{\"505\":1}}],[\"关键操作\",{\"0\":{\"395\":1}}],[\"关键内部类\",{\"0\":{\"394\":1}}],[\"关键属性\",{\"0\":{\"393\":1}}],[\"关键属性及类\",{\"0\":{\"392\":1}}],[\"关键逻辑请看注释\",{\"1\":{\"379\":1}}],[\"关键\",{\"1\":{\"218\":1}}],[\"关键字所不具备的同步特性\",{\"1\":{\"504\":1}}],[\"关键字隐式加锁解锁的便捷性\",{\"1\":{\"504\":1}}],[\"关键字实现锁功能的\",{\"1\":{\"504\":1}}],[\"关键字之后独有的\",{\"1\":{\"443\":1}}],[\"关键字使得每次\",{\"1\":{\"429\":1}}],[\"关键字中\",{\"1\":{\"358\":1}}],[\"关键字\",{\"1\":{\"182\":1,\"494\":1}}],[\"关键词和城市名不能为空\",{\"1\":{\"86\":1,\"93\":1}}],[\"关键词\",{\"1\":{\"75\":2,\"86\":1,\"93\":1}}],[\"关闭终端后服务就会停止\",{\"1\":{\"129\":1}}],[\"关闭浏览器实例\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致\",{\"1\":{\"524\":1}}],[\"关于线程安全问题\",{\"1\":{\"427\":1}}],[\"关于扩容操作\",{\"1\":{\"399\":1}}],[\"关于这个在同步组件的实现中被频繁使用的\",{\"1\":{\"385\":1}}],[\"关于\",{\"1\":{\"379\":1,\"380\":1,\"397\":1,\"399\":1,\"408\":1,\"420\":1,\"488\":1}}],[\"关于锁降级下面的示例代码摘自\",{\"1\":{\"371\":1}}],[\"关于同步组件的实现层级结构可以看这篇文章\",{\"1\":{\"366\":1}}],[\"关于读写锁的特性\",{\"1\":{\"364\":1}}],[\"关于表结构的操作也是包含四个部分\",{\"1\":{\"179\":1}}],[\"关于翻页操作的参数\",{\"1\":{\"85\":1,\"92\":1}}],[\"关于中间件\",{\"1\":{\"9\":1}}],[\"对超时时间的处理上\",{\"1\":{\"520\":1}}],[\"对同步状态的管理的基石\",{\"1\":{\"512\":1}}],[\"对同一个监视器的解锁\",{\"1\":{\"444\":1}}],[\"对语句\",{\"1\":{\"494\":1}}],[\"对数组元素的写入可能看到也可能看不到\",{\"1\":{\"488\":1}}],[\"对数据结构做了进一步的优化\",{\"1\":{\"399\":1}}],[\"对底层的约束就很少\",{\"1\":{\"485\":1}}],[\"对底层尽量减少约束\",{\"1\":{\"430\":1}}],[\"对final引用数据类型person进行更改\",{\"1\":{\"479\":1}}],[\"对并发分析的切入点可以分为\",{\"1\":{\"467\":1}}],[\"对编译器和处理器的束缚已经尽可能少\",{\"1\":{\"435\":1}}],[\"对编译器和处理器不做要求\",{\"1\":{\"435\":1}}],[\"对编译器和处理器重排序的约束原则\",{\"1\":{\"432\":1}}],[\"对这两种不同性质的重排序\",{\"1\":{\"435\":1}}],[\"对线程\",{\"1\":{\"433\":1,\"445\":1}}],[\"对一个\",{\"1\":{\"433\":1,\"467\":1}}],[\"对一个锁的解锁\",{\"1\":{\"433\":1}}],[\"对程序员的承诺\",{\"1\":{\"432\":1}}],[\"对最终结果也不会存在关系\",{\"1\":{\"430\":1}}],[\"对当前线程进行中断操作\",{\"1\":{\"419\":1}}],[\"对当前容量大小进行检查\",{\"1\":{\"399\":2}}],[\"对红黑树进行操作的时候针对的是\",{\"1\":{\"399\":1}}],[\"对未来的一种预测\",{\"1\":{\"346\":1}}],[\"对浮点数四舍五入\",{\"1\":{\"335\":1}}],[\"对浮点数向下取整\",{\"1\":{\"335\":1}}],[\"对浮点数向上取整\",{\"1\":{\"335\":1}}],[\"对元素采用的是堆排序\",{\"1\":{\"333\":1}}],[\"对原来的list和返回的list做的\",{\"1\":{\"327\":1}}],[\"对形参的改动不会影响实参的初始值\",{\"1\":{\"272\":1}}],[\"对用户的基本信息查询频率特别的高\",{\"1\":{\"201\":1}}],[\"对用户而言\",{\"1\":{\"139\":2}}],[\"对null值不作为统计\",{\"1\":{\"195\":1}}],[\"对\",{\"1\":{\"139\":1,\"394\":1,\"399\":1,\"488\":3,\"489\":1,\"494\":2,\"516\":1}}],[\"对于能够支持多个线程同时访问的并发组件\",{\"1\":{\"523\":1}}],[\"对于底层而言\",{\"1\":{\"485\":1}}],[\"对于编译器来说\",{\"1\":{\"469\":1}}],[\"对于文章开头的现象\",{\"1\":{\"461\":1}}],[\"对于不会改变程序执行结果的重排序\",{\"1\":{\"435\":1}}],[\"对于会改变程序执行结果的重排序\",{\"1\":{\"435\":1}}],[\"对于像手机这样的小型设备可能使用协作式调度\",{\"1\":{\"414\":1}}],[\"对于这个估计值\",{\"1\":{\"402\":1}}],[\"对于\",{\"1\":{\"402\":1,\"436\":1}}],[\"对于数据库锁\",{\"1\":{\"349\":1}}],[\"对于第二层每个元素有指针\",{\"1\":{\"221\":1}}],[\"对于个人来说\",{\"1\":{\"133\":1}}],[\"对于企业来说\",{\"1\":{\"133\":1}}],[\"对应的关键字\",{\"1\":{\"200\":1}}],[\"对应的为省份名称和对应职位的工资\",{\"1\":{\"102\":1}}],[\"对应的文件找到了\",{\"1\":{\"89\":1}}],[\"对象头里的\",{\"1\":{\"452\":1}}],[\"对象头\",{\"0\":{\"452\":1}}],[\"对象监视器\",{\"1\":{\"443\":1}}],[\"对象监视器上只能拥有一个同步队列和一个等待队列\",{\"1\":{\"377\":1}}],[\"对象锁\",{\"0\":{\"443\":1}}],[\"对象的markword变化为下图\",{\"1\":{\"452\":1}}],[\"对象的对象头\",{\"1\":{\"452\":1}}],[\"对象的\",{\"1\":{\"413\":1,\"487\":1}}],[\"对象的入参会有什么不同的地方了\",{\"1\":{\"386\":1}}],[\"对象的eles方法获取页面中所有joblist\",{\"1\":{\"96\":1}}],[\"对象都天然继承于\",{\"1\":{\"375\":1}}],[\"对象来拼接\",{\"1\":{\"323\":1}}],[\"对象上\",{\"1\":{\"317\":1}}],[\"对象栈层次\",{\"1\":{\"301\":1}}],[\"对象代表异常原因\",{\"1\":{\"301\":1}}],[\"对象是通过\",{\"1\":{\"377\":1}}],[\"对象是类这种类型对应的实例\",{\"1\":{\"280\":1}}],[\"对象是单例的\",{\"1\":{\"139\":1}}],[\"对象中\",{\"1\":{\"198\":1}}],[\"对象即可实现对\",{\"1\":{\"139\":1}}],[\"对象\",{\"1\":{\"139\":2,\"375\":1,\"377\":2,\"386\":3,\"394\":2,\"397\":1,\"433\":1,\"487\":1}}],[\"对象存储可以作为主存储层\",{\"1\":{\"134\":1}}],[\"对象存储的读\",{\"1\":{\"134\":1}}],[\"对象存储\",{\"1\":{\"133\":1}}],[\"对象并生成对应的\",{\"1\":{\"75\":1}}],[\"对话中发送pycharm\",{\"1\":{\"69\":1}}],[\"创建型\",{\"0\":{\"537\":1}}],[\"创建型模式\",{\"2\":{\"344\":1}}],[\"创建线程池demo\",{\"1\":{\"413\":1}}],[\"创建一个\",{\"1\":{\"377\":1}}],[\"创建对象\",{\"1\":{\"325\":1}}],[\"创建索引\",{\"1\":{\"222\":1}}],[\"创建表时指定\",{\"1\":{\"200\":1}}],[\"创建表\",{\"1\":{\"179\":1}}],[\"创建数据库\",{\"0\":{\"176\":1}}],[\"创建文件\",{\"1\":{\"158\":1}}],[\"创建存储桶的时候\",{\"1\":{\"141\":1}}],[\"创建\",{\"0\":{\"180\":1},\"1\":{\"75\":1,\"174\":1}}],[\"创建项目\",{\"0\":{\"21\":1},\"1\":{\"16\":1}}],[\"全部为\",{\"1\":{\"394\":1}}],[\"全部用大写字符\",{\"1\":{\"260\":1}}],[\"全部用小写字符\",{\"1\":{\"260\":1}}],[\"全部字段\",{\"1\":{\"188\":1}}],[\"全部字段添加数据\",{\"1\":{\"188\":1}}],[\"全称\",{\"1\":{\"172\":1}}],[\"全局变量\",{\"1\":{\"155\":1}}],[\"全国招聘数量分布\",{\"1\":{\"111\":1,\"115\":1}}],[\"全国招聘工作数量可视化表\",{\"0\":{\"109\":1},\"1\":{\"114\":1,\"115\":1}}],[\"全国招聘工作工资分布可视化表\",{\"0\":{\"100\":1},\"1\":{\"106\":1,\"107\":1}}],[\"全国岗位平均工资\",{\"1\":{\"103\":1,\"107\":1}}],[\"全国各省份平均工资\",{\"1\":{\"102\":1,\"107\":1}}],[\"全国\",{\"1\":{\"75\":1}}],[\"全家桶\",{\"1\":{\"70\":1}}],[\"人工智能\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"人生苦短\",{\"1\":{\"65\":1}}],[\"保证原子性\",{\"1\":{\"494\":1}}],[\"保证每个线程都是操作的最新值\",{\"1\":{\"461\":1}}],[\"保证\",{\"1\":{\"423\":1,\"523\":1}}],[\"保证只有一个线程正在进行初始化操作\",{\"1\":{\"398\":1}}],[\"保证了系统更大的吞吐量\",{\"1\":{\"360\":1}}],[\"保证了即使在最坏的情况\",{\"1\":{\"134\":1}}],[\"保证请求资源时间上的绝对顺序\",{\"1\":{\"360\":1}}],[\"保证元素添加顺序\",{\"1\":{\"328\":1}}],[\"保证事务在不受外部并发操作影响的独立环境下运行\",{\"1\":{\"218\":1}}],[\"保证在一个事务中多次操作数据库表中数据时\",{\"1\":{\"216\":1}}],[\"保证数据的一致性和完整性\",{\"1\":{\"182\":1,\"200\":1}}],[\"保证字段的所有数据都是唯一\",{\"1\":{\"182\":1}}],[\"保护数据免受硬件故障和无声数据损坏\",{\"1\":{\"134\":1}}],[\"保存数据时\",{\"1\":{\"182\":1}}],[\"保存在字典内\",{\"1\":{\"96\":1}}],[\"保存合并且去重后的数据到新的\",{\"1\":{\"75\":1}}],[\"保亭黎族苗族自治县\",{\"1\":{\"76\":1,\"77\":1}}],[\"保山\",{\"1\":{\"76\":1,\"77\":1}}],[\"保定\",{\"1\":{\"76\":1,\"77\":1}}],[\"保持所有的默认设置\",{\"0\":{\"32\":1}}],[\"城市参数\",{\"1\":{\"95\":2}}],[\"城市参数网址\",{\"1\":{\"88\":1}}],[\"城市对应的省份\",{\"1\":{\"76\":1}}],[\"城市\",{\"1\":{\"75\":3,\"77\":2,\"85\":1,\"86\":3,\"92\":1,\"93\":3,\"96\":1}}],[\"城市字段去重\",{\"1\":{\"75\":1}}],[\"=f\",{\"1\":{\"243\":1,\"245\":1}}],[\"=2\",{\"1\":{\"243\":1,\"245\":1}}],[\"=>\",{\"1\":{\"217\":6,\"304\":2}}],[\"=<>>>=<<=\",{\"1\":{\"211\":1}}],[\"=yxc\",{\"1\":{\"161\":1}}],[\"=abc\",{\"1\":{\"161\":1}}],[\"=1\",{\"1\":{\"161\":1,\"243\":2,\"245\":2}}],[\"=400\",{\"1\":{\"111\":1,\"115\":1}}],[\"=0\",{\"1\":{\"111\":1,\"115\":1}}],[\"=60000\",{\"1\":{\"104\":1,\"107\":1}}],[\"=max\",{\"1\":{\"102\":1,\"107\":1}}],[\"=min\",{\"1\":{\"102\":1,\"107\":1}}],[\"===================================================\",{\"1\":{\"349\":1}}],[\"==\",{\"1\":{\"77\":1,\"84\":1,\"86\":2,\"91\":2,\"93\":3,\"102\":1,\"107\":2,\"111\":1,\"112\":1,\"115\":3,\"239\":6,\"240\":2,\"243\":1,\"247\":1,\"248\":1,\"249\":1,\"275\":1,\"303\":1,\"359\":3,\"360\":2,\"366\":2,\"367\":1,\"369\":4,\"370\":4,\"378\":1,\"379\":1,\"398\":4,\"399\":15,\"400\":4,\"401\":9,\"402\":5,\"497\":3,\"508\":4,\"516\":3,\"517\":1,\"518\":1,\"519\":1,\"520\":1,\"522\":1,\"523\":3}}],[\"==2\",{\"1\":{\"76\":1,\"77\":1}}],[\"=\",{\"1\":{\"75\":13,\"76\":16,\"77\":29,\"82\":1,\"84\":4,\"85\":8,\"86\":23,\"91\":4,\"92\":8,\"93\":23,\"96\":8,\"101\":14,\"102\":3,\"103\":2,\"104\":3,\"105\":1,\"106\":2,\"107\":25,\"111\":2,\"112\":2,\"113\":1,\"114\":1,\"115\":17,\"118\":7,\"119\":1,\"121\":10,\"139\":1,\"141\":5,\"142\":8,\"161\":1,\"189\":2,\"194\":2,\"198\":1,\"205\":1,\"210\":1,\"213\":1,\"221\":1,\"233\":7,\"234\":15,\"235\":7,\"236\":8,\"237\":1,\"239\":28,\"240\":7,\"241\":10,\"243\":12,\"244\":2,\"245\":14,\"247\":5,\"248\":2,\"249\":7,\"250\":1,\"252\":4,\"253\":3,\"254\":26,\"255\":7,\"256\":1,\"259\":5,\"260\":13,\"261\":3,\"262\":2,\"265\":3,\"266\":4,\"269\":1,\"270\":2,\"272\":2,\"273\":7,\"275\":4,\"276\":3,\"278\":2,\"282\":4,\"283\":2,\"284\":2,\"288\":1,\"289\":2,\"302\":8,\"303\":2,\"304\":4,\"310\":8,\"314\":5,\"316\":5,\"317\":11,\"318\":6,\"324\":16,\"325\":1,\"327\":4,\"328\":3,\"329\":4,\"330\":2,\"331\":1,\"332\":1,\"333\":4,\"338\":14,\"349\":4,\"359\":7,\"360\":5,\"366\":8,\"367\":3,\"369\":11,\"370\":8,\"371\":2,\"377\":2,\"378\":27,\"379\":15,\"381\":6,\"387\":1,\"393\":1,\"394\":4,\"397\":3,\"398\":9,\"399\":44,\"400\":15,\"401\":83,\"402\":27,\"408\":2,\"413\":5,\"419\":2,\"420\":5,\"423\":1,\"430\":3,\"441\":4,\"444\":2,\"445\":2,\"456\":2,\"461\":4,\"466\":1,\"467\":5,\"470\":3,\"479\":4,\"487\":6,\"488\":7,\"490\":4,\"494\":8,\"497\":2,\"504\":1,\"508\":4,\"513\":5,\"516\":16,\"517\":9,\"518\":12,\"519\":5,\"520\":8,\"522\":8,\"523\":4}}],[\"招聘网站\",{\"1\":{\"74\":1,\"79\":1}}],[\"招聘网站爬虫\",{\"0\":{\"61\":1},\"1\":{\"61\":1,\"64\":1}}],[\"爬取数据并写入csv\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"爬取\",{\"1\":{\"74\":1}}],[\"爬虫\",{\"2\":{\"63\":1,\"73\":1}}],[\"以实现内存可见性\",{\"1\":{\"498\":1}}],[\"以更高层次的指令\",{\"1\":{\"494\":1}}],[\"以下面的例子来说\",{\"1\":{\"490\":1}}],[\"以后该线程在进入和退出同步块时不需要进行\",{\"1\":{\"454\":1}}],[\"以保证内存可见性\",{\"1\":{\"408\":1}}],[\"以保持操作的效率\",{\"1\":{\"228\":1}}],[\"以减小\",{\"1\":{\"399\":1}}],[\"以非公平锁为例\",{\"1\":{\"359\":1}}],[\"以m为底取n的对数\",{\"1\":{\"335\":1}}],[\"以10为底取对数\",{\"1\":{\"335\":1}}],[\"以e为底取对数\",{\"1\":{\"335\":1}}],[\"以外的异常\",{\"1\":{\"299\":1}}],[\"以外的数据类型的对象\",{\"1\":{\"273\":1}}],[\"以适应数据的增减\",{\"1\":{\"227\":1}}],[\"以此来提高数据的操作效率\",{\"1\":{\"201\":1}}],[\"以此类推\",{\"1\":{\"158\":1}}],[\"以分号结尾\",{\"1\":{\"171\":1}}],[\"以便后面的\",{\"1\":{\"494\":1}}],[\"以便能够进行恢复先前状态\",{\"1\":{\"348\":1}}],[\"以便可以通过http访问\",{\"1\":{\"142\":1}}],[\"以便于软件各部件之间的沟通\",{\"1\":{\"9\":1}}],[\"以及对阻塞线程进行排队\",{\"1\":{\"512\":1}}],[\"以及对数据安全的保障服务\",{\"1\":{\"133\":1}}],[\"以及实例变量\",{\"1\":{\"477\":1}}],[\"以及重排序导致的问题\",{\"1\":{\"441\":1}}],[\"以及操作系统上\",{\"1\":{\"422\":1}}],[\"以及\",{\"1\":{\"391\":1,\"399\":1,\"467\":1,\"503\":2,\"506\":1}}],[\"以及在\",{\"1\":{\"385\":1}}],[\"以及存储桶索引\",{\"1\":{\"133\":1}}],[\"以及一些表格的例子pyecharts\",{\"1\":{\"99\":1}}],[\"以\",{\"1\":{\"118\":1,\"469\":1,\"489\":1}}],[\"以上三种新建线程的方式需要注意的是\",{\"1\":{\"413\":1}}],[\"以上就是\",{\"1\":{\"96\":1}}],[\"以上就是python+pycharm的详细安装过程\",{\"1\":{\"71\":1}}],[\"以上\",{\"1\":{\"82\":1}}],[\"以qurey=python\",{\"1\":{\"82\":1}}],[\"替换回到对象头\",{\"1\":{\"459\":1}}],[\"替换为指向锁记录的指针\",{\"1\":{\"458\":1}}],[\"替换占位符\",{\"1\":{\"324\":1}}],[\"替换字符串\",{\"1\":{\"260\":1}}],[\"替换字符\",{\"1\":{\"260\":1}}],[\"替换掉文件名中的非法字符\",{\"1\":{\"86\":1,\"93\":1}}],[\"替换\",{\"1\":{\"71\":2}}],[\"qq号码\",{\"1\":{\"185\":2}}],[\"qq\",{\"1\":{\"185\":6}}],[\"queue<e>\",{\"1\":{\"331\":1}}],[\"queue<>\",{\"1\":{\"293\":1}}],[\"queue\",{\"0\":{\"331\":1},\"1\":{\"331\":2,\"332\":2,\"366\":1,\"369\":1,\"377\":2,\"379\":1}}],[\"query\",{\"1\":{\"172\":1}}],[\"query=python\",{\"1\":{\"82\":1,\"86\":1}}],[\"quit\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"qurey代表求职信息即我们搜索框中输入的内容\",{\"1\":{\"81\":1}}],[\"qurey=python\",{\"1\":{\"81\":1}}],[\"q\",{\"1\":{\"71\":1,\"331\":1,\"332\":1}}],[\"选中时复制粘贴选中部分\",{\"1\":{\"71\":1}}],[\"选择运行该新线程\",{\"1\":{\"417\":1}}],[\"选择网络一栏\",{\"1\":{\"81\":1,\"82\":1}}],[\"选择第二种\",{\"1\":{\"67\":1}}],[\"选择代码和测试点就可以运行了\",{\"1\":{\"55\":1}}],[\"选择\",{\"1\":{\"27\":1,\"82\":1}}],[\"选择你想使用的源\",{\"1\":{\"22\":1}}],[\"选择包管理器\",{\"1\":{\"22\":1}}],[\"选择一些默认的配置\",{\"1\":{\"22\":1}}],[\"注定注解是否出出现在\",{\"1\":{\"308\":1}}],[\"注解的使用目的比较简单\",{\"1\":{\"306\":1}}],[\"注解不影响程序逻辑\",{\"1\":{\"306\":1}}],[\"注解\",{\"0\":{\"306\":1},\"1\":{\"306\":1}}],[\"注解与反射\",{\"0\":{\"305\":1}}],[\"注册为\",{\"1\":{\"139\":1}}],[\"注释内容\",{\"1\":{\"171\":2}}],[\"注释内容或\",{\"1\":{\"171\":1}}],[\"注释\",{\"0\":{\"147\":1},\"1\":{\"71\":2,\"171\":1,\"185\":2}}],[\"注意这里的是\",{\"1\":{\"488\":1}}],[\"注意不同点\",{\"1\":{\"470\":1}}],[\"注意不能直接用==\",{\"1\":{\"260\":1}}],[\"注意不加小括号\",{\"1\":{\"257\":1}}],[\"注意不是stdout\",{\"1\":{\"159\":1}}],[\"注意需要抛异常\",{\"1\":{\"236\":1,\"237\":1}}],[\"注意余数可能为负数\",{\"1\":{\"234\":1}}],[\"注意事项\",{\"1\":{\"189\":1,\"190\":1,\"196\":1,\"197\":1,\"198\":1,\"207\":1,\"208\":1,\"222\":1}}],[\"注意此处的\",{\"1\":{\"45\":1}}],[\"注意\",{\"1\":{\"22\":2,\"47\":1,\"49\":1,\"129\":1,\"176\":1,\"181\":1,\"182\":1,\"195\":1,\"241\":1,\"259\":1,\"413\":1,\"419\":1,\"432\":1,\"479\":1,\"487\":1,\"494\":1}}],[\"+1\",{\"1\":{\"402\":1}}],[\"+f\",{\"1\":{\"243\":1,\"245\":1}}],[\"++i\",{\"1\":{\"402\":1}}],[\"++hc\",{\"1\":{\"401\":1}}],[\"++lc\",{\"1\":{\"401\":1}}],[\"++bincount\",{\"1\":{\"399\":2}}],[\"++a\",{\"1\":{\"234\":1}}],[\"++\",{\"1\":{\"234\":1,\"235\":2,\"243\":3,\"245\":4,\"247\":1,\"248\":1,\"249\":5,\"254\":6,\"255\":3,\"260\":1,\"262\":1,\"265\":1,\"266\":1,\"273\":1,\"302\":2,\"314\":3,\"316\":2,\"317\":4,\"318\":1}}],[\"+x\",{\"1\":{\"126\":1,\"146\":1,\"155\":1,\"158\":1}}],[\"+city\",{\"1\":{\"77\":2}}],[\"+=\",{\"1\":{\"77\":5,\"118\":1,\"121\":1,\"234\":2,\"243\":1,\"245\":2,\"248\":1,\"260\":1,\"402\":1}}],[\"+\",{\"1\":{\"71\":7,\"76\":1,\"77\":1,\"84\":2,\"86\":2,\"91\":2,\"93\":2,\"102\":4,\"104\":2,\"107\":6,\"111\":2,\"115\":2,\"141\":5,\"221\":4,\"234\":3,\"235\":7,\"237\":2,\"239\":4,\"243\":1,\"245\":5,\"250\":1,\"254\":3,\"259\":1,\"260\":2,\"262\":1,\"270\":1,\"278\":1,\"288\":3,\"289\":3,\"304\":4,\"310\":1,\"314\":3,\"318\":3,\"323\":1,\"329\":1,\"359\":1,\"360\":1,\"366\":3,\"369\":1,\"381\":2,\"387\":1,\"395\":3,\"397\":3,\"401\":3,\"402\":6,\"419\":2,\"420\":1,\"441\":1,\"461\":1,\"479\":5,\"494\":1,\"520\":2}}],[\"常量\",{\"1\":{\"233\":1}}],[\"常作为临时表\",{\"1\":{\"214\":1}}],[\"常用方法\",{\"1\":{\"324\":1}}],[\"常用注解\",{\"0\":{\"307\":1}}],[\"常用容器\",{\"0\":{\"290\":1}}],[\"常用ascii值\",{\"1\":{\"259\":1}}],[\"常用api\",{\"0\":{\"257\":1,\"310\":1,\"315\":1,\"321\":1},\"1\":{\"260\":1}}],[\"常用比较运算符\",{\"1\":{\"239\":1}}],[\"常用聚合函数\",{\"1\":{\"195\":1}}],[\"常用的操作符\",{\"1\":{\"211\":1,\"212\":1,\"213\":1}}],[\"常用的逻辑运算符如下\",{\"1\":{\"194\":1}}],[\"常用的比较运算符如下\",{\"1\":{\"194\":1}}],[\"常用语言的\",{\"1\":{\"134\":1}}],[\"常用快捷键\",{\"0\":{\"71\":1}}],[\"常见的探测方法包括线性探测\",{\"1\":{\"226\":1}}],[\"常见的有\",{\"1\":{\"146\":1}}],[\"常见的有阿里云对象存储服务\",{\"1\":{\"133\":1}}],[\"常见中间件主要分为\",{\"1\":{\"9\":1}}],[\"常德\",{\"1\":{\"76\":1,\"77\":1}}],[\"常州\",{\"1\":{\"76\":1,\"77\":1}}],[\"首先获取头节点的后继节点\",{\"1\":{\"518\":1}}],[\"首先得了解下\",{\"1\":{\"512\":1}}],[\"首先要获得\",{\"1\":{\"443\":1}}],[\"首先会尝试多次计算\",{\"1\":{\"403\":1}}],[\"首先先看当前的\",{\"1\":{\"400\":1}}],[\"首先判断这个节点的类型\",{\"1\":{\"399\":1}}],[\"首先利用\",{\"1\":{\"399\":1}}],[\"首先对于每一个放入的值\",{\"1\":{\"399\":1}}],[\"首先在\",{\"1\":{\"399\":1}}],[\"首先\",{\"1\":{\"359\":1}}],[\"首先找到元素的位置\",{\"1\":{\"226\":1}}],[\"首先找到解压包下的安装包\",{\"1\":{\"70\":1}}],[\"首先计算元素键的哈希值\",{\"1\":{\"226\":1}}],[\"首先你需要创建一个\",{\"1\":{\"26\":1}}],[\"破解过程与idea一致\",{\"1\":{\"70\":1}}],[\"微信公众号搜索软件管家\",{\"1\":{\"69\":1}}],[\"涉及版权\",{\"1\":{\"69\":1}}],[\"警告\",{\"1\":{\"69\":1}}],[\"免费\",{\"1\":{\"68\":1}}],[\"只保证这个引用类型变量所引用的地址不会发生改变\",{\"1\":{\"479\":1}}],[\"只保留表关联部分的数据\",{\"1\":{\"205\":1}}],[\"只需简单地测试一下对象头的\",{\"1\":{\"454\":1}}],[\"只需要同步组件表达的\",{\"1\":{\"508\":1}}],[\"只需要同步组件返回的\",{\"1\":{\"508\":1}}],[\"只需要调用同步组件提供的方法来实现并发编程即可\",{\"1\":{\"508\":1}}],[\"只需要调用\",{\"1\":{\"412\":1}}],[\"只需要调整连接查询时\",{\"1\":{\"208\":1}}],[\"只需要\",{\"1\":{\"367\":1}}],[\"只需要使用逗号分隔多张表即可\",{\"1\":{\"205\":1}}],[\"只需要创建\",{\"1\":{\"139\":1}}],[\"只需要在最后面加上\",{\"1\":{\"126\":1}}],[\"只要不改变程序的执行结果\",{\"1\":{\"432\":1,\"435\":1}}],[\"只要函数的返回类型不是\",{\"1\":{\"276\":1}}],[\"只不过会当做正常的用户线程执行\",{\"1\":{\"423\":1}}],[\"只不过减少了对中断的处理\",{\"1\":{\"378\":1}}],[\"只是算出\",{\"1\":{\"397\":1}}],[\"只是想说明下我们刚才所想的\",{\"1\":{\"377\":1}}],[\"只是简单的获取了一下当前状态做了一些逻辑处理\",{\"1\":{\"360\":1}}],[\"只是项目名\",{\"1\":{\"45\":1}}],[\"只有源码会告诉我们答案\",{\"1\":{\"516\":1}}],[\"只有一个线程会成功\",{\"1\":{\"449\":1}}],[\"只有一个实例\",{\"0\":{\"341\":1}}],[\"只有守护线程的时候\",{\"1\":{\"423\":1}}],[\"只有在扩容的时候才为非\",{\"1\":{\"393\":1}}],[\"只有熟悉了源码的逻辑我们的理解才是最深的\",{\"1\":{\"378\":1}}],[\"只有被释放\",{\"1\":{\"359\":1}}],[\"只有当同步状态为0时\",{\"1\":{\"359\":1}}],[\"只有本类内部可以访问\",{\"1\":{\"282\":1}}],[\"只有表名存在时才会删除该表\",{\"1\":{\"186\":1}}],[\"只能保证一个共享变量的原子操作\",{\"1\":{\"451\":1}}],[\"只能通过切换时间片的方式交替进行\",{\"1\":{\"352\":1}}],[\"只能在函数内部使用\",{\"1\":{\"270\":1}}],[\"只能读取\",{\"1\":{\"260\":1}}],[\"只支持一维数组\",{\"1\":{\"160\":1}}],[\"只支持python开发\",{\"1\":{\"68\":1}}],[\"只读变量\",{\"0\":{\"153\":1},\"1\":{\"260\":1}}],[\"功能同方法\",{\"1\":{\"386\":3}}],[\"功能\",{\"1\":{\"194\":2,\"195\":1}}],[\"功能强大\",{\"1\":{\"68\":1}}],[\"功能非常完善\",{\"1\":{\"44\":1}}],[\"我想这样做的目的不仅仅是为了满足\",{\"1\":{\"401\":1}}],[\"我们学习到了独占式锁的获取和释放的过程以及同步队列\",{\"1\":{\"518\":1}}],[\"我们依旧先是通过看源码的方式\",{\"1\":{\"513\":1}}],[\"我们需要解决三个问题\",{\"1\":{\"513\":1}}],[\"我们先来分析一下不加\",{\"1\":{\"497\":1}}],[\"我们先来看这样一个例子\",{\"1\":{\"494\":1}}],[\"我们先来看看什么是不可变类\",{\"1\":{\"484\":1}}],[\"我们先来看看\",{\"1\":{\"399\":1}}],[\"我们再来分析\",{\"1\":{\"487\":1}}],[\"我们再搜索一个求职信息如\",{\"1\":{\"81\":1}}],[\"我们就可以重写\",{\"1\":{\"481\":1}}],[\"我们就不能重写该方法\",{\"1\":{\"481\":1}}],[\"我们就完成了编写代码的准备环节\",{\"1\":{\"82\":1}}],[\"我们利用这条规则推导下\",{\"1\":{\"467\":1}}],[\"我们已经知道了\",{\"1\":{\"467\":1}}],[\"我们想这个\",{\"1\":{\"466\":1}}],[\"我们俩的共享数据现在为\",{\"1\":{\"445\":1}}],[\"我们接下来看看基于\",{\"1\":{\"445\":1}}],[\"我们接下来就来依次看看几个常用的方法是怎样实现的\",{\"1\":{\"396\":1}}],[\"我们分析完\",{\"1\":{\"445\":1}}],[\"我们从三个方面做个总结\",{\"1\":{\"434\":1}}],[\"我们知道\",{\"1\":{\"429\":1,\"469\":1,\"519\":1}}],[\"我们知道对于一个\",{\"1\":{\"399\":1}}],[\"我们知道在锁机制的实现上\",{\"1\":{\"377\":1}}],[\"我们按照上面的分解的步骤一步步来看\",{\"1\":{\"399\":1}}],[\"我们用一个很简单的例子说说\",{\"1\":{\"381\":1}}],[\"我们都知道如果使用\",{\"1\":{\"386\":1}}],[\"我们都知道当当前线程调用\",{\"1\":{\"378\":1}}],[\"我们都要至少执行一次循环\",{\"1\":{\"244\":1}}],[\"我们还是从源码的角度去看\",{\"1\":{\"378\":1}}],[\"我们可以知道操作\",{\"1\":{\"467\":1}}],[\"我们可以多次调用\",{\"1\":{\"377\":1}}],[\"我们可以得出等待队列的示意图如下图所示\",{\"1\":{\"377\":1}}],[\"我们可以理清\",{\"1\":{\"359\":1}}],[\"我们会发现\",{\"1\":{\"377\":1}}],[\"我们几乎会高频率的使用到独占式锁\",{\"1\":{\"364\":1}}],[\"我们来画下存在的一种可能执行时序图\",{\"1\":{\"487\":1}}],[\"我们来通过看源码的方式来看这样的猜想是不是对的\",{\"1\":{\"379\":1}}],[\"我们来看看第\",{\"1\":{\"397\":1}}],[\"我们来看看公平锁的处理逻辑是怎样的\",{\"1\":{\"360\":1}}],[\"我们来看看\",{\"1\":{\"359\":1,\"484\":1}}],[\"我们来编写一个求阶乘的程序\",{\"1\":{\"265\":1}}],[\"我们的计算能力会按照指数级别的速度增长\",{\"1\":{\"346\":1}}],[\"我们要避免写出死循环\",{\"1\":{\"243\":1}}],[\"我们要操作某一个数据库下的表时\",{\"1\":{\"177\":1}}],[\"我们要操作某一个数据库\",{\"1\":{\"175\":1}}],[\"我们平常所说的索引\",{\"1\":{\"221\":1}}],[\"我们只需要在任意一方来添加一个外键就可以了\",{\"1\":{\"201\":1}}],[\"我们访问网址\",{\"1\":{\"82\":1}}],[\"我们随便搜索一个求职信息如\",{\"1\":{\"81\":1}}],[\"我们在获取城市代码的过程中可以获取到它对应的省\",{\"1\":{\"76\":1}}],[\"我们在招聘网站中获取到的数据\",{\"1\":{\"76\":1}}],[\"我们现在将两个网站数据进行合并\",{\"1\":{\"75\":1}}],[\"我们将项目生成至当前目录下的\",{\"1\":{\"22\":1}}],[\"我下载的是\",{\"1\":{\"68\":1}}],[\"black\",{\"1\":{\"394\":1}}],[\"blocked\",{\"1\":{\"386\":1,\"412\":1,\"417\":2,\"443\":2}}],[\"blocker\",{\"1\":{\"386\":4}}],[\"block\",{\"1\":{\"304\":1,\"369\":1,\"423\":3}}],[\"blob\",{\"1\":{\"134\":1,\"183\":1}}],[\"bmin\",{\"1\":{\"338\":1}}],[\"bmax\",{\"1\":{\"338\":1}}],[\"b3\",{\"1\":{\"324\":1}}],[\"b2\",{\"1\":{\"324\":2}}],[\"b1\",{\"1\":{\"324\":1}}],[\"bw\",{\"1\":{\"237\":3,\"304\":3}}],[\"b+tree\",{\"1\":{\"221\":8}}],[\"befor\",{\"1\":{\"444\":1}}],[\"before\",{\"0\":{\"426\":1,\"431\":1,\"432\":1,\"436\":1,\"444\":1,\"467\":1},\"1\":{\"371\":3,\"401\":2,\"432\":16,\"433\":14,\"434\":1,\"435\":4,\"436\":2,\"441\":1,\"444\":11,\"445\":3,\"467\":10,\"468\":1,\"517\":1}}],[\"be\",{\"1\":{\"379\":1,\"402\":2,\"517\":1}}],[\"been\",{\"1\":{\"379\":1}}],[\"because\",{\"1\":{\"369\":2,\"371\":1,\"402\":1}}],[\"beginindex\",{\"1\":{\"260\":2}}],[\"begin\",{\"1\":{\"217\":1,\"322\":5,\"324\":3}}],[\"between\",{\"1\":{\"194\":1}}],[\"bean\",{\"1\":{\"139\":2}}],[\"biasedlockingstartupdelay\",{\"1\":{\"456\":1}}],[\"bits\",{\"1\":{\"399\":1}}],[\"big\",{\"1\":{\"239\":3}}],[\"bigint\",{\"1\":{\"183\":1}}],[\"bincount\",{\"1\":{\"399\":10}}],[\"binarysearch\",{\"1\":{\"336\":1}}],[\"bin\",{\"1\":{\"146\":7,\"158\":1,\"399\":1}}],[\"backwards\",{\"1\":{\"518\":1}}],[\"backup\",{\"1\":{\"516\":1}}],[\"bash\",{\"1\":{\"146\":7,\"158\":1}}],[\"basecount\",{\"1\":{\"402\":6}}],[\"base\",{\"1\":{\"91\":1,\"93\":1,\"129\":3}}],[\"bar\",{\"1\":{\"104\":4,\"105\":1,\"107\":6,\"115\":1}}],[\"b\",{\"1\":{\"102\":1,\"104\":1,\"107\":2,\"111\":1,\"112\":1,\"115\":2,\"205\":1,\"206\":1,\"233\":1,\"234\":16,\"235\":4,\"239\":21,\"240\":5,\"243\":4,\"245\":4,\"252\":1,\"253\":2,\"255\":1,\"259\":4,\"260\":3,\"276\":3,\"277\":6,\"310\":2,\"324\":7,\"327\":1,\"335\":4,\"349\":8,\"401\":3,\"402\":3,\"429\":4,\"430\":6,\"432\":7,\"433\":11,\"435\":1,\"444\":6,\"445\":5,\"451\":1,\"461\":1,\"467\":5,\"468\":8,\"487\":15,\"488\":4,\"490\":1,\"494\":4,\"497\":2}}],[\"br\",{\"1\":{\"236\":2,\"304\":2}}],[\"break\",{\"0\":{\"247\":1},\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"241\":8,\"247\":1,\"249\":1,\"275\":1,\"378\":4,\"398\":1,\"399\":7,\"402\":1,\"523\":1}}],[\"brandindustry\",{\"1\":{\"85\":1,\"86\":1}}],[\"brandname\",{\"1\":{\"85\":1,\"86\":1}}],[\"btn\",{\"1\":{\"85\":3,\"86\":3,\"92\":8,\"93\":5}}],[\"bound\",{\"1\":{\"401\":3}}],[\"bourne\",{\"1\":{\"146\":2}}],[\"both\",{\"1\":{\"370\":1}}],[\"bottom=\",{\"1\":{\"105\":2,\"106\":1,\"107\":3,\"114\":1,\"115\":1}}],[\"bottom\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":2}}],[\"bob\",{\"1\":{\"324\":1}}],[\"boolean\",{\"1\":{\"141\":2,\"233\":1,\"247\":1,\"249\":1,\"318\":2,\"359\":3,\"360\":3,\"366\":1,\"367\":2,\"370\":1,\"375\":2,\"378\":2,\"379\":1,\"381\":1,\"394\":1,\"395\":1,\"399\":1,\"401\":2,\"402\":1,\"409\":2,\"467\":1,\"470\":1,\"505\":2,\"507\":2,\"508\":7,\"512\":4,\"516\":3,\"517\":2,\"518\":1,\"519\":1,\"520\":3,\"522\":2,\"523\":1}}],[\"border\",{\"1\":{\"112\":2,\"115\":2}}],[\"body\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"boss直聘\",{\"0\":{\"80\":1},\"1\":{\"75\":1,\"86\":1,\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"boss\",{\"1\":{\"75\":4,\"86\":4},\"2\":{\"98\":1}}],[\"byte\",{\"1\":{\"233\":1,\"324\":5,\"338\":2}}],[\"bytes\",{\"1\":{\"183\":10}}],[\"by\",{\"1\":{\"68\":1,\"129\":1,\"192\":4,\"196\":1,\"197\":2,\"349\":2,\"369\":2,\"371\":1,\"508\":1,\"518\":1}}],[\"busythread\",{\"1\":{\"419\":9}}],[\"busythread一直执行死循环\",{\"1\":{\"419\":1}}],[\"but\",{\"1\":{\"370\":1,\"517\":1,\"518\":1,\"523\":1}}],[\"bufferedwriter\",{\"1\":{\"237\":3,\"304\":2}}],[\"bufferedreader\",{\"1\":{\"236\":3,\"304\":2}}],[\"bucketlist\",{\"1\":{\"141\":2}}],[\"bucket已经存在\",{\"1\":{\"141\":1}}],[\"bucketname\",{\"1\":{\"141\":5}}],[\"bucketexistsargs\",{\"1\":{\"141\":2}}],[\"bucketexists\",{\"1\":{\"141\":3}}],[\"bucket\",{\"0\":{\"141\":1},\"1\":{\"133\":2,\"139\":6,\"141\":10,\"142\":7}}],[\"bundler\",{\"1\":{\"23\":2}}],[\"builder\",{\"1\":{\"139\":1,\"141\":5,\"142\":7}}],[\"build\",{\"1\":{\"23\":2,\"26\":1,\"139\":1,\"141\":5,\"142\":7}}],[\"由原子性变量操作\",{\"1\":{\"494\":1}}],[\"由此来确定这个值在\",{\"1\":{\"399\":1}}],[\"由\",{\"1\":{\"378\":1,\"444\":1}}],[\"由安全管理器抛出的异常\",{\"1\":{\"300\":1}}],[\"由0个或多个形参组成的列表以及函数体\",{\"1\":{\"264\":1}}],[\"由所有参数构成的用空格隔开的字符串\",{\"1\":{\"159\":1}}],[\"由于不会对有间接依赖性的操作重排序\",{\"1\":{\"489\":1}}],[\"由于一个\",{\"1\":{\"488\":1}}],[\"由于一个没有捕获到的异常终止了\",{\"1\":{\"416\":1}}],[\"由于对\",{\"1\":{\"488\":1}}],[\"由于这两个操作可以在一个线程之内\",{\"1\":{\"432\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"430\":1}}],[\"由于\",{\"1\":{\"413\":1,\"416\":1,\"430\":1,\"434\":1,\"487\":1}}],[\"由于锁会被获取\",{\"1\":{\"359\":1}}],[\"由于上下文切换也是个相对比较耗时的操作\",{\"1\":{\"348\":1}}],[\"由于业务之间相互关联\",{\"1\":{\"199\":1}}],[\"由于该网站招聘信息\",{\"1\":{\"94\":1}}],[\"由于我们在后面的可视化表格需要全称\",{\"1\":{\"76\":1}}],[\"由于专业版本需要付费\",{\"1\":{\"69\":1}}],[\"由于插件之间版本不同容易出现依赖冲突\",{\"1\":{\"23\":1}}],[\"由jetbrains开发而成\",{\"1\":{\"68\":1}}],[\"请求的方法不存在\",{\"1\":{\"300\":1}}],[\"请求的变量不存在\",{\"1\":{\"300\":1}}],[\"请输入搜索关键词\",{\"1\":{\"86\":1,\"93\":1}}],[\"请输入城市名\",{\"1\":{\"86\":1,\"93\":1}}],[\"请参照\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"119\":1,\"120\":1}}],[\"请参照公众号文章教程\",{\"1\":{\"70\":1}}],[\"请参考官方\",{\"1\":{\"49\":1,\"50\":1}}],[\"请不要勾选第六项\",{\"1\":{\"67\":1}}],[\"建立第三张中间表\",{\"1\":{\"202\":1}}],[\"建完表后\",{\"1\":{\"200\":1}}],[\"建议使用\",{\"1\":{\"330\":1}}],[\"建议别放在c盘\",{\"1\":{\"70\":1}}],[\"建议别安装在c盘\",{\"1\":{\"67\":1}}],[\"建议选择专业版\",{\"1\":{\"68\":1}}],[\"建议自定义安装\",{\"1\":{\"67\":1}}],[\"建好以后开始配置环境\",{\"1\":{\"34\":1}}],[\"第四种通过线程池新建线程后面单拎出来\",{\"1\":{\"413\":1}}],[\"第四个参数\",{\"1\":{\"158\":2}}],[\"第\",{\"1\":{\"399\":1}}],[\"第3行的初始值\",{\"1\":{\"255\":1}}],[\"第2行的初始值\",{\"1\":{\"255\":1}}],[\"第2种情况\",{\"1\":{\"217\":1}}],[\"第1行的初始值\",{\"1\":{\"255\":1}}],[\"第1种情况\",{\"1\":{\"217\":1}}],[\"第三层由\",{\"1\":{\"221\":1}}],[\"第三个参数\",{\"1\":{\"158\":2}}],[\"第三行注释\",{\"1\":{\"149\":3}}],[\"第二部分就是将原来\",{\"1\":{\"401\":1}}],[\"第二个实参初始化第二个形参\",{\"1\":{\"267\":1}}],[\"第二个参数\",{\"1\":{\"158\":2}}],[\"第二层一共是\",{\"1\":{\"221\":1}}],[\"第二行注释\",{\"1\":{\"149\":3}}],[\"第二种情况是当前节点被移动到了同步队列中\",{\"1\":{\"378\":1}}],[\"第二种写法\",{\"1\":{\"163\":2,\"164\":2}}],[\"第二种方法\",{\"1\":{\"155\":1}}],[\"第二种\",{\"1\":{\"67\":1}}],[\"第一部分是构建一个\",{\"1\":{\"401\":1}}],[\"第一件事自然而然就是\",{\"1\":{\"397\":1}}],[\"第一个实参初始化第一个形参\",{\"1\":{\"267\":1}}],[\"第一个对第二个数取余数\",{\"1\":{\"234\":1}}],[\"第一个数除以第二个数\",{\"1\":{\"234\":1}}],[\"第一个数乘以第二个数\",{\"1\":{\"234\":1}}],[\"第一个数减去第二个数\",{\"1\":{\"234\":1}}],[\"第一个数加上第二个数\",{\"1\":{\"234\":1}}],[\"第一个参数\",{\"1\":{\"158\":2}}],[\"第一张表存放的是用户的基本信息\",{\"1\":{\"201\":1}}],[\"第一行注释\",{\"1\":{\"149\":3}}],[\"第一种写法\",{\"1\":{\"163\":2,\"164\":2}}],[\"第一种方法\",{\"1\":{\"155\":1}}],[\"第一种\",{\"1\":{\"67\":1}}],[\"立即安装\",{\"1\":{\"67\":1}}],[\"好用等特点\",{\"1\":{\"65\":1}}],[\"都拥有所属同步器的引用\",{\"1\":{\"377\":1}}],[\"都链接一个链表\",{\"1\":{\"226\":1}}],[\"都是初始状态\",{\"1\":{\"468\":1}}],[\"都是为了在不改变程序执行结果的前提下\",{\"1\":{\"432\":1}}],[\"都是指默认的\",{\"1\":{\"221\":1}}],[\"都是使用逻辑外键\",{\"1\":{\"200\":1}}],[\"都可以描述字符串\",{\"1\":{\"183\":1}}],[\"都会被阻塞住\",{\"1\":{\"459\":1}}],[\"都会被写入到同一个日志文件中\",{\"1\":{\"126\":1}}],[\"都会被写入到这个日志文件中\",{\"1\":{\"126\":1}}],[\"都会有缓存\",{\"1\":{\"429\":1}}],[\"都会继续执行后面的代码\",{\"1\":{\"351\":1}}],[\"都会影响到彼此对方\",{\"1\":{\"327\":1}}],[\"都会警告\",{\"1\":{\"44\":1}}],[\"都符合标签\",{\"1\":{\"57\":1}}],[\"后线程\",{\"1\":{\"467\":1}}],[\"后再进行操作\",{\"1\":{\"466\":1}}],[\"后的\",{\"1\":{\"451\":1}}],[\"后的求职信息\",{\"1\":{\"74\":1}}],[\"后虚拟机才可以使用处理器提供的\",{\"1\":{\"449\":1}}],[\"后才能继续往下执行\",{\"1\":{\"443\":1}}],[\"后才会从\",{\"1\":{\"378\":1}}],[\"后清除标志位\",{\"1\":{\"419\":1}}],[\"后使得线程\",{\"1\":{\"380\":1}}],[\"后结束\",{\"1\":{\"378\":1}}],[\"后会使得当前线程从等待队列中移至到同步队列中去\",{\"1\":{\"378\":1}}],[\"后继节点不为null时唤醒该线程\",{\"1\":{\"518\":1}}],[\"后继节点的线程处于等待状态\",{\"1\":{\"513\":1}}],[\"后继节点\",{\"1\":{\"377\":1}}],[\"后者是语言级别的\",{\"1\":{\"375\":1}}],[\"后者则会在栈中创建一个对象引用变量\",{\"1\":{\"324\":1}}],[\"后移元素\",{\"1\":{\"327\":1}}],[\"后端需要响应什么数据给前端\",{\"1\":{\"198\":1}}],[\"后端开发\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"后续通过注入\",{\"1\":{\"139\":1}}],[\"后续通过调用\",{\"1\":{\"139\":1}}],[\"后续需要自定义\",{\"1\":{\"49\":1}}],[\"后台给前端返回的数据包含\",{\"1\":{\"198\":1}}],[\"后台也都需要借助于数据库的分页操作\",{\"1\":{\"198\":1}}],[\"后台服务安装\",{\"0\":{\"129\":1}}],[\"后台启动\",{\"1\":{\"126\":1}}],[\"后期数据处理很麻烦\",{\"1\":{\"94\":1}}],[\"后面编写代码需要\",{\"1\":{\"82\":1}}],[\"后面制作表格需要\",{\"1\":{\"77\":1}}],[\"后\",{\"1\":{\"57\":1,\"241\":1,\"399\":1,\"470\":1}}],[\"包的整体实现图如下图所示\",{\"1\":{\"503\":1}}],[\"包的结构层次\",{\"0\":{\"503\":1}}],[\"包的实现\",{\"1\":{\"450\":1}}],[\"包中的精华\",{\"1\":{\"503\":1}}],[\"包中的实现类也几乎都是用\",{\"1\":{\"450\":1}}],[\"包中提供了\",{\"1\":{\"451\":1}}],[\"包中利用\",{\"1\":{\"450\":1}}],[\"包中实现了\",{\"1\":{\"364\":1}}],[\"包装成一个线程安全的\",{\"1\":{\"391\":1}}],[\"包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程\",{\"1\":{\"435\":1}}],[\"包下\",{\"1\":{\"385\":1,\"503\":1}}],[\"包头\",{\"1\":{\"76\":1,\"77\":1}}],[\"包含三个值分别为\",{\"1\":{\"449\":1}}],[\"包含了三个步骤\",{\"1\":{\"494\":1}}],[\"包含了两个方面\",{\"1\":{\"435\":1}}],[\"包含了\",{\"1\":{\"413\":1}}],[\"包含了一道题的全部信息\",{\"1\":{\"57\":1}}],[\"包含达到78万6千多个像素\",{\"1\":{\"346\":1}}],[\"包含一组变量和函数\",{\"1\":{\"280\":1}}],[\"包含路径\",{\"1\":{\"158\":1}}],[\"包含小数\",{\"1\":{\"76\":1}}],[\"包括偏向锁\",{\"1\":{\"391\":1}}],[\"包括\",{\"1\":{\"324\":1}}],[\"包括整数\",{\"1\":{\"227\":1}}],[\"包括两张表交集部分数据\",{\"1\":{\"206\":2}}],[\"包括但不限于\",{\"1\":{\"132\":1}}],[\"包括新增\",{\"1\":{\"26\":1}}],[\"包括算法题\",{\"1\":{\"13\":1}}],[\"包括编程语言\",{\"1\":{\"2\":1}}],[\"会执行\",{\"1\":{\"522\":1}}],[\"会做什么事情了来保证自己能够有机会获得独占式锁了\",{\"1\":{\"516\":1}}],[\"会继续执行\",{\"1\":{\"523\":1}}],[\"会继续执行到\",{\"1\":{\"516\":1}}],[\"会继续检查占有线程是否为当前线程\",{\"1\":{\"359\":1}}],[\"会针对\",{\"1\":{\"508\":1}}],[\"会针对编译器制定\",{\"1\":{\"469\":1}}],[\"会认为当前线程获取同步组件成功直接返回\",{\"1\":{\"508\":1}}],[\"会有不同的操作\",{\"1\":{\"508\":1}}],[\"会重写该方法为\",{\"1\":{\"507\":1}}],[\"会重新从系统内存中把数据读到处理器缓存里\",{\"1\":{\"466\":1}}],[\"会发现\",{\"1\":{\"505\":1}}],[\"会通过在指令中添加\",{\"1\":{\"498\":1}}],[\"会禁止这两个操作的重排序\",{\"1\":{\"487\":1}}],[\"会禁止\",{\"1\":{\"487\":1}}],[\"会导致线程安全的问题吗\",{\"1\":{\"485\":1}}],[\"会导致等待的线程挂起\",{\"1\":{\"353\":1}}],[\"会带来一定的安全隐患\",{\"1\":{\"483\":1}}],[\"会出现报错\",{\"1\":{\"477\":1}}],[\"会限制特定类型的编译器和处理器重排序\",{\"1\":{\"469\":1}}],[\"会允许编译器和处理器对指令序列进行重排序\",{\"1\":{\"469\":1}}],[\"会先在当前线程的栈桢中创建用于存储锁记录的空间\",{\"1\":{\"458\":1}}],[\"会默认存放\",{\"1\":{\"452\":1}}],[\"会自旋\",{\"1\":{\"451\":1}}],[\"会自动创建主键索引\",{\"1\":{\"222\":1}}],[\"会检查旧值有没有变化\",{\"1\":{\"451\":1}}],[\"会首先先从主内存中读取共享变量\",{\"1\":{\"445\":1}}],[\"会改变程序执行结果的重排序\",{\"1\":{\"435\":1}}],[\"会让人感觉代码是一行一行顺序执行上\",{\"1\":{\"430\":1}}],[\"会遵守数据依赖性\",{\"1\":{\"430\":1}}],[\"会一直打印\",{\"1\":{\"423\":1}}],[\"会一直阻塞\",{\"1\":{\"420\":1}}],[\"会等待\",{\"1\":{\"420\":1}}],[\"会返回\",{\"1\":{\"419\":1}}],[\"会清除中断标志位\",{\"1\":{\"419\":1}}],[\"会调用\",{\"1\":{\"417\":1,\"507\":1}}],[\"会帮助\",{\"1\":{\"403\":1}}],[\"会进行怎样的重排序\",{\"1\":{\"485\":1}}],[\"会进一步对当前链表大小进行调整\",{\"1\":{\"399\":1}}],[\"会进入到这个\",{\"1\":{\"378\":1}}],[\"会对\",{\"1\":{\"399\":1,\"508\":1}}],[\"会判断当前\",{\"1\":{\"399\":1}}],[\"会将\",{\"1\":{\"394\":1}}],[\"会直接抛出异常\",{\"1\":{\"379\":1}}],[\"会使用原子的\",{\"1\":{\"459\":1}}],[\"会使当前线程释放\",{\"1\":{\"378\":1}}],[\"会使得当前线程释放\",{\"1\":{\"378\":1}}],[\"会优先使用局部变量\",{\"1\":{\"270\":1}}],[\"会在入队和出队的操作中获得更大的便捷性\",{\"1\":{\"516\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"469\":1}}],[\"会在对象头和栈帧中的锁记录里存储锁偏向的线程\",{\"1\":{\"454\":1}}],[\"会在自己的栈空间运行\",{\"1\":{\"441\":1}}],[\"会在超时之后继续执行\",{\"1\":{\"420\":1}}],[\"会在下一章解释\",{\"1\":{\"265\":1}}],[\"会在最下方提醒\",{\"1\":{\"55\":1}}],[\"会构造一个新的字符串\",{\"1\":{\"260\":1}}],[\"会顺次执行后面每个\",{\"1\":{\"241\":1}}],[\"会影响检索速度\",{\"1\":{\"221\":1}}],[\"会明确指出禁止使用物理外键\",{\"1\":{\"200\":1}}],[\"会根据业务需求及业务模块之间的关系\",{\"1\":{\"199\":1}}],[\"会提示询问是否确认删除所有数据\",{\"1\":{\"190\":1}}],[\"会报错\",{\"1\":{\"153\":1}}],[\"会话也不会被阻塞\",{\"1\":{\"126\":1}}],[\"会用黄色标识出来\",{\"1\":{\"55\":1}}],[\"有问题的语句是这条\",{\"1\":{\"497\":1}}],[\"有着\",{\"1\":{\"494\":1}}],[\"有着简单\",{\"1\":{\"65\":1}}],[\"有一些更方便的特性\",{\"1\":{\"519\":1}}],[\"有一个静态内部类\",{\"1\":{\"513\":1}}],[\"有一个直观的印象\",{\"1\":{\"494\":1}}],[\"有一个解决方案是利用对象整合多个共享变量\",{\"1\":{\"451\":1}}],[\"有一种的可能执行时序为下图\",{\"1\":{\"487\":1}}],[\"有两个知识点需要先关注\",{\"1\":{\"446\":1}}],[\"有两种情况\",{\"1\":{\"55\":1}}],[\"有的时候付款的时候在包里拿出钱包再去拿出钱\",{\"1\":{\"446\":1}}],[\"有什么解决方案\",{\"1\":{\"441\":1}}],[\"有如下代码\",{\"1\":{\"430\":1}}],[\"有如下优点\",{\"1\":{\"221\":1}}],[\"有可能就是一个未正确初始化的对象\",{\"1\":{\"487\":1}}],[\"有可能存在一个情况是多个线程同时走到这个方法中\",{\"1\":{\"398\":1}}],[\"有可能刚释放锁的线程能再次获取到锁\",{\"1\":{\"360\":1}}],[\"有意思的是\",{\"1\":{\"386\":1,\"489\":1}}],[\"有助于工程人员能够迅速发现问题解决问题\",{\"1\":{\"386\":1}}],[\"有兴趣的可以去看看\",{\"1\":{\"391\":1}}],[\"有兴趣的可以去查阅资料\",{\"1\":{\"386\":1}}],[\"有兴趣的可以直接去看源码\",{\"1\":{\"385\":1}}],[\"有兴趣可以看看\",{\"1\":{\"369\":1}}],[\"有这样几个问题\",{\"1\":{\"378\":1}}],[\"有序性和可见性\",{\"1\":{\"499\":1}}],[\"有序性\",{\"0\":{\"493\":1,\"495\":1},\"1\":{\"349\":1,\"437\":1,\"467\":1}}],[\"有序\",{\"1\":{\"336\":1}}],[\"有返回值的函数\",{\"0\":{\"276\":1}}],[\"有\",{\"1\":{\"221\":1}}],[\"有些内存可见性保证其实并不一定真实存在\",{\"1\":{\"435\":1}}],[\"有些操作系统甚至会忽略线程优先级的设定\",{\"1\":{\"422\":1}}],[\"有些业务操作要多次访问数据库\",{\"1\":{\"216\":1}}],[\"有些需要进行处理\",{\"1\":{\"76\":1}}],[\"有升序排序\",{\"1\":{\"197\":1}}],[\"有符号\",{\"1\":{\"183\":1}}],[\"有效性和完整性\",{\"1\":{\"182\":1}}],[\"有十分完善的官方文档\",{\"1\":{\"134\":1}}],[\"有别于boss直聘\",{\"1\":{\"89\":1}}],[\"有版本管理系统\",{\"1\":{\"44\":1}}],[\"了同步状态的修改\",{\"1\":{\"508\":1}}],[\"了在读\",{\"1\":{\"487\":1}}],[\"了\",{\"1\":{\"55\":1,\"497\":1}}],[\"评测状态\",{\"1\":{\"55\":1}}],[\"之前的方式是\",{\"1\":{\"446\":1}}],[\"之前\",{\"1\":{\"403\":1,\"432\":1,\"487\":1}}],[\"之前学习过\",{\"1\":{\"378\":1}}],[\"之前数据清洗过之后的文件\",{\"1\":{\"101\":1}}],[\"之间可以插入其他指令\",{\"1\":{\"494\":1}}],[\"之间进行了一次通信\",{\"1\":{\"468\":1}}],[\"之间进行分析\",{\"1\":{\"364\":1}}],[\"之间存在数据竞争\",{\"1\":{\"488\":1}}],[\"之间存在\",{\"1\":{\"432\":1}}],[\"之间没有数据依赖性\",{\"1\":{\"430\":1,\"487\":1,\"490\":1}}],[\"之间没有任何关系\",{\"1\":{\"430\":1}}],[\"之间要完成通信的话\",{\"1\":{\"429\":1}}],[\"之间以及\",{\"1\":{\"364\":1}}],[\"之间\",{\"1\":{\"364\":1}}],[\"之间的数据是相互隔离的\",{\"1\":{\"139\":1}}],[\"之后将数据重新写回到主内存中\",{\"1\":{\"429\":1}}],[\"之后后面也会用单独的一篇文章进行解析\",{\"1\":{\"380\":1}}],[\"之后的读写操作均使用位于工作内存的变量副本\",{\"1\":{\"429\":1}}],[\"之后的操作的\",{\"1\":{\"379\":1}}],[\"之后的操作都是针对这个节点\",{\"1\":{\"379\":1}}],[\"之后的内容均是注释\",{\"1\":{\"148\":1}}],[\"之后\",{\"1\":{\"210\":3,\"304\":1,\"504\":1}}],[\"之后可以在列表里点进去\",{\"1\":{\"55\":1}}],[\"之类的\",{\"1\":{\"55\":1}}],[\"之类的来表示在一个范围内随机选择\",{\"1\":{\"53\":1}}],[\"并重写需要的\",{\"1\":{\"508\":1}}],[\"并成功更新\",{\"1\":{\"449\":1}}],[\"并成功返回\",{\"1\":{\"433\":1}}],[\"并不能保证原子性\",{\"1\":{\"494\":1}}],[\"并不意味着\",{\"1\":{\"432\":1}}],[\"并不是武断的间线程挂起\",{\"1\":{\"449\":1}}],[\"并不是代表当前线程不再运行了\",{\"1\":{\"422\":1}}],[\"并不是线程安全的\",{\"1\":{\"391\":1}}],[\"并在某个时刻将工作内存的变量副本写回到主存中去\",{\"1\":{\"429\":1}}],[\"并在单线程里维持多个任务间的切换\",{\"1\":{\"348\":1}}],[\"并没有初始化成功\",{\"1\":{\"497\":1}}],[\"并没有\",{\"1\":{\"443\":1}}],[\"并没有打印\",{\"1\":{\"423\":1}}],[\"并没有考虑到当前同步队列中线程等待的情况\",{\"1\":{\"360\":1}}],[\"并等待这下次分配\",{\"1\":{\"422\":1}}],[\"并等待被\",{\"1\":{\"349\":1}}],[\"并给另一个线程一个机会来运行\",{\"1\":{\"414\":1}}],[\"并拥有\",{\"1\":{\"394\":1}}],[\"并由于\",{\"1\":{\"381\":1}}],[\"并通知所有的等待线程后释放锁\",{\"1\":{\"381\":1}}],[\"并通过重写同步器\",{\"1\":{\"366\":1}}],[\"并省略了\",{\"1\":{\"378\":1}}],[\"并行程序会比串行程序更适应业务需求\",{\"1\":{\"346\":1}}],[\"并行多图\",{\"0\":{\"105\":1,\"113\":1}}],[\"并发包中增加了\",{\"1\":{\"504\":1}}],[\"并发容器之\",{\"0\":{\"390\":1,\"406\":1}}],[\"并发编程\",{\"0\":{\"539\":1},\"2\":{\"355\":1,\"361\":1,\"372\":1,\"382\":1,\"388\":1,\"404\":1,\"410\":1,\"424\":1,\"438\":1,\"462\":1,\"471\":1,\"491\":1,\"500\":1,\"509\":1,\"525\":1}}],[\"并发编程有哪些缺点\",{\"0\":{\"347\":1}}],[\"并发指的是多个任务交替进行\",{\"1\":{\"352\":1}}],[\"并发和并行是十分容易混淆的概念\",{\"1\":{\"352\":1}}],[\"并发与并行\",{\"0\":{\"352\":1}}],[\"并发累加未必会比串行累加速度要快\",{\"1\":{\"348\":1}}],[\"并发\",{\"1\":{\"346\":1}}],[\"并发的优缺点\",{\"0\":{\"345\":1}}],[\"并调整堆\",{\"1\":{\"333\":1}}],[\"并令引用变量\",{\"1\":{\"324\":1}}],[\"并提供了修改字符串的方法\",{\"1\":{\"323\":1}}],[\"并提供标准接口\",{\"1\":{\"9\":1}}],[\"并填入arr的值\",{\"1\":{\"322\":1}}],[\"并唤醒被该锁阻塞的其他线程\",{\"1\":{\"316\":1}}],[\"并返回原来的值\",{\"1\":{\"329\":1}}],[\"并返回删除元素e\",{\"1\":{\"327\":1}}],[\"并返回栈顶元素\",{\"1\":{\"292\":1}}],[\"并返回\",{\"1\":{\"265\":1}}],[\"并可能需要处理冲突链表或调整开放寻址中的空闲位置\",{\"1\":{\"226\":1}}],[\"并将对象头中的\",{\"1\":{\"458\":1}}],[\"并将该对象转换为\",{\"1\":{\"198\":1}}],[\"并将这些块分散存储在不同的磁盘上\",{\"1\":{\"134\":1}}],[\"并形成一个全局的命名空间\",{\"1\":{\"134\":1}}],[\"并且该节点的状态值不为\",{\"1\":{\"518\":1}}],[\"并且能够获得同步状态的话\",{\"1\":{\"517\":1}}],[\"并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息\",{\"1\":{\"513\":1}}],[\"并且重写了\",{\"1\":{\"508\":1}}],[\"并且还有一个同步静态方法\",{\"1\":{\"443\":1}}],[\"并且已经知道出现线程安全的主要来源于\",{\"1\":{\"441\":1}}],[\"并且会把位于主存中的共享变量拷贝到自己的工作内存\",{\"1\":{\"429\":1}}],[\"并且需要注意的是设置守护线程要先于\",{\"1\":{\"423\":1}}],[\"并且再次获得\",{\"1\":{\"421\":1}}],[\"并且线程调度器允许该线程持有这个锁时\",{\"1\":{\"415\":1}}],[\"并且线程状态转换为等待状态\",{\"1\":{\"377\":1}}],[\"并且都是用volatile进行修饰的\",{\"1\":{\"408\":1}}],[\"并且防止拉链过长导致性能下降\",{\"1\":{\"403\":1}}],[\"并且更新\",{\"1\":{\"401\":1}}],[\"并且判断是否需要\",{\"1\":{\"401\":1}}],[\"并且当前\",{\"1\":{\"399\":1}}],[\"并且不为\",{\"1\":{\"399\":1}}],[\"并且具有\",{\"1\":{\"394\":1}}],[\"并且大量使用了\",{\"1\":{\"391\":1}}],[\"并且可在线程中使用\",{\"1\":{\"385\":1}}],[\"并且可以在语句执行完毕后确保每个资源都被自动关闭\",{\"1\":{\"304\":1}}],[\"并且可以一键把这组数据加到\",{\"1\":{\"53\":1}}],[\"并且相同索引对应的元素都相同\",{\"1\":{\"322\":1}}],[\"并且底层已经实现了按照索引进行排序\",{\"1\":{\"221\":1}}],[\"并且设置外键为唯一的\",{\"1\":{\"201\":1}}],[\"并且除了\",{\"1\":{\"134\":1}}],[\"并且支持跨越多个数据中心\",{\"1\":{\"134\":1}}],[\"并且忽略挂起\",{\"1\":{\"126\":1}}],[\"并且\",{\"1\":{\"57\":1,\"134\":1,\"194\":1,\"429\":1,\"433\":1,\"444\":1,\"467\":1,\"517\":1}}],[\"即能成功获得同步状态\",{\"1\":{\"522\":1}}],[\"即能看到\",{\"1\":{\"488\":1}}],[\"即线程阻塞时该线程被中断\",{\"1\":{\"519\":1}}],[\"即线程之间保证同步关系\",{\"1\":{\"442\":1}}],[\"即与队列断开\",{\"1\":{\"517\":1}}],[\"即当前线程是第一次插入同步队列\",{\"1\":{\"516\":1}}],[\"即当前线程获取该锁再次获取不会被阻塞\",{\"1\":{\"358\":1}}],[\"即该同步组件没被任何线程获取\",{\"1\":{\"508\":1}}],[\"即该旧值\",{\"1\":{\"449\":1}}],[\"即禁止\",{\"1\":{\"488\":1}}],[\"即是一个常量\",{\"1\":{\"479\":1}}],[\"即一直引用这个对象\",{\"1\":{\"479\":1}}],[\"即一个类中的成员变量就是这几个共享变量\",{\"1\":{\"451\":1}}],[\"即满足数据的\",{\"1\":{\"467\":1}}],[\"即不会出现数据脏读的现象\",{\"1\":{\"465\":1}}],[\"即获取到对象的锁\",{\"1\":{\"452\":1}}],[\"即获取到lock\",{\"1\":{\"378\":1}}],[\"即假设每一次执行临界区代码都会产生冲突\",{\"1\":{\"448\":1}}],[\"即表现为互斥性\",{\"1\":{\"446\":1}}],[\"即监视器锁规则\",{\"1\":{\"444\":1}}],[\"即在同一锁程中\",{\"1\":{\"443\":1}}],[\"即同一时刻只有一个线程能够获取到\",{\"1\":{\"443\":1}}],[\"即同一时刻该锁可以被多个读线程获取也就是一种共享式锁\",{\"1\":{\"369\":1}}],[\"即执行结果不能被改变\",{\"1\":{\"432\":1}}],[\"即执行一条\",{\"1\":{\"217\":1}}],[\"即等待获取锁的时候\",{\"1\":{\"417\":1}}],[\"即等待队列中的头结点\",{\"1\":{\"377\":1}}],[\"即插入\",{\"1\":{\"399\":1}}],[\"即正在初始化的状态\",{\"1\":{\"398\":1}}],[\"即32\",{\"1\":{\"397\":1}}],[\"即table数组还未初始化\",{\"1\":{\"397\":1}}],[\"即数组长度为默认初始值\",{\"1\":{\"393\":1}}],[\"即从\",{\"1\":{\"379\":1}}],[\"即另外线程调用的\",{\"1\":{\"378\":1}}],[\"即取同步状态的高\",{\"1\":{\"366\":1}}],[\"即取同步状态的低\",{\"1\":{\"366\":1}}],[\"即为数组实际大小\",{\"1\":{\"398\":1}}],[\"即为\",{\"1\":{\"366\":1}}],[\"即出现脏读\",{\"1\":{\"364\":1}}],[\"即时将所有的像素遍历一边都需要很长的时间\",{\"1\":{\"346\":1}}],[\"即使在多个线程一起执行的时候\",{\"1\":{\"494\":1}}],[\"即使负载因子和\",{\"1\":{\"399\":1}}],[\"即使两个形参的类型一样\",{\"1\":{\"268\":1}}],[\"即使你退出了终端或关闭了会话\",{\"1\":{\"126\":1}}],[\"即索引\",{\"1\":{\"226\":1}}],[\"即\",{\"1\":{\"221\":1,\"300\":1,\"366\":2,\"369\":1,\"379\":1,\"397\":1,\"401\":1,\"419\":1,\"430\":2,\"433\":1,\"461\":1,\"490\":1,\"513\":1,\"516\":1,\"520\":1,\"523\":1}}],[\"即这些操作要么同时成功\",{\"1\":{\"216\":1}}],[\"即丢失一半数量的硬盘的情况下仍能保证数据的安全性\",{\"1\":{\"134\":1}}],[\"即输出到\",{\"1\":{\"126\":1}}],[\"即采用默认安装方式\",{\"1\":{\"67\":1}}],[\"即可以获得独占式锁\",{\"1\":{\"516\":1}}],[\"即可以获取当前最新值\",{\"1\":{\"466\":1}}],[\"即可\",{\"1\":{\"126\":1,\"139\":1,\"190\":2,\"378\":1,\"449\":1,\"508\":2}}],[\"即可进行打包\",{\"1\":{\"57\":1}}],[\"即可在本地访问你的blog\",{\"1\":{\"23\":1}}],[\"即展示在题面中\",{\"1\":{\"52\":1}}],[\"其返回值是一个int类型\",{\"1\":{\"522\":1}}],[\"其示意图如下\",{\"1\":{\"513\":1}}],[\"其示意图如下图所示\",{\"1\":{\"366\":1}}],[\"其余会失败\",{\"1\":{\"449\":1}}],[\"其余为o\",{\"1\":{\"327\":1}}],[\"其关键就是必须要对对象的监视器\",{\"1\":{\"443\":1}}],[\"其核心在于理解\",{\"1\":{\"427\":1}}],[\"其休眠时间的精度取决于处理器的计时器和调度器\",{\"1\":{\"421\":1}}],[\"其含义是\",{\"1\":{\"420\":1}}],[\"其实是因为\",{\"1\":{\"505\":1}}],[\"其实是在遵循一个基本原则\",{\"1\":{\"432\":1,\"435\":1}}],[\"其实线程间的这种协作方式也符合现实生活\",{\"1\":{\"420\":1}}],[\"其实一对一我们可以看成一种特殊的一对多\",{\"1\":{\"201\":1}}],[\"其源码为\",{\"1\":{\"408\":1}}],[\"其\",{\"1\":{\"394\":1,\"490\":1}}],[\"其节点状态和相关属性可以去看\",{\"1\":{\"377\":1}}],[\"其原因正是我们刚才所说的\",{\"1\":{\"367\":1}}],[\"其主要逻辑为\",{\"1\":{\"366\":1}}],[\"其全部oldchar都替换成newchar\",{\"1\":{\"324\":1}}],[\"其创建的对象将直接放置到堆中\",{\"1\":{\"324\":1}}],[\"其长度为end或end\",{\"1\":{\"322\":1}}],[\"其工作原理主要包括以下几个步骤\",{\"1\":{\"226\":1}}],[\"其他请求该资源的线程将会阻塞\",{\"1\":{\"513\":1}}],[\"其他方法主要是实现了排队和阻塞机制\",{\"1\":{\"506\":1}}],[\"其他线程能够立即得知这个修改\",{\"1\":{\"498\":1}}],[\"其他线程只能等待\",{\"1\":{\"496\":1}}],[\"其他线程对这个值已经做了自增操作后\",{\"1\":{\"494\":1}}],[\"其他线程试图获取锁时\",{\"1\":{\"459\":1}}],[\"其他线程获取锁时会强制从主内存中获取最新的值\",{\"1\":{\"445\":1}}],[\"其他线程可以调用该线程的\",{\"1\":{\"419\":1}}],[\"其他值表示错误\",{\"1\":{\"159\":1}}],[\"其他参数与上面类似\",{\"1\":{\"111\":1}}],[\"其它参数相关变量\",{\"0\":{\"159\":1}}],[\"其它文件\",{\"1\":{\"48\":1}}],[\"其中的属性有\",{\"1\":{\"513\":1}}],[\"其中包含了两个子包\",{\"1\":{\"503\":1}}],[\"其中六条可以满足基本数据类型的访问读写具备原子性\",{\"1\":{\"494\":1}}],[\"其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象\",{\"1\":{\"442\":1}}],[\"其中会用到红黑树的插入\",{\"1\":{\"399\":1}}],[\"其中利用了锁分段的思想提高了并发度\",{\"1\":{\"391\":1}}],[\"其中每个形参都是含有一个声明符的声明\",{\"1\":{\"268\":1}}],[\"其中\",{\"1\":{\"128\":1,\"149\":1,\"349\":1,\"366\":1}}],[\"其中可以使用\",{\"1\":{\"53\":1}}],[\"其中点击每个测试点的\",{\"1\":{\"52\":1}}],[\"编译之后\",{\"1\":{\"443\":1}}],[\"编译器会在\",{\"1\":{\"487\":1}}],[\"编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序\",{\"1\":{\"469\":1}}],[\"编译器会直接替换成该变量的值\",{\"1\":{\"479\":1}}],[\"编译器会根据实参的类型选择最匹配的函数来执行\",{\"1\":{\"277\":1}}],[\"编译器\",{\"1\":{\"430\":1}}],[\"编译器和处理器会进行指令重排序\",{\"1\":{\"497\":1}}],[\"编译器和处理器希望实现一个弱内存模型\",{\"1\":{\"435\":1}}],[\"编译器和处理器希望内存模型对它们的束缚越少越好\",{\"1\":{\"435\":1}}],[\"编译器和处理器对内存模型的实现\",{\"1\":{\"435\":1}}],[\"编译器和处理器怎么优化都行\",{\"1\":{\"432\":1,\"435\":1}}],[\"编译器和处理器为了提供并行度\",{\"1\":{\"430\":1}}],[\"编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序\",{\"1\":{\"430\":1}}],[\"编译器和处理器在重排序时\",{\"1\":{\"430\":1}}],[\"编译器和处理器常常会对指令进行重排序\",{\"1\":{\"430\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"469\":1}}],[\"编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序\",{\"1\":{\"430\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"430\":1}}],[\"编译器优化的重排序\",{\"1\":{\"430\":1}}],[\"编写函数\",{\"0\":{\"265\":1}}],[\"编写sql语句对数据表中的数据进行增删改查操作\",{\"1\":{\"173\":1}}],[\"编写请参考官方\",{\"1\":{\"51\":1}}],[\"编辑\",{\"1\":{\"71\":1}}],[\"编程语言\",{\"0\":{\"4\":1,\"536\":1}}],[\"用的位置可以有这些使用场景\",{\"1\":{\"442\":1}}],[\"用cas设置成特殊节点forwardingnode\",{\"1\":{\"401\":1}}],[\"用逆向思维去看就好\",{\"1\":{\"400\":1}}],[\"用一个简单的\",{\"1\":{\"443\":1}}],[\"用一个表格将上面六种状态进行一个总结归纳\",{\"1\":{\"417\":1}}],[\"用一个很简单的例子说说这些方法怎么用\",{\"1\":{\"387\":1}}],[\"用一条\",{\"1\":{\"240\":1}}],[\"用当前同步状态直接减去写状态\",{\"1\":{\"367\":1}}],[\"用当前的调用栈层次填充throwable\",{\"1\":{\"301\":1}}],[\"用newvalue替换所有等于oldvalue的元素\",{\"1\":{\"336\":1}}],[\"用指定的字符串连接字符串数组\",{\"1\":{\"324\":1}}],[\"用非法索引访问数组时抛出的异常\",{\"1\":{\"300\":1}}],[\"用\",{\"1\":{\"237\":1,\"261\":1}}],[\"用户线程完全结束后就意味着整个系统的业务任务全部结束了\",{\"1\":{\"423\":1}}],[\"用户线程就可以认为是系统的工作线程\",{\"1\":{\"423\":1}}],[\"用户程序的入口\",{\"1\":{\"413\":1}}],[\"用户的id\",{\"1\":{\"201\":1}}],[\"用户表\",{\"1\":{\"201\":1}}],[\"用户名\",{\"1\":{\"183\":1}}],[\"用户名和密码都可以省略\",{\"1\":{\"126\":1}}],[\"用法同\",{\"1\":{\"330\":1}}],[\"用法\",{\"1\":{\"175\":1}}],[\"用解释器执行\",{\"1\":{\"146\":1}}],[\"用作堆栈而不是\",{\"1\":{\"330\":1}}],[\"用作云原生应用程序的主要存储\",{\"1\":{\"134\":1}}],[\"用作学习也够用\",{\"1\":{\"68\":1}}],[\"用于表示所修饰的内容一旦赋值之后就不会再被改变\",{\"1\":{\"474\":1}}],[\"用于表示某个程序元素\",{\"1\":{\"307\":1}}],[\"用于指向下一个节点从而构成链式队列\",{\"1\":{\"408\":1}}],[\"用于修饰包\",{\"1\":{\"306\":1}}],[\"用于处理关闭资源时可能引发的所有异常\",{\"1\":{\"304\":1}}],[\"用于声明和实例化资源\",{\"1\":{\"304\":1}}],[\"用于索引数据\",{\"1\":{\"221\":1}}],[\"用于限制存储在表中的数据\",{\"1\":{\"182\":1}}],[\"用于删除指定存储桶中的对象\",{\"1\":{\"142\":1}}],[\"用于删除一个已存在的存储桶\",{\"1\":{\"141\":1}}],[\"用于列出指定存储桶中的所有对象\",{\"1\":{\"142\":1}}],[\"用于列出用户有权访问的所有存储桶\",{\"1\":{\"141\":1}}],[\"用于从指定的存储桶中下载文件\",{\"1\":{\"142\":1}}],[\"用于生成一个对象\",{\"1\":{\"142\":1}}],[\"用于检查指定的对象\",{\"1\":{\"142\":1}}],[\"用于检查指定的存储桶是否存在\",{\"1\":{\"141\":1}}],[\"用于上传文件到指定的存储桶\",{\"1\":{\"142\":1}}],[\"用于创建一个新的存储桶\",{\"1\":{\"141\":1}}],[\"用于将命令放到后台执行\",{\"1\":{\"126\":1}}],[\"用于运行另一个命令在后台\",{\"1\":{\"126\":1}}],[\"用到的包drissionpage\",{\"1\":{\"83\":1,\"90\":1}}],[\"用来记录导致线程阻塞的阻塞对象\",{\"1\":{\"386\":3}}],[\"用来阻塞线程和唤醒线程\",{\"1\":{\"385\":1}}],[\"用来对数据库中表的数据记录进行增\",{\"1\":{\"187\":1}}],[\"用来对数据库表中的数据进行增删改\",{\"1\":{\"172\":1}}],[\"用来创建数据库用户\",{\"1\":{\"172\":1}}],[\"用来查询数据库中表的记录\",{\"1\":{\"172\":1}}],[\"用来定义数据库对象\",{\"1\":{\"172\":1,\"174\":1}}],[\"用来处理\",{\"1\":{\"134\":1}}],[\"用来提\",{\"1\":{\"56\":1}}],[\"用来测试\",{\"1\":{\"51\":1}}],[\"用来检测数据合法性\",{\"1\":{\"51\":1}}],[\"用管理员模式在项目根目录\",{\"1\":{\"23\":1}}],[\"用管理员模式打开\",{\"1\":{\"22\":1,\"35\":1}}],[\"仅为该类的成员变量提供\",{\"1\":{\"484\":1}}],[\"仅仅实现栈的操作\",{\"1\":{\"330\":1}}],[\"仅用于单节点数据库\",{\"1\":{\"200\":1}}],[\"仅\",{\"1\":{\"50\":1}}],[\"添加一个版本号可以解决\",{\"1\":{\"451\":1}}],[\"添加到栈层次任何先前信息中\",{\"1\":{\"301\":1}}],[\"添加到暂存区\",{\"1\":{\"26\":1}}],[\"添加关键字和其对应的值\",{\"1\":{\"295\":1}}],[\"添加元素e到队尾\",{\"1\":{\"331\":1}}],[\"添加元素\",{\"1\":{\"294\":1}}],[\"添加唯一约束时\",{\"1\":{\"222\":1}}],[\"添加外键\",{\"1\":{\"200\":1}}],[\"添加数据\",{\"1\":{\"187\":1}}],[\"添加字段\",{\"1\":{\"185\":1,\"200\":1}}],[\"添加\",{\"1\":{\"139\":1}}],[\"添加若干组输出以及对应的期望评测结果\",{\"1\":{\"49\":1}}],[\"教程\",{\"1\":{\"49\":1,\"50\":1,\"51\":1}}],[\"教程章节\",{\"0\":{\"16\":1,\"39\":1,\"62\":1}}],[\"下图就以这种执行时序出现的一种情况来讨论\",{\"1\":{\"488\":1}}],[\"下图就展示了线程\",{\"1\":{\"468\":1}}],[\"下图是线程\",{\"1\":{\"468\":1}}],[\"下图是两个线程同时争夺锁\",{\"1\":{\"459\":1}}],[\"下图线程\",{\"1\":{\"455\":1}}],[\"下图表现了对象\",{\"1\":{\"443\":1}}],[\"下\",{\"1\":{\"417\":1}}],[\"下的阻塞队列以及\",{\"1\":{\"503\":1}}],[\"下的等待通知机制\",{\"1\":{\"380\":1}}],[\"下的值\",{\"1\":{\"182\":1}}],[\"下使用cas算法来更新数据\",{\"1\":{\"348\":1}}],[\"下标为0的元素代表栈顶\",{\"1\":{\"301\":1}}],[\"下标从0开始\",{\"1\":{\"160\":1}}],[\"下边距设置为\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"下一页的标签在\",{\"1\":{\"85\":1,\"92\":1}}],[\"下一步\",{\"1\":{\"67\":3,\"70\":3}}],[\"下面使用一个例子来进一步理解下\",{\"1\":{\"508\":1}}],[\"下面结合实例来看\",{\"1\":{\"488\":1}}],[\"下面用具体的代码演示\",{\"1\":{\"478\":1}}],[\"下面用具体的代码来演示\",{\"1\":{\"477\":1}}],[\"下面用一个具体的例子来说说\",{\"1\":{\"420\":1}}],[\"下面以一个具体的例子来讲下如何使用这些规则进行推论\",{\"1\":{\"433\":1}}],[\"下面以一个简单的例子来表述\",{\"1\":{\"423\":1}}],[\"下面以两个方面来说\",{\"1\":{\"431\":1}}],[\"下面会作为一个具体的方法进行讲解\",{\"1\":{\"399\":1}}],[\"下面我们结合具体的代码\",{\"1\":{\"467\":1}}],[\"下面我们来看看\",{\"1\":{\"379\":1}}],[\"下面我们带着这三个问题\",{\"1\":{\"364\":1}}],[\"下面将讲解\",{\"1\":{\"70\":1}}],[\"下面的代码主要是新增的一些功能\",{\"1\":{\"369\":1}}],[\"下面的\",{\"1\":{\"49\":1,\"51\":1}}],[\"下载\",{\"1\":{\"128\":1,\"129\":1}}],[\"下载安装包\",{\"1\":{\"126\":1}}],[\"下载的内容为\",{\"1\":{\"70\":1}}],[\"下载完成后执行以下命令即可在本地打开博客\",{\"1\":{\"23\":1}}],[\"下来\",{\"1\":{\"49\":1}}],[\"自旋不断尝试cas尾插入节点直至成功为止\",{\"1\":{\"516\":1}}],[\"自旋时间过长\",{\"1\":{\"451\":1}}],[\"自旋等待获取到同步状态\",{\"1\":{\"378\":1}}],[\"自然而然会在\",{\"1\":{\"520\":1}}],[\"自然而然是在\",{\"1\":{\"516\":1}}],[\"自然而然就只能去主内存去取了\",{\"1\":{\"468\":1}}],[\"自然而然可以将新值\",{\"1\":{\"449\":1}}],[\"自然而然得先从它的节点类看起\",{\"1\":{\"408\":1}}],[\"自然而然\",{\"1\":{\"377\":1}}],[\"自然排序\",{\"1\":{\"329\":1}}],[\"自减\",{\"1\":{\"235\":1}}],[\"自减运算符\",{\"1\":{\"234\":1}}],[\"自增运算符\",{\"1\":{\"234\":1}}],[\"自己的文件系统\",{\"1\":{\"134\":1}}],[\"自己可根据自己的需要进行选择\",{\"1\":{\"68\":1}}],[\"自动提交事务\",{\"1\":{\"217\":1}}],[\"自动增长\",{\"1\":{\"182\":1}}],[\"自动获取文件大小\",{\"1\":{\"142\":1}}],[\"自动\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"自动播放\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"自动加在题面里\",{\"1\":{\"52\":1}}],[\"自贡\",{\"1\":{\"76\":1,\"77\":1}}],[\"自行选择\",{\"1\":{\"69\":1}}],[\"自行去\",{\"1\":{\"49\":1}}],[\"自定义实现最小\",{\"1\":{\"333\":1}}],[\"自定义排序算法\",{\"1\":{\"333\":1}}],[\"自定义排序时\",{\"1\":{\"329\":1}}],[\"自定义异常\",{\"1\":{\"303\":1}}],[\"自定义变量改成环境变量\",{\"1\":{\"155\":1}}],[\"自定义变量\",{\"1\":{\"155\":1}}],[\"自定义安装\",{\"1\":{\"67\":2}}],[\"自定义安装路径\",{\"1\":{\"32\":1}}],[\"自定义一下安装路径\",{\"1\":{\"32\":1}}],[\"均需要包含头文件\",{\"1\":{\"49\":1}}],[\"提出\",{\"1\":{\"432\":1}}],[\"提升应用性能\",{\"1\":{\"346\":1}}],[\"提高数据查询的效率\",{\"1\":{\"220\":1}}],[\"提交给\",{\"1\":{\"413\":2}}],[\"提交事务\",{\"1\":{\"217\":2}}],[\"提交信息\",{\"1\":{\"26\":1}}],[\"提取从0开始的5个字符\",{\"1\":{\"156\":1}}],[\"提取子串\",{\"1\":{\"156\":1}}],[\"提取相关数据内容\",{\"1\":{\"96\":1}}],[\"提取标签\",{\"1\":{\"96\":1}}],[\"提取具体的数据内容\",{\"1\":{\"96\":1}}],[\"提示\",{\"1\":{\"84\":1,\"85\":1,\"92\":1,\"128\":1}}],[\"提供出来的模板方法\",{\"1\":{\"512\":1}}],[\"提供带参的构造器用于初始化类的成员变量\",{\"1\":{\"484\":1}}],[\"提供的模板方法实现同步组件语义\",{\"1\":{\"512\":1}}],[\"提供的模板方法实现自己的同步语义\",{\"1\":{\"507\":1}}],[\"提供的模板方法\",{\"1\":{\"508\":1}}],[\"提供的模板方法可以分为\",{\"1\":{\"507\":1}}],[\"提供的模板方法如下图\",{\"1\":{\"507\":1}}],[\"提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法\",{\"1\":{\"436\":1}}],[\"提供的\",{\"1\":{\"380\":1,\"507\":1}}],[\"提供的方法\",{\"1\":{\"377\":1}}],[\"提供的关键字\",{\"1\":{\"364\":1}}],[\"提供的教程\",{\"1\":{\"52\":1}}],[\"提供了线程安全的保障\",{\"1\":{\"391\":1}}],[\"提供了一个关键字\",{\"1\":{\"182\":1}}],[\"提供了一些内置的\",{\"1\":{\"49\":1}}],[\"提供了以下5种约束\",{\"1\":{\"182\":1}}],[\"官网链接\",{\"1\":{\"132\":1}}],[\"官网下载\",{\"1\":{\"125\":1}}],[\"官网描述为\",{\"1\":{\"44\":1}}],[\"官方称为\",{\"1\":{\"458\":1}}],[\"官方团队表示\",{\"1\":{\"139\":1}}],[\"官方仓库\",{\"1\":{\"125\":1}}],[\"官方文档可参考pyecharts\",{\"1\":{\"99\":1}}],[\"官方下载\",{\"1\":{\"68\":1}}],[\"官方教程\",{\"1\":{\"48\":1}}],[\"式交互题需要\",{\"1\":{\"50\":1}}],[\"式交互题还有\",{\"1\":{\"48\":1}}],[\"式交互参见\",{\"1\":{\"48\":1}}],[\"需要在\",{\"1\":{\"504\":1}}],[\"需要等待全局安全点\",{\"1\":{\"455\":1}}],[\"需要经过需求分析师进行需求分解后\",{\"1\":{\"420\":1}}],[\"需要对\",{\"1\":{\"401\":1}}],[\"需要依次向后遍历确定这个新加入的值所在位置\",{\"1\":{\"399\":1}}],[\"需要频繁的上下文切换\",{\"1\":{\"360\":1}}],[\"需要注意的是在不同\",{\"1\":{\"422\":1}}],[\"需要注意的是如果当前线程获得了锁\",{\"1\":{\"421\":1}}],[\"需要注意的是\",{\"1\":{\"359\":1,\"369\":1,\"377\":1,\"397\":1,\"422\":1,\"469\":1,\"504\":1}}],[\"需要保存当前的状态起来\",{\"1\":{\"348\":1}}],[\"需要拆分\",{\"1\":{\"346\":1}}],[\"需要先进行了解\",{\"1\":{\"392\":1}}],[\"需要先定义好排序规则\",{\"1\":{\"333\":1}}],[\"需要先在下面的\",{\"1\":{\"47\":1}}],[\"需要用到\",{\"1\":{\"329\":1}}],[\"需要用到的库有\",{\"1\":{\"99\":1}}],[\"需要手动刷新缓冲区\",{\"1\":{\"237\":1}}],[\"需要手动验证\",{\"1\":{\"95\":1}}],[\"需要适时调整\",{\"1\":{\"228\":1}}],[\"需要将多次访问数据库的操作视为一个整体来执行\",{\"1\":{\"216\":1}}],[\"需要将其注册为\",{\"1\":{\"129\":1}}],[\"需要消除无效的笛卡尔积\",{\"1\":{\"205\":1}}],[\"需要检查外键关系\",{\"1\":{\"200\":1}}],[\"需要指定长度\",{\"1\":{\"183\":2}}],[\"需要指定存储桶名称和对象键\",{\"1\":{\"142\":1}}],[\"需要指定存储桶的名称\",{\"1\":{\"141\":1}}],[\"需要加上\",{\"1\":{\"152\":1}}],[\"需要提供输入和期望是否合法\",{\"1\":{\"51\":1}}],[\"需要放在\",{\"1\":{\"48\":1}}],[\"外连接分为两种\",{\"1\":{\"208\":1}}],[\"外连接\",{\"0\":{\"208\":1},\"1\":{\"206\":1}}],[\"外键字段名\",{\"1\":{\"200\":2}}],[\"外键名称\",{\"1\":{\"200\":2}}],[\"外键约束\",{\"0\":{\"200\":1},\"1\":{\"182\":1,\"200\":1}}],[\"外\",{\"1\":{\"48\":1}}],[\"样例在\",{\"1\":{\"47\":1}}],[\"题面编辑完后需要\",{\"1\":{\"47\":1}}],[\"题面编辑内容不包括样例\",{\"1\":{\"47\":1}}],[\"题面和题解都需要使用\",{\"1\":{\"47\":1}}],[\"题目类型\",{\"1\":{\"46\":1}}],[\"题目创建\",{\"0\":{\"38\":1}}],[\"一书\",{\"1\":{\"507\":1}}],[\"一书中\",{\"1\":{\"417\":1}}],[\"一书中有过一个实验\",{\"1\":{\"348\":1}}],[\"一样的锁功能\",{\"1\":{\"504\":1}}],[\"一样让其他线程都停下来让你去统计\",{\"1\":{\"402\":1}}],[\"一定会先读这个包含这个\",{\"1\":{\"487\":1}}],[\"一会是编译器重排序一会是处理器重排序\",{\"1\":{\"431\":1}}],[\"一共给我们提供了\",{\"1\":{\"397\":1}}],[\"一共提供了如下几个构造器方法\",{\"1\":{\"397\":1}}],[\"一旦赋值后就不能再次更改\",{\"1\":{\"479\":1}}],[\"一旦赋值之后再次赋值就会出错\",{\"1\":{\"478\":1}}],[\"一旦锁升级成重量级锁\",{\"1\":{\"459\":1}}],[\"一旦执行\",{\"1\":{\"422\":1}}],[\"一旦\",{\"1\":{\"419\":1}}],[\"一旦一个线程开始运行\",{\"1\":{\"414\":1}}],[\"一旦调用\",{\"1\":{\"414\":1}}],[\"一旦出现拉链过长\",{\"1\":{\"399\":1}}],[\"一旦临界区资源被一个线程占有\",{\"1\":{\"354\":1}}],[\"一旦产生死锁就会造成系统功能不可用\",{\"1\":{\"349\":1}}],[\"一旦为表起了别名\",{\"1\":{\"207\":1}}],[\"一张\",{\"1\":{\"346\":1}}],[\"一直以来\",{\"1\":{\"346\":1}}],[\"一种方式是\",{\"1\":{\"428\":1}}],[\"一种特殊的返回类型是\",{\"1\":{\"269\":1}}],[\"一种是出现了\",{\"1\":{\"55\":1}}],[\"一是用实参初始化函数对应的形参\",{\"1\":{\"266\":1}}],[\"一维数组\",{\"0\":{\"251\":1}}],[\"一\",{\"0\":{\"232\":1}}],[\"一致性\",{\"1\":{\"218\":2}}],[\"一行一列\",{\"1\":{\"210\":1}}],[\"一门课程也可以供多个学生选择\",{\"1\":{\"202\":1}}],[\"一门操作关系型数据库的编程语言\",{\"1\":{\"170\":1}}],[\"一个锁能够防止多个线程同时访问共享资源\",{\"1\":{\"504\":1}}],[\"一个操作一旦开始\",{\"1\":{\"494\":1}}],[\"一个处理器的缓存回写到内存会导致其他处理器的缓存失效\",{\"1\":{\"466\":1}}],[\"一个对象的初始化完成\",{\"1\":{\"433\":1}}],[\"一个对象会被分成\",{\"1\":{\"134\":1}}],[\"一个很经典的例子就是\",{\"1\":{\"430\":1}}],[\"一个好的内存模型实际上会放松对处理器和编译器规则的束缚\",{\"1\":{\"430\":1}}],[\"一个基友先走在前面突然看见另一个基友落在后面了\",{\"1\":{\"420\":1}}],[\"一个线程中的每个操作\",{\"1\":{\"433\":1}}],[\"一个线程会继承构造它的那个线程的优先级\",{\"1\":{\"422\":1}}],[\"一个线程的输入可能非常依赖于另一个线程的输出\",{\"1\":{\"420\":1}}],[\"一个线程只有在调用\",{\"1\":{\"414\":1}}],[\"一个线程被另一个线程中断\",{\"1\":{\"300\":1}}],[\"一个可运行的线程可能正在运行\",{\"1\":{\"414\":1}}],[\"一个是数据域\",{\"1\":{\"408\":1}}],[\"一个是原链表\",{\"1\":{\"401\":1}}],[\"一个例子\",{\"0\":{\"381\":1,\"387\":1,\"461\":1,\"470\":1,\"508\":1}}],[\"一个整数\",{\"1\":{\"300\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"285\":1}}],[\"一个源文件可以有多个非\",{\"1\":{\"281\":1}}],[\"一个源文件中只能有一个\",{\"1\":{\"281\":1}}],[\"一个典型的函数定义包括以下部分\",{\"1\":{\"264\":1}}],[\"一个不好的哈希函数可能导致性能下降\",{\"1\":{\"228\":1}}],[\"一个指针占\",{\"1\":{\"221\":1}}],[\"一个\",{\"1\":{\"221\":1,\"413\":1,\"436\":1}}],[\"一个节点可以保存多个数据\",{\"1\":{\"221\":1}}],[\"一个节点下面只能有两个子节点\",{\"1\":{\"221\":1}}],[\"一个事务一旦被提交或回滚\",{\"1\":{\"218\":1}}],[\"一个事务的成功或者失败对于其他的事务是没有影响\",{\"1\":{\"218\":1}}],[\"一个事务完成之后数据都必须处于一致性状态\",{\"1\":{\"218\":1}}],[\"一个用户的事务不能被其他用户的事务干扰\",{\"1\":{\"218\":1}}],[\"一个用户只能对应一个身份证\",{\"1\":{\"201\":1}}],[\"一个业务要发送多条\",{\"1\":{\"216\":1}}],[\"一个课程也可以供多个学生选修\",{\"1\":{\"202\":1}}],[\"一个学生可以选修多门课程\",{\"1\":{\"202\":2}}],[\"一个学生可以有多个授课老师\",{\"1\":{\"202\":1}}],[\"一个授课老师也可以有多个学生\",{\"1\":{\"202\":1}}],[\"一对一的应用场景\",{\"1\":{\"201\":1}}],[\"一对一关系表在实际开发中应用起来比较简单\",{\"1\":{\"201\":1}}],[\"一对一\",{\"0\":{\"201\":1},\"1\":{\"199\":1,\"201\":1}}],[\"一对多我们是怎么设计表关系的\",{\"1\":{\"201\":1}}],[\"一对多关系实现\",{\"1\":{\"200\":1}}],[\"一对多\",{\"0\":{\"200\":1},\"1\":{\"199\":1}}],[\"一列\",{\"1\":{\"118\":1}}],[\"一栏\",{\"1\":{\"82\":1}}],[\"一下包含破解教程\",{\"1\":{\"69\":1}}],[\"一般来说\",{\"1\":{\"504\":1}}],[\"一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等\",{\"1\":{\"427\":1}}],[\"一般处理器不会重排序这两个操作\",{\"1\":{\"487\":1}}],[\"一般重排序可以分为如下三种\",{\"1\":{\"430\":1}}],[\"一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源\",{\"1\":{\"419\":1}}],[\"一般有四种方式\",{\"1\":{\"413\":1}}],[\"一般情况下不自定义检查型异常\",{\"1\":{\"299\":1}}],[\"一般会选择线程终止\",{\"1\":{\"297\":1}}],[\"一般与\",{\"1\":{\"247\":1}}],[\"一般负责修改循环变量\",{\"1\":{\"245\":1}}],[\"一般用来初始化循环变量\",{\"1\":{\"245\":1}}],[\"一般用于审核\",{\"1\":{\"47\":1}}],[\"一般需要同时修改公共字段\",{\"1\":{\"189\":1}}],[\"一般是数据没有过\",{\"1\":{\"55\":1}}],[\"一路下一步即可\",{\"0\":{\"32\":1}}],[\"与独占式的区别在于同一时刻有多个线程获取同步状态\",{\"1\":{\"512\":1}}],[\"与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量\",{\"1\":{\"488\":1}}],[\"与按\",{\"1\":{\"432\":1}}],[\"与之对应的就是用户线程\",{\"1\":{\"423\":1}}],[\"与期望的旧值\",{\"1\":{\"393\":2}}],[\"与第一种的区别在于能够唤醒所有等待在\",{\"1\":{\"375\":1}}],[\"与此同时\",{\"1\":{\"358\":1}}],[\"与\",{\"0\":{\"297\":1,\"318\":1,\"380\":1,\"402\":1,\"436\":1,\"502\":1},\"1\":{\"47\":1,\"183\":1,\"196\":1,\"240\":1,\"285\":1,\"364\":3,\"366\":1,\"375\":2,\"379\":1,\"402\":2,\"432\":1,\"434\":1,\"487\":1,\"512\":1,\"519\":1}}],[\"📌wordcloud\",{\"0\":{\"119\":1}}],[\"📌pie\",{\"0\":{\"112\":1}}],[\"📌成果展示\",{\"0\":{\"108\":1,\"116\":1,\"122\":1}}],[\"📌timeline\",{\"0\":{\"106\":1,\"114\":1,\"120\":1}}],[\"📌grid\",{\"0\":{\"105\":1,\"113\":1}}],[\"📌bar\",{\"0\":{\"104\":1}}],[\"📌line\",{\"0\":{\"103\":1}}],[\"📌map\",{\"0\":{\"102\":1,\"111\":1}}],[\"📌数据获取\",{\"0\":{\"101\":1,\"110\":1,\"118\":1}}],[\"📌数据抓取\",{\"0\":{\"85\":1,\"92\":1}}],[\"📌url获取模块\",{\"0\":{\"91\":1}}],[\"📌完整代码\",{\"0\":{\"77\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"📌️url获取模块\",{\"0\":{\"84\":1}}],[\"📌️packages\",{\"0\":{\"57\":1}}],[\"📌️issues\",{\"0\":{\"56\":1}}],[\"📌️invocations\",{\"0\":{\"55\":1}}],[\"📌️interactor\",{\"0\":{\"50\":1}}],[\"📌️solution\",{\"0\":{\"54\":1}}],[\"📌️stresses\",{\"0\":{\"53\":1}}],[\"📌️statement\",{\"0\":{\"47\":1}}],[\"📌️tests\",{\"0\":{\"52\":1}}],[\"📌️validator\",{\"0\":{\"51\":1}}],[\"📌️checker\",{\"0\":{\"49\":1}}],[\"📌️files\",{\"0\":{\"48\":1}}],[\"📌️general\",{\"0\":{\"46\":1}}],[\"📍题目创建\",{\"0\":{\"45\":1}}],[\"📍简介\",{\"0\":{\"44\":1}}],[\"开放给我们使用\",{\"1\":{\"494\":1}}],[\"开放寻址法\",{\"1\":{\"226\":1}}],[\"开发才会继续跟进\",{\"1\":{\"420\":1}}],[\"开发人员倍感幸福\",{\"1\":{\"391\":1}}],[\"开头的三个问题我们通过阅读源码的方式已经完全找到了答案\",{\"1\":{\"378\":1}}],[\"开立方\",{\"1\":{\"335\":1}}],[\"开平方\",{\"1\":{\"335\":1}}],[\"开启\",{\"1\":{\"441\":1,\"461\":1,\"494\":1}}],[\"开启了两个线程分别为\",{\"1\":{\"419\":1}}],[\"开启了两个线程\",{\"1\":{\"349\":1,\"381\":1}}],[\"开启一个线程\",{\"1\":{\"315\":1}}],[\"开启事务\",{\"1\":{\"217\":2}}],[\"开启手动控制事务\",{\"1\":{\"217\":1}}],[\"开封\",{\"1\":{\"76\":1,\"77\":1}}],[\"开源的\",{\"1\":{\"133\":1}}],[\"开源协议\",{\"1\":{\"132\":1}}],[\"开源\",{\"1\":{\"68\":1}}],[\"开源项目\",{\"0\":{\"14\":1}}],[\"开始指定大小capacity\",{\"1\":{\"333\":1}}],[\"开始时间\",{\"1\":{\"201\":1}}],[\"开始\",{\"1\":{\"198\":1}}],[\"开始自增\",{\"1\":{\"182\":1}}],[\"开始编辑题目\",{\"1\":{\"45\":1}}],[\"开始创建一个题目表格\",{\"1\":{\"45\":1}}],[\"能保证其原子性\",{\"1\":{\"451\":1}}],[\"能支持处理器提供的\",{\"1\":{\"451\":1}}],[\"能否直接将新值插入到\",{\"1\":{\"399\":1}}],[\"能从\",{\"1\":{\"386\":1}}],[\"能够正确赋值\",{\"1\":{\"487\":1}}],[\"能够正确显示版本号说明安装成功\",{\"1\":{\"34\":1}}],[\"能够拥有一次时间片的机会\",{\"1\":{\"423\":1}}],[\"能够从\",{\"1\":{\"380\":1}}],[\"能够有机会获取\",{\"1\":{\"380\":1}}],[\"能够有机会移入到同步队列中\",{\"1\":{\"380\":1}}],[\"能够访问到\",{\"1\":{\"377\":1}}],[\"能够支持超时时间的设置\",{\"1\":{\"375\":1}}],[\"能够支持多个等待队列\",{\"1\":{\"375\":1}}],[\"能够支持不响应中断\",{\"1\":{\"375\":1}}],[\"能被100整除时\",{\"1\":{\"239\":1}}],[\"能看懂英文就基本能用了\",{\"1\":{\"45\":1}}],[\"而该方法其底层会调用\",{\"1\":{\"519\":1}}],[\"而关于底层实现\",{\"1\":{\"508\":1}}],[\"而对\",{\"1\":{\"508\":2}}],[\"而对于引用类型变量而言\",{\"1\":{\"479\":1}}],[\"而此时当继承\",{\"1\":{\"507\":1}}],[\"而此时线程\",{\"1\":{\"429\":1}}],[\"而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法\",{\"1\":{\"507\":1}}],[\"而同样的\",{\"1\":{\"417\":1}}],[\"而用\",{\"1\":{\"497\":1}}],[\"而语句\",{\"1\":{\"494\":1}}],[\"而当线程\",{\"1\":{\"490\":1}}],[\"而写线程\",{\"1\":{\"488\":1}}],[\"而普通域就不具有这个保障\",{\"1\":{\"487\":1}}],[\"而实际上这个\",{\"1\":{\"497\":1}}],[\"而实例变量则可以有三个时机赋初值\",{\"1\":{\"477\":1}}],[\"而实例变量可以在声明变量的时候给实例变量赋初值\",{\"1\":{\"477\":1}}],[\"而实现写锁的同步语义是通过重写\",{\"1\":{\"366\":1}}],[\"而蓝色的就是根据传递性规则推导出来的\",{\"1\":{\"467\":1}}],[\"而针对用户来说\",{\"1\":{\"508\":1}}],[\"而针对\",{\"1\":{\"465\":1}}],[\"而上层会有基于\",{\"1\":{\"435\":1}}],[\"而且只能在这三个地方进行指定\",{\"1\":{\"477\":1}}],[\"而且只能在这两个地方之一进行指定\",{\"1\":{\"477\":1}}],[\"而且总是由同一线程多次获得\",{\"1\":{\"453\":1}}],[\"而且每次运行结果都不一样\",{\"1\":{\"441\":1}}],[\"而且也向程序员提供了足够强的内存可见性保证\",{\"1\":{\"435\":1}}],[\"而且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"432\":1}}],[\"而且可以有多个线程并行运行\",{\"1\":{\"414\":1}}],[\"而局部变量\",{\"1\":{\"428\":1}}],[\"而解决线程安全的问题最重要的就是理解这两种问题是怎么来的\",{\"1\":{\"427\":1}}],[\"而它们不同的是\",{\"1\":{\"422\":1}}],[\"而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性\",{\"1\":{\"422\":1}}],[\"而使用在代码块中也可以分为三种\",{\"1\":{\"442\":1}}],[\"而使用\",{\"1\":{\"417\":1,\"461\":1}}],[\"而使用多线程时\",{\"1\":{\"352\":1}}],[\"而没有启动新的线程\",{\"1\":{\"413\":1}}],[\"而保障\",{\"1\":{\"407\":1}}],[\"而采用\",{\"1\":{\"403\":1}}],[\"而之前我们提过\",{\"1\":{\"399\":1}}],[\"而红黑树的操作是针对\",{\"1\":{\"394\":1}}],[\"而到了\",{\"1\":{\"391\":1}}],[\"而调用\",{\"1\":{\"386\":1}}],[\"而另一个线程\",{\"1\":{\"380\":1}}],[\"而移入到同步队列后才有机会使得等待线程被唤醒\",{\"1\":{\"379\":1}}],[\"而这些实际上则是\",{\"1\":{\"512\":1}}],[\"而这些类的实现主要是依赖于\",{\"1\":{\"503\":1}}],[\"而这三个操作无法构成原子操作\",{\"1\":{\"494\":1}}],[\"而这种机制能够解决最经典的问题就是\",{\"1\":{\"380\":1}}],[\"而这段代码的逻辑就是告诉我们这三个问题的答案\",{\"1\":{\"378\":1}}],[\"而这个方法锁的对象依然就这个类对象\",{\"1\":{\"443\":1}}],[\"而这个方法实际上是会\",{\"1\":{\"377\":1}}],[\"而这个获取的过程是互斥的\",{\"1\":{\"443\":1}}],[\"而这个锁目前被其他线程占有\",{\"1\":{\"415\":1}}],[\"而这个值其实也是一个大概的数值\",{\"1\":{\"402\":1}}],[\"而这个切换时非常损耗性能\",{\"1\":{\"348\":1}}],[\"而通过使用\",{\"1\":{\"375\":1}}],[\"而如果在这种业务场景下\",{\"1\":{\"364\":1}}],[\"而在此之前\",{\"1\":{\"512\":1}}],[\"而在\",{\"1\":{\"403\":1}}],[\"而在大量的同步组件和并发容器的实现中使用\",{\"1\":{\"393\":1}}],[\"而在之前利用\",{\"1\":{\"377\":1}}],[\"而在之前说\",{\"1\":{\"377\":1}}],[\"而在一些业务场景中\",{\"1\":{\"364\":1}}],[\"而在学习多线程编程技术的过程中也会让你收获颇丰\",{\"1\":{\"349\":1}}],[\"而非进行耗时的挂起唤醒的操作\",{\"1\":{\"449\":1}}],[\"而非共享数据不会出现线程安全的问题\",{\"1\":{\"428\":1}}],[\"而非公平锁会降低一定的上下文切换\",{\"1\":{\"360\":1}}],[\"而非公平锁有可能刚释放锁的线程下次继续获取该锁\",{\"1\":{\"360\":1}}],[\"而非公平性锁则不一定\",{\"1\":{\"360\":1}}],[\"而非阻塞就恰好相反\",{\"1\":{\"353\":1}}],[\"而非一种软件\",{\"1\":{\"9\":1}}],[\"而成为并发执行任务\",{\"1\":{\"352\":1}}],[\"而并没有加锁\",{\"1\":{\"401\":1}}],[\"而并发包中的\",{\"1\":{\"377\":1}}],[\"而并发编程更能吻合这种业务拆分\",{\"1\":{\"346\":1}}],[\"而并行则是指真正意义上的\",{\"1\":{\"352\":1}}],[\"而异步调用了\",{\"1\":{\"351\":1}}],[\"而异步调用\",{\"1\":{\"351\":1}}],[\"而每次切换时\",{\"1\":{\"348\":1}}],[\"而每个节点一共能存储\",{\"1\":{\"221\":1}}],[\"而专业服务器则通常可以达到几个独立的\",{\"1\":{\"346\":1}}],[\"而是先将系统内存的数据读到内部缓存\",{\"1\":{\"466\":1}}],[\"而是统计一次这个值\",{\"1\":{\"402\":1}}],[\"而是希望利用并发处理去减少扩容带来的时间影响\",{\"1\":{\"401\":1}}],[\"而是包装的很多\",{\"1\":{\"394\":1}}],[\"而是\",{\"1\":{\"391\":1}}],[\"而是将多个计算单元整合到了一起\",{\"1\":{\"346\":1}}],[\"而是exit\",{\"1\":{\"159\":1}}],[\"而不用再去理解底层重排序的规则\",{\"1\":{\"431\":1}}],[\"而不是\",{\"1\":{\"394\":1,\"399\":1,\"403\":1}}],[\"而不是再追求单独的计算单元\",{\"1\":{\"346\":1}}],[\"而不会被消息刷屏却一直没有\",{\"1\":{\"44\":1}}],[\"而指定的类对象因为是一个接口或是一个抽象类而无法实例化时\",{\"1\":{\"300\":1}}],[\"而一个节点总共容量是\",{\"1\":{\"221\":1}}],[\"而一个身份证也只能关联一个用户\",{\"1\":{\"201\":1}}],[\"而我们在日常开发使用时\",{\"1\":{\"208\":1}}],[\"而第二张表存放的就是用户的身份信息\",{\"1\":{\"201\":1}}],[\"而\",{\"1\":{\"183\":1,\"196\":2,\"221\":1,\"323\":1,\"366\":1,\"375\":3,\"377\":1,\"379\":1,\"393\":1,\"419\":1,\"421\":4,\"422\":1,\"430\":1,\"448\":1,\"449\":1,\"461\":1,\"465\":1,\"469\":1,\"487\":2,\"504\":2,\"505\":1,\"507\":2,\"508\":4,\"515\":1}}],[\"发送了一个消息告诉线程\",{\"1\":{\"468\":1}}],[\"发生错误\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"发现一个最优布置来最小化插入屏障的总数几乎是不可能的\",{\"1\":{\"469\":1}}],[\"发现找不到对应的json文件\",{\"1\":{\"89\":1}}],[\"发现参数qurey=java和city=100010000\",{\"1\":{\"81\":1}}],[\"发现问题可以提\",{\"1\":{\"44\":1}}],[\"发布站点\",{\"0\":{\"27\":1}}],[\"拍出来的数据可以直接添加到题目数据中\",{\"1\":{\"44\":1}}],[\"输出结果\",{\"1\":{\"419\":1}}],[\"输出结果为\",{\"1\":{\"381\":1,\"420\":1,\"423\":1}}],[\"输出二维数组\",{\"1\":{\"255\":1}}],[\"输出三个数中的最大值\",{\"1\":{\"240\":1}}],[\"输出三个数中最大的那个\",{\"1\":{\"239\":1}}],[\"输出c\",{\"1\":{\"239\":1}}],[\"输出b\",{\"1\":{\"239\":1}}],[\"输出a\",{\"1\":{\"239\":1}}],[\"输出两个数中较大的那个\",{\"1\":{\"239\":1}}],[\"输出这个数的绝对值\",{\"1\":{\"239\":1}}],[\"输出规模较大时使用\",{\"1\":{\"237\":1}}],[\"输出规模较小时使用\",{\"1\":{\"237\":1}}],[\"输出字符串\",{\"1\":{\"237\":2}}],[\"输出整数\",{\"1\":{\"237\":2}}],[\"输出3\",{\"1\":{\"156\":1}}],[\"输出\",{\"0\":{\"237\":1},\"1\":{\"156\":2,\"239\":1}}],[\"输出空行\",{\"1\":{\"154\":1}}],[\"输出yxcacwing\",{\"1\":{\"152\":1}}],[\"输出yxc\",{\"1\":{\"152\":2}}],[\"输出自动生成\",{\"1\":{\"44\":1}}],[\"输入一整行字符串\",{\"1\":{\"261\":1}}],[\"输入一个\",{\"1\":{\"254\":1}}],[\"输入一个年份\",{\"1\":{\"239\":1}}],[\"输入一个0到100之间的分数\",{\"1\":{\"239\":1}}],[\"输入一个整数\",{\"1\":{\"239\":1}}],[\"输入字符串\",{\"1\":{\"261\":1}}],[\"输入与输出\",{\"0\":{\"261\":1}}],[\"输入三个数\",{\"1\":{\"240\":1}}],[\"输入三个整数\",{\"1\":{\"239\":1}}],[\"输入两个整数\",{\"1\":{\"239\":1}}],[\"输入规模较大时使用\",{\"1\":{\"236\":1}}],[\"输入规模较小时使用\",{\"1\":{\"236\":1}}],[\"输入\",{\"0\":{\"236\":1},\"1\":{\"254\":1}}],[\"输入python验证\",{\"1\":{\"67\":1}}],[\"输入以下指令\",{\"1\":{\"34\":1}}],[\"环环相扣\",{\"1\":{\"44\":1}}],[\"环境或\",{\"1\":{\"300\":1}}],[\"环境就已经完全配好了\",{\"1\":{\"34\":1}}],[\"环境变量改为自定义变量\",{\"1\":{\"155\":1}}],[\"环境变量\",{\"1\":{\"34\":1,\"155\":1}}],[\"环境配置\",{\"0\":{\"34\":1,\"64\":1},\"1\":{\"62\":1},\"2\":{\"36\":1}}],[\"尤其是多人合作出题时\",{\"1\":{\"44\":1}}],[\"在下一次循环中进行重试\",{\"1\":{\"523\":1}}],[\"在共享式锁的释放过程中\",{\"1\":{\"523\":1}}],[\"在该方法中会首先调用\",{\"1\":{\"522\":1}}],[\"在该方法中如果当前同步状态为\",{\"1\":{\"508\":1}}],[\"在获取同步状态失败后就会调用\",{\"1\":{\"519\":1}}],[\"在获取同步状态时\",{\"1\":{\"518\":1}}],[\"在释放同步状态时\",{\"1\":{\"518\":1}}],[\"在释放的过程中会唤醒同步队列中的下一个节点\",{\"1\":{\"378\":1}}],[\"在自旋过程中主要完成了两件事情\",{\"1\":{\"517\":1}}],[\"在当前线程是第一个加入同步队列时\",{\"1\":{\"516\":1}}],[\"在实现实现\",{\"1\":{\"508\":1}}],[\"在实现同步组件时\",{\"1\":{\"507\":1}}],[\"在实际的业务开发中\",{\"1\":{\"216\":1}}],[\"在重写\",{\"1\":{\"507\":1}}],[\"在弄懂这点后会lock的实现理解有很大的提升\",{\"1\":{\"507\":1}}],[\"在锁的实现中聚合同步器\",{\"1\":{\"506\":1}}],[\"在超时时间内\",{\"1\":{\"520\":1}}],[\"在超时时间内没有获得同步状态返回\",{\"1\":{\"512\":1}}],[\"在超时内或者未中断的情况下能够获取锁\",{\"1\":{\"505\":1}}],[\"在超时购物\",{\"1\":{\"351\":1}}],[\"在针对并发编程中\",{\"1\":{\"503\":1}}],[\"在单例模式的实现上有一种双重检验锁定的方式\",{\"1\":{\"497\":1}}],[\"在单线程中\",{\"1\":{\"430\":1}}],[\"在单线程编程中我们会经常用到一些集合类\",{\"1\":{\"407\":1}}],[\"在单线程里实现多任务的调度\",{\"1\":{\"348\":1}}],[\"在前面说过\",{\"1\":{\"494\":1}}],[\"在前面的学习中\",{\"1\":{\"469\":1}}],[\"在引用对象对所有线程可见时\",{\"1\":{\"490\":1}}],[\"在构造函数\",{\"1\":{\"490\":1}}],[\"在构造函数内对一个\",{\"1\":{\"488\":1}}],[\"在构建线程的时候可以通过\",{\"1\":{\"422\":1}}],[\"在读一个对象的\",{\"1\":{\"487\":1}}],[\"在一个线程中\",{\"1\":{\"487\":1}}],[\"在一个函数内部\",{\"1\":{\"278\":1}}],[\"在对象引用为任意线程可见之前\",{\"1\":{\"487\":1}}],[\"在对指定值做进一步处理\",{\"1\":{\"397\":1}}],[\"在定义该\",{\"1\":{\"479\":1}}],[\"在满足一下三个条件时\",{\"1\":{\"479\":1}}],[\"在声明final实例成员变量时进行赋值\",{\"1\":{\"479\":1}}],[\"在非静态初始化块中以及构造器中赋初值\",{\"1\":{\"477\":1}}],[\"在非法或不适当的时间调用方法时产生的信号\",{\"1\":{\"300\":1}}],[\"在每个\",{\"1\":{\"469\":4}}],[\"在写\",{\"1\":{\"468\":1}}],[\"在六条\",{\"1\":{\"467\":1}}],[\"在生成汇编代码时会在\",{\"1\":{\"466\":1}}],[\"在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题\",{\"1\":{\"449\":1}}],[\"在聊到锁的优化也就是锁的几种状态前\",{\"1\":{\"446\":1}}],[\"在图中每一个箭头连接的两个节点就代表之间的\",{\"1\":{\"444\":1}}],[\"在上述五个接口中\",{\"1\":{\"505\":1}}],[\"在上一篇文章中我们了解到\",{\"1\":{\"465\":1}}],[\"在上一篇提到过\",{\"1\":{\"445\":1}}],[\"在上一篇讨论过\",{\"1\":{\"444\":1}}],[\"在上一篇中我们已经了解了\",{\"1\":{\"441\":1}}],[\"在上面的源码中我们可以看出在第1步中会先创建头结点\",{\"1\":{\"516\":1}}],[\"在上面的例子中一个创建了\",{\"1\":{\"420\":1}}],[\"在上面的这个\",{\"1\":{\"349\":1}}],[\"在上面我们提及到在\",{\"1\":{\"395\":1}}],[\"在上面非公平锁获取时\",{\"1\":{\"360\":1}}],[\"在设计\",{\"1\":{\"435\":1}}],[\"在我的理解中\",{\"1\":{\"435\":1}}],[\"在我看来\",{\"1\":{\"346\":1}}],[\"在不改变最终结果的前提下\",{\"1\":{\"433\":1}}],[\"在不改变程序执行结果的前提下\",{\"1\":{\"430\":1}}],[\"在java程序中所有实例域\",{\"1\":{\"428\":1}}],[\"在并发编程中主要需要解决两个问题\",{\"1\":{\"428\":1}}],[\"在并发场景中用于解决线程安全的问题\",{\"1\":{\"364\":1}}],[\"在现实生活中\",{\"1\":{\"428\":1}}],[\"在现在的企业开发中\",{\"1\":{\"200\":1}}],[\"在后台默默地守护一些系统服务\",{\"1\":{\"423\":1}}],[\"在后续篇幅会讲述\",{\"1\":{\"349\":1}}],[\"在等待的时间内还没有结束的话\",{\"1\":{\"420\":1}}],[\"在软件开发的过程中\",{\"1\":{\"420\":1}}],[\"在有多个处理器的机器上\",{\"1\":{\"414\":1}}],[\"在创建线程的时候尽量多考虑采用实现接口的形式\",{\"1\":{\"413\":1}}],[\"在用户程序中新建一个线程\",{\"1\":{\"413\":1}}],[\"在多处理器下\",{\"1\":{\"466\":1}}],[\"在多线程情况下\",{\"1\":{\"485\":1}}],[\"在多线程开发时需要从原子性\",{\"1\":{\"437\":1}}],[\"在多线程下原子操作例如\",{\"1\":{\"437\":1}}],[\"在多线程条件下\",{\"1\":{\"427\":1}}],[\"在多线程就很容易出现线程安全的问题\",{\"1\":{\"409\":1}}],[\"在多表查询时\",{\"1\":{\"205\":1}}],[\"在队列进行出队入队的时候免不了对节点需要进行操作\",{\"1\":{\"409\":1}}],[\"在队尾添加元素\",{\"1\":{\"293\":1}}],[\"在面试中也经常会有一些考点\",{\"1\":{\"407\":1}}],[\"在原容量大小的基础上右移一位\",{\"1\":{\"401\":1}}],[\"在table的i位置上插入forwardnode节点\",{\"1\":{\"401\":1}}],[\"在treeset类中\",{\"1\":{\"328\":1}}],[\"在nexttable的i+n的位置上插入另一个链表\",{\"1\":{\"401\":1}}],[\"在nexttable的i位置上插入一个链表\",{\"1\":{\"401\":1}}],[\"在之后会用到\",{\"1\":{\"401\":1}}],[\"在之前了解过\",{\"1\":{\"399\":1}}],[\"在之前介绍\",{\"1\":{\"385\":1}}],[\"在红黑树中查找即可\",{\"1\":{\"400\":1}}],[\"在红黑树中插入新值\",{\"1\":{\"399\":1}}],[\"在链表中如果找到了与待插入的键值对的\",{\"1\":{\"399\":1}}],[\"在链表中插入新值\",{\"1\":{\"399\":1}}],[\"在链表中插入新的键值对\",{\"1\":{\"399\":1}}],[\"在性能开销上也能兼顾\",{\"1\":{\"399\":1}}],[\"在熟悉上面的这核心信息之后\",{\"1\":{\"396\":1}}],[\"在理解\",{\"1\":{\"395\":1}}],[\"在理想情况下\",{\"1\":{\"227\":1}}],[\"在扩容时才会出现的特殊节点\",{\"1\":{\"394\":1}}],[\"在初始化过程中\",{\"1\":{\"393\":1}}],[\"在高并发的情况下\",{\"1\":{\"391\":1}}],[\"在使用\",{\"1\":{\"391\":1,\"397\":1}}],[\"在第\",{\"1\":{\"378\":1,\"398\":2,\"520\":1}}],[\"在第二步增加了处理逻辑\",{\"1\":{\"359\":1}}],[\"在功能特性上还是有很多的不同\",{\"1\":{\"375\":1}}],[\"在线程竞争激烈的情况下会升级为重量级锁\",{\"1\":{\"465\":1}}],[\"在线程间实现通信的往往会应用到\",{\"1\":{\"375\":1}}],[\"在线程获取锁的时候\",{\"1\":{\"359\":1}}],[\"在分析\",{\"1\":{\"364\":1}}],[\"在特殊的业务场景下先天的就适合于并发编程\",{\"1\":{\"346\":1}}],[\"在堆中加入元素\",{\"1\":{\"333\":1}}],[\"在map中若存在value\",{\"1\":{\"329\":1}}],[\"在map中若存在key\",{\"1\":{\"329\":1}}],[\"在map中加入键值对<key\",{\"1\":{\"329\":1}}],[\"在mysql数据库当中\",{\"1\":{\"182\":1}}],[\"在集合中删除元素e\",{\"1\":{\"328\":1}}],[\"在集合中添加元素e\",{\"1\":{\"328\":1}}],[\"在index位置插一个元素e\",{\"1\":{\"327\":1}}],[\"在in之后的列表中的值\",{\"1\":{\"194\":1}}],[\"在尾部添加一个元素e\",{\"1\":{\"327\":1}}],[\"在函数定义时抛出一些可能的异常\",{\"1\":{\"303\":1}}],[\"在函数内抛出一个异常\",{\"1\":{\"303\":1}}],[\"在末尾添加一个元素\",{\"1\":{\"291\":1}}],[\"在建表时\",{\"1\":{\"222\":1}}],[\"在指定的集合范围之内\",{\"1\":{\"212\":1}}],[\"在查询时给多表查询加上连接查询的条件\",{\"1\":{\"205\":1}}],[\"在比如\",{\"1\":{\"202\":1}}],[\"在任意一方加入外键\",{\"1\":{\"201\":1}}],[\"在业务层逻辑中\",{\"1\":{\"200\":1}}],[\"在数据库表中多的一方\",{\"1\":{\"200\":1}}],[\"在进行数据库表结构设计时\",{\"1\":{\"199\":1}}],[\"在根据指定的列统计的时候\",{\"1\":{\"195\":1}}],[\"在某个范围之内\",{\"1\":{\"194\":1}}],[\"在sql语句当中构造条件的运算符分为两类\",{\"1\":{\"194\":1}}],[\"在基本查询的\",{\"1\":{\"193\":1}}],[\"在修改数据时\",{\"1\":{\"189\":1}}],[\"在同步队列中的节点\",{\"1\":{\"516\":1}}],[\"在同步队列中得线程就会有机会重新获取该监视器\",{\"1\":{\"443\":1}}],[\"在同步组件的实现中\",{\"1\":{\"512\":1}}],[\"在同步组件的实现上主要是利用了\",{\"1\":{\"508\":1}}],[\"在同步组件实现中\",{\"1\":{\"507\":1}}],[\"在同步的时候是获取对象的\",{\"1\":{\"452\":1}}],[\"在同一时刻写锁是不能被多个线程所获取\",{\"1\":{\"366\":1}}],[\"在同一个时刻只允许一个线程占有锁\",{\"1\":{\"508\":1}}],[\"在同一个包中可以访问\",{\"1\":{\"282\":1}}],[\"在同一个类中存在多个函数\",{\"1\":{\"277\":1}}],[\"在同一个数据库服务器中\",{\"1\":{\"176\":1}}],[\"在同目录下创建\",{\"1\":{\"129\":1}}],[\"在命令行中输入密码\",{\"1\":{\"169\":1}}],[\"在执行程序时\",{\"1\":{\"430\":1}}],[\"在执行\",{\"1\":{\"158\":1,\"487\":1}}],[\"在服务安装后\",{\"1\":{\"134\":1}}],[\"在很早的时候就采用了\",{\"1\":{\"134\":1}}],[\"在标准硬件上\",{\"1\":{\"134\":1}}],[\"在这个时间点上没有正在执行的字节码\",{\"1\":{\"455\":1}}],[\"在这个页面中可以设置题目的时间限制\",{\"1\":{\"46\":1}}],[\"在这样的设备中\",{\"1\":{\"414\":1}}],[\"在这种情况下\",{\"1\":{\"133\":1}}],[\"在浏览器输入\",{\"1\":{\"128\":1}}],[\"在行中间执行时\",{\"1\":{\"71\":1}}],[\"在选择框中有简要介绍\",{\"1\":{\"49\":1}}],[\"在其它地方出题\",{\"1\":{\"44\":1}}],[\"在\",{\"1\":{\"44\":1,\"50\":1,\"126\":1,\"129\":1,\"139\":1,\"306\":2,\"358\":1,\"375\":1,\"386\":2,\"391\":1,\"393\":1,\"399\":3,\"402\":1,\"403\":1,\"409\":1,\"422\":1,\"441\":1,\"442\":1,\"449\":1,\"450\":3,\"476\":1,\"485\":1,\"494\":1,\"497\":1,\"504\":1,\"512\":3,\"513\":1}}],[\"在本教程中\",{\"1\":{\"22\":1}}],[\"网上有个流行语\",{\"1\":{\"428\":1}}],[\"网站信息爬取过程\",{\"1\":{\"96\":1}}],[\"网络安全\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"网络和数据库之上\",{\"1\":{\"9\":1}}],[\"网址中\",{\"1\":{\"81\":1}}],[\"网址\",{\"1\":{\"44\":1}}],[\"本章中我们只使用静态成员变量和静态成员函数\",{\"1\":{\"270\":1}}],[\"本溪\",{\"1\":{\"76\":1,\"77\":1}}],[\"本页面将简要介绍使用多人协作出题平台\",{\"1\":{\"43\":1}}],[\"本教程将指导你如何制作可视化图表\",{\"1\":{\"99\":1}}],[\"本教程将指导你如何爬取\",{\"1\":{\"79\":1}}],[\"本教程将指导你如何处理\",{\"1\":{\"74\":1}}],[\"本教程将指导你如何配置\",{\"1\":{\"64\":1}}],[\"本教程将指导你如何搭建\",{\"1\":{\"29\":1}}],[\"本教程指引你如何部署\",{\"1\":{\"25\":1}}],[\"本教程指引你如何配置\",{\"1\":{\"18\":1}}],[\"还包括\",{\"1\":{\"507\":1}}],[\"还包括中文的空格字符\",{\"1\":{\"324\":1}}],[\"还剩下\",{\"1\":{\"494\":1}}],[\"还剩下第三个问题\",{\"1\":{\"378\":1}}],[\"还未读到对象引用就在读取该对象的普通域变量\",{\"1\":{\"487\":1}}],[\"还是以上面的代码为例\",{\"1\":{\"468\":1}}],[\"还是不太完整的\",{\"1\":{\"445\":1}}],[\"还是应该知道它的实现原理\",{\"1\":{\"377\":1}}],[\"还会涉及到编译器指令重排序和处理器指令重排序\",{\"1\":{\"427\":1}}],[\"还在\",{\"1\":{\"403\":1}}],[\"还额外支持了超时机制\",{\"1\":{\"378\":1}}],[\"还提供了另外一个实现\",{\"1\":{\"364\":1}}],[\"还提供可视化的操作管理界面\",{\"1\":{\"134\":1}}],[\"还可以支持范围查询\",{\"1\":{\"221\":1}}],[\"还可以通过\",{\"1\":{\"47\":1}}],[\"还支持公平锁和非公平锁两种方式\",{\"1\":{\"358\":1}}],[\"还支持\",{\"1\":{\"134\":1}}],[\"还有一个比较有意思的就是\",{\"1\":{\"430\":1}}],[\"还有一点值得关注的是\",{\"1\":{\"387\":1}}],[\"还有一点需要注意的是\",{\"1\":{\"386\":1}}],[\"还有一些为面议\",{\"1\":{\"76\":1}}],[\"还有内置的\",{\"1\":{\"41\":1}}],[\"还要实现应用之间的互操作\",{\"1\":{\"9\":1}}],[\"文章开篇提到等待\",{\"1\":{\"380\":1}}],[\"文档\",{\"1\":{\"134\":1}}],[\"文档全面\",{\"1\":{\"134\":1}}],[\"文档和项目\",{\"1\":{\"41\":1}}],[\"文本数据\",{\"1\":{\"132\":1}}],[\"文本位置设置为右侧\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"文昌\",{\"1\":{\"76\":1,\"77\":1}}],[\"文山壮族苗族自治州\",{\"1\":{\"76\":1,\"77\":1}}],[\"文件名\",{\"1\":{\"158\":2}}],[\"文件参数变量\",{\"0\":{\"158\":1}}],[\"文件开头需要写\",{\"1\":{\"146\":1}}],[\"文件路径\",{\"1\":{\"142\":1}}],[\"文件的管理\",{\"1\":{\"134\":1}}],[\"文件的数据\",{\"1\":{\"75\":1}}],[\"文件\",{\"1\":{\"49\":1,\"75\":2,\"126\":2,\"129\":1,\"142\":3,\"146\":1}}],[\"文件夹\",{\"1\":{\"22\":1,\"35\":2}}],[\"上面一共有八条原子操作\",{\"1\":{\"494\":1}}],[\"上面这四个语句中只有第\",{\"1\":{\"494\":1}}],[\"上面对\",{\"1\":{\"490\":1}}],[\"上面我们提到过\",{\"1\":{\"489\":1}}],[\"上面用黄色高亮的部分就是需要注意的部分了\",{\"1\":{\"443\":1}}],[\"上面的这个例子实现了独占锁的语义\",{\"1\":{\"508\":1}}],[\"上面的这些指令操作是相当底层的\",{\"1\":{\"494\":1}}],[\"上面的实例代码对应的\",{\"1\":{\"467\":1}}],[\"上面的\",{\"1\":{\"443\":1,\"508\":1}}],[\"上面的代码中有一个同步代码块\",{\"1\":{\"443\":1}}],[\"上面的第\",{\"1\":{\"432\":2}}],[\"上面的重排序原则\",{\"1\":{\"431\":1}}],[\"上面的例子中\",{\"1\":{\"423\":1}}],[\"上的线程\",{\"1\":{\"375\":2}}],[\"上述其他几条性质也是吻合的\",{\"1\":{\"484\":1}}],[\"上述语法中的\",{\"1\":{\"178\":1}}],[\"上述指令\",{\"1\":{\"169\":1}}],[\"上一条命令的退出状态\",{\"1\":{\"159\":1}}],[\"上一步完成推送后\",{\"1\":{\"27\":1}}],[\"上启动\",{\"1\":{\"129\":1}}],[\"上边距设置为\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"上饶\",{\"1\":{\"76\":1,\"77\":1}}],[\"上海\",{\"1\":{\"76\":2,\"77\":2}}],[\"上海市\",{\"1\":{\"76\":1,\"77\":1}}],[\"上传题目数据\",{\"0\":{\"59\":1},\"1\":{\"39\":1}}],[\"算法设计的再合理\",{\"1\":{\"399\":1}}],[\"算法来保障线程安全的操作\",{\"1\":{\"395\":1}}],[\"算法保证了线程安全性\",{\"1\":{\"393\":1}}],[\"算法工程师\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"算法题目\",{\"1\":{\"38\":1}}],[\"算法笔记\",{\"0\":{\"13\":1}}],[\"前缀的指令会引起处理器缓存写回内存\",{\"1\":{\"466\":1}}],[\"前缀的指令在多核处理器下会发现什么事情了\",{\"1\":{\"466\":1}}],[\"前缀的指令\",{\"1\":{\"466\":2}}],[\"前一个线程将接力棒传给下一个线程\",{\"1\":{\"420\":1}}],[\"前者是\",{\"1\":{\"324\":1,\"375\":1}}],[\"前端在请求服务端时\",{\"1\":{\"198\":1}}],[\"前端查询数据库的流程\",{\"1\":{\"198\":1}}],[\"前台启动\",{\"1\":{\"126\":1}}],[\"前情提要\",{\"1\":{\"94\":1}}],[\"前程无忧\",{\"0\":{\"94\":1},\"1\":{\"96\":1},\"2\":{\"98\":1}}],[\"前面我们已经知道\",{\"1\":{\"379\":1}}],[\"前面我们说过\",{\"1\":{\"377\":1}}],[\"前面我们获取了两个网站的数据\",{\"1\":{\"75\":1}}],[\"前面还是为了实现getreadholdcount等新功能\",{\"1\":{\"370\":1}}],[\"前面新建文件夹node\",{\"1\":{\"34\":1}}],[\"前言\",{\"1\":{\"65\":1,\"76\":1,\"99\":1}}],[\"前往\",{\"1\":{\"27\":1}}],[\"u\",{\"1\":{\"393\":3,\"395\":3,\"398\":2,\"401\":2,\"402\":4,\"435\":1,\"450\":1}}],[\"u3000\",{\"1\":{\"324\":1}}],[\"u用户名\",{\"1\":{\"169\":1}}],[\"uncontended\",{\"1\":{\"402\":3}}],[\"unchecked\",{\"1\":{\"398\":1,\"401\":1}}],[\"untreefi\",{\"1\":{\"401\":1}}],[\"untreeify\",{\"1\":{\"401\":4}}],[\"unparksuccessor\",{\"1\":{\"518\":5,\"523\":3}}],[\"unpark\",{\"1\":{\"379\":1,\"385\":2,\"386\":2,\"387\":3,\"518\":3}}],[\"unlike\",{\"1\":{\"523\":1}}],[\"unlink\",{\"1\":{\"394\":1}}],[\"unlinkcancelledwaiters\",{\"1\":{\"378\":2}}],[\"unlocked\",{\"1\":{\"508\":1}}],[\"unlock\",{\"1\":{\"316\":2,\"371\":4,\"377\":1,\"381\":2,\"494\":4,\"504\":2,\"508\":2}}],[\"unmatchedunlockexception\",{\"1\":{\"370\":1}}],[\"unused\",{\"1\":{\"369\":1,\"370\":1,\"508\":2}}],[\"unsafe\",{\"1\":{\"386\":4,\"393\":3,\"409\":6}}],[\"unsupportedoperationexception\",{\"1\":{\"300\":1,\"507\":1}}],[\"unsigned\",{\"1\":{\"183\":1}}],[\"unset\",{\"1\":{\"154\":2}}],[\"unit\",{\"1\":{\"369\":2,\"370\":1,\"375\":1,\"505\":1,\"508\":2}}],[\"unique\",{\"1\":{\"182\":1,\"201\":1,\"222\":1}}],[\"uninstall\",{\"1\":{\"129\":1}}],[\"unix\",{\"1\":{\"126\":1}}],[\"usual\",{\"1\":{\"523\":1}}],[\"usr\",{\"1\":{\"146\":3}}],[\"uses\",{\"1\":{\"523\":1}}],[\"usebiasedlocking\",{\"1\":{\"456\":1}}],[\"used\",{\"1\":{\"402\":2,\"484\":1}}],[\"use\",{\"1\":{\"52\":1,\"177\":1,\"371\":1,\"394\":1,\"494\":2}}],[\"username\",{\"1\":{\"183\":2}}],[\"user=admin\",{\"1\":{\"126\":2}}],[\"user\",{\"1\":{\"34\":1,\"139\":1}}],[\"upon\",{\"1\":{\"394\":1,\"523\":1}}],[\"up\",{\"1\":{\"378\":1,\"379\":1}}],[\"updating\",{\"1\":{\"369\":1}}],[\"update\",{\"0\":{\"189\":1},\"1\":{\"23\":2,\"187\":1,\"189\":5,\"190\":1,\"210\":1,\"220\":1,\"366\":1}}],[\"uploadobjectargs\",{\"1\":{\"142\":1}}],[\"uploadobject\",{\"1\":{\"142\":1}}],[\"util\",{\"0\":{\"335\":1,\"336\":1,\"337\":1},\"1\":{\"236\":1,\"239\":9,\"240\":2,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"254\":3,\"256\":1,\"257\":1,\"259\":2,\"261\":1,\"269\":1,\"273\":1,\"276\":1,\"277\":1,\"278\":1,\"291\":3,\"292\":1,\"293\":3,\"294\":4,\"295\":4,\"302\":1,\"303\":1,\"316\":1,\"385\":1,\"386\":2,\"417\":1,\"503\":1}}],[\"utils\",{\"1\":{\"107\":1}}],[\"utf\",{\"1\":{\"77\":1,\"86\":1,\"93\":1,\"324\":3}}],[\"ui\",{\"1\":{\"85\":1}}],[\"ui设计师\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"url\",{\"1\":{\"84\":7,\"85\":1,\"86\":9,\"91\":7,\"92\":1,\"93\":9}}],[\"高效的数据检索\",{\"1\":{\"227\":1}}],[\"高效地开发和集成复杂的应用软件\",{\"1\":{\"9\":1}}],[\"高性能的工具类\",{\"1\":{\"503\":1}}],[\"高性能\",{\"1\":{\"133\":1,\"134\":1}}],[\"高级系统设置\",{\"1\":{\"34\":1}}],[\"如有必要可以使用\",{\"1\":{\"456\":1}}],[\"如图在\",{\"1\":{\"452\":1}}],[\"如图\",{\"1\":{\"378\":1,\"408\":1,\"430\":1,\"442\":1,\"443\":1}}],[\"如图队列中的线程引用依次为\",{\"1\":{\"377\":1}}],[\"如图所示\",{\"0\":{\"33\":1},\"1\":{\"377\":1}}],[\"如上图为\",{\"1\":{\"429\":1}}],[\"如上图\",{\"1\":{\"380\":1,\"399\":1,\"455\":1}}],[\"如上所述\",{\"1\":{\"349\":1}}],[\"如上例中值为\",{\"1\":{\"159\":2}}],[\"如上例中值为4\",{\"1\":{\"159\":1}}],[\"如此评价这种情况\",{\"1\":{\"346\":1}}],[\"如何关闭偏向锁\",{\"0\":{\"456\":1}}],[\"如何正确理解由于jmm内存模型在原子性\",{\"1\":{\"349\":1}}],[\"如何正确的使用多线程编程技术有很大的学问\",{\"1\":{\"349\":1}}],[\"如何把头脑中的想法变成简洁的代码\",{\"1\":{\"242\":1}}],[\"如何破解\",{\"1\":{\"70\":1}}],[\"如用户\",{\"1\":{\"133\":1}}],[\"如启动信息\",{\"1\":{\"126\":1}}],[\"如下图\",{\"1\":{\"481\":1,\"483\":1}}],[\"如下图所示\",{\"1\":{\"413\":1,\"503\":1}}],[\"如下图所示即安装成功\",{\"1\":{\"67\":1}}],[\"如下\",{\"1\":{\"101\":1,\"435\":1,\"487\":1}}],[\"如\",{\"1\":{\"48\":1,\"178\":2,\"205\":1,\"221\":1,\"299\":2}}],[\"如果理解了上面的内容对这部分的理解也是水到渠成的\",{\"1\":{\"524\":1}}],[\"如果还没有超时\",{\"1\":{\"520\":1}}],[\"如果同步状态释放成功\",{\"1\":{\"518\":1}}],[\"如果先驱节点是头结点的并且成功获得同步状态的时候\",{\"1\":{\"516\":1}}],[\"如果去查看源码的实现\",{\"1\":{\"505\":1}}],[\"如果我们需要更大范围的原子性操作就可以使用\",{\"1\":{\"494\":1}}],[\"如果以\",{\"1\":{\"489\":1}}],[\"如果可见的\",{\"1\":{\"488\":1}}],[\"如果失败\",{\"1\":{\"458\":1,\"459\":1}}],[\"如果成功则方法结束返回\",{\"1\":{\"515\":1}}],[\"如果成功\",{\"1\":{\"458\":1,\"459\":1}}],[\"如果成立\",{\"1\":{\"243\":1}}],[\"如果设置了\",{\"1\":{\"454\":1}}],[\"如果测试失败\",{\"1\":{\"454\":1}}],[\"如果测试成功\",{\"1\":{\"454\":1}}],[\"如果对声明了\",{\"1\":{\"466\":1}}],[\"如果对多个共享变量进行操作\",{\"1\":{\"451\":1}}],[\"如果对这有疑问的话\",{\"1\":{\"399\":1}}],[\"如果出现冲突了怎么办\",{\"1\":{\"448\":1}}],[\"如果出现有关`crlf`\",{\"1\":{\"26\":1}}],[\"如果获取失败则插入同步队列进行等待\",{\"1\":{\"512\":1}}],[\"如果获取失败\",{\"1\":{\"443\":1}}],[\"如果获取的话再得到等待队列的头指针引用的节点\",{\"1\":{\"379\":1}}],[\"如果多线程间没有共享的数据也就是说多线程间并没有协作完成一件事情\",{\"1\":{\"441\":1}}],[\"如果结果正确的话自然而然总数就应该是\",{\"1\":{\"441\":1}}],[\"如果编译器经过细致的分析后\",{\"1\":{\"435\":2}}],[\"如果让\",{\"1\":{\"494\":1}}],[\"如果让我们设计\",{\"1\":{\"434\":1}}],[\"如果让程序员再去了解这些底层的实现以及具体规则\",{\"1\":{\"431\":1}}],[\"如果a\",{\"1\":{\"432\":1}}],[\"如果重排序之后的执行结果\",{\"1\":{\"432\":1}}],[\"如果重排序会对最终执行结果会存在影响\",{\"1\":{\"430\":1}}],[\"如果将小明妈妈和小明作为两个线程\",{\"1\":{\"428\":1}}],[\"如果线程仍然活着\",{\"1\":{\"455\":1}}],[\"如果线程不处于活动状态\",{\"1\":{\"455\":1}}],[\"如果线程\",{\"1\":{\"420\":1,\"429\":1,\"433\":2,\"494\":1}}],[\"如果有必要就重写\",{\"1\":{\"484\":1}}],[\"如果有\",{\"1\":{\"403\":1}}],[\"如果有前驱节点说明有线程比当前线程更早的请求资源\",{\"1\":{\"360\":1}}],[\"如果check值大于等于0\",{\"1\":{\"402\":1}}],[\"如果它是一个链表的头节点\",{\"1\":{\"401\":1}}],[\"如果遍历到forwardingnode节点\",{\"1\":{\"401\":1}}],[\"如果长度大于\",{\"1\":{\"399\":1}}],[\"如果遇到\",{\"1\":{\"399\":1}}],[\"如果直到找到了链表的末尾都没有找到的话\",{\"1\":{\"399\":1}}],[\"如果到链表末尾仍未找到\",{\"1\":{\"399\":1}}],[\"如果插入值待插入的位置刚好所在的\",{\"1\":{\"399\":1}}],[\"如果超过了临界值\",{\"1\":{\"399\":2}}],[\"如果选择是无参的构造器的话\",{\"1\":{\"398\":1}}],[\"如果指定值大于了所允许的最大值的话就取最大值\",{\"1\":{\"397\":1}}],[\"如果小于\",{\"1\":{\"397\":1,\"400\":1}}],[\"如果小于60\",{\"1\":{\"239\":1}}],[\"如果当前链表节点个数大于等于\",{\"1\":{\"399\":1}}],[\"如果当前节点的前驱节点是头节点\",{\"1\":{\"517\":1}}],[\"如果当前节点的先驱节点是头结点并且成功获取同步状态\",{\"1\":{\"516\":1}}],[\"如果当前节点释放同步状态会通知后继节点\",{\"1\":{\"513\":1}}],[\"如果当前节点不为\",{\"1\":{\"399\":1}}],[\"如果当前节点没有前驱节点的话\",{\"1\":{\"360\":1}}],[\"如果当前\",{\"1\":{\"399\":2}}],[\"如果当前table还没有初始化先调用inittable方法将tab进行初始化\",{\"1\":{\"399\":1}}],[\"如果当前数组为\",{\"1\":{\"393\":1}}],[\"如果为\",{\"1\":{\"393\":2}}],[\"如果调用\",{\"1\":{\"386\":1}}],[\"如果许可尚不可用\",{\"1\":{\"385\":1}}],[\"如果释放成功则正常返回\",{\"1\":{\"378\":1}}],[\"如果等待队列的\",{\"1\":{\"378\":1}}],[\"如果该节点\",{\"1\":{\"399\":1}}],[\"如果该许可可用\",{\"1\":{\"385\":1}}],[\"如果该线程能够从\",{\"1\":{\"378\":1}}],[\"如果该锁已经被线程所占有了\",{\"1\":{\"359\":1}}],[\"如果该锁未被任何线程占有\",{\"1\":{\"359\":1}}],[\"如果在一个线程观察另一个线程\",{\"1\":{\"497\":1}}],[\"如果在本线程内观察\",{\"1\":{\"497\":1}}],[\"如果在下一次竞争中\",{\"1\":{\"422\":1}}],[\"如果在红黑树中存在与待插入键值对的\",{\"1\":{\"399\":1}}],[\"如果在同步队列中能够竞争到\",{\"1\":{\"375\":1}}],[\"如果在等待状态中被中断会抛出被中断异常\",{\"1\":{\"375\":1}}],[\"如果在业务系统当中\",{\"1\":{\"201\":1}}],[\"如果其他处理器缓存的值还是旧的\",{\"1\":{\"466\":1}}],[\"如果其他线程调用\",{\"1\":{\"375\":1}}],[\"如果其中有一条\",{\"1\":{\"216\":1}}],[\"如果\",{\"1\":{\"369\":1,\"380\":1,\"432\":1,\"433\":1,\"444\":1,\"451\":1,\"467\":1,\"478\":2,\"479\":2,\"497\":1,\"516\":3}}],[\"如果写锁已经被获取并且获取写锁的线程不是当前线程的话\",{\"1\":{\"369\":1}}],[\"如果仅仅是读数据的话并不会影响数据正确性\",{\"1\":{\"364\":1}}],[\"如果锁的是类对象的话\",{\"1\":{\"442\":1}}],[\"如果锁被获取\",{\"1\":{\"359\":1}}],[\"如果锁已经被其他线程获取\",{\"1\":{\"316\":1}}],[\"如果已经获取锁的线程是当前线程的话则直接再次获取成功\",{\"1\":{\"359\":1}}],[\"如果已经有其他线程在执行扩容操作\",{\"1\":{\"402\":1}}],[\"如果已经有\",{\"1\":{\"324\":1}}],[\"如果系统内只有一个\",{\"1\":{\"352\":1}}],[\"如果一个操作\",{\"1\":{\"432\":1}}],[\"如果一个线程实例\",{\"1\":{\"420\":1}}],[\"如果一个锁是公平的\",{\"1\":{\"360\":1}}],[\"如果一个类只允许创建一个对象\",{\"1\":{\"342\":1}}],[\"如果一件物品没了\",{\"1\":{\"351\":1}}],[\"如果某个类包含的数据在系统中只应保存一份\",{\"1\":{\"342\":1}}],[\"如果找到\",{\"1\":{\"336\":1}}],[\"如果发现k\",{\"1\":{\"329\":1}}],[\"如果map中有key\",{\"1\":{\"329\":1}}],[\"如果修改了原list的大小\",{\"1\":{\"327\":1}}],[\"如果你确定应用程序里所有的锁通常情况下处于竞争状态\",{\"1\":{\"456\":1}}],[\"如果你在调用了sublist返回了子list之后\",{\"1\":{\"327\":1}}],[\"如果你有需求\",{\"1\":{\"22\":1}}],[\"如果两个操作访问同一个变量\",{\"1\":{\"430\":1}}],[\"如果两个数组长度相同\",{\"1\":{\"322\":1}}],[\"如果两个值相等\",{\"1\":{\"275\":1}}],[\"如果end大于arr\",{\"1\":{\"322\":1}}],[\"如果应用程序试图创建大小为负的数组\",{\"1\":{\"300\":1}}],[\"如果索引为负或大于等于数组大小\",{\"1\":{\"300\":1}}],[\"如果程序执行到了这里\",{\"1\":{\"275\":1}}],[\"如果打算修改字符串\",{\"1\":{\"262\":1}}],[\"如果条件成立\",{\"1\":{\"243\":1}}],[\"如果大于等于60并且小于70\",{\"1\":{\"239\":1}}],[\"如果大于等于70并且小于85\",{\"1\":{\"239\":1}}],[\"如果大于等于85\",{\"1\":{\"239\":1}}],[\"如果存在冲突\",{\"1\":{\"226\":1}}],[\"如果存在则不创建\",{\"1\":{\"176\":1}}],[\"如果事务执行出现错误\",{\"1\":{\"218\":1}}],[\"如果事务成功的完成\",{\"1\":{\"218\":1}}],[\"如果查询的是第一页数据\",{\"1\":{\"198\":1}}],[\"如果不出现线程安全的问题最终的结果应该就是\",{\"1\":{\"494\":1}}],[\"如果不出现哈希冲突的时候\",{\"1\":{\"399\":1}}],[\"如果不使用同步的话\",{\"1\":{\"461\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"430\":1}}],[\"如果不用考虑这些线程在运行时环境下的调度和交替运行\",{\"1\":{\"427\":1}}],[\"如果不是树节点\",{\"1\":{\"400\":1}}],[\"如果不是数值类型\",{\"1\":{\"195\":1}}],[\"如果不处理\",{\"1\":{\"299\":1}}],[\"如果不加该参数项\",{\"1\":{\"186\":1}}],[\"如果这里自旋时间过长对性能是很大的消耗\",{\"1\":{\"451\":1}}],[\"如果这个节点的类型是\",{\"1\":{\"399\":1}}],[\"如果这个位置为空\",{\"1\":{\"401\":1}}],[\"如果这个位置存在结点\",{\"1\":{\"399\":1}}],[\"如果这个位置是\",{\"1\":{\"399\":1,\"401\":2}}],[\"如果这一列中有\",{\"1\":{\"195\":1}}],[\"如果这些代码需要\",{\"1\":{\"48\":1}}],[\"如果没有设置\",{\"1\":{\"454\":1}}],[\"如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处\",{\"1\":{\"443\":1}}],[\"如果没有获取\",{\"1\":{\"379\":1}}],[\"如果没有\",{\"1\":{\"324\":1,\"403\":1}}],[\"如果没有特别指明\",{\"1\":{\"221\":1}}],[\"如果没有条件\",{\"1\":{\"189\":1,\"190\":1}}],[\"如果没有联网\",{\"1\":{\"67\":1}}],[\"如果未指定该字段值\",{\"1\":{\"182\":1}}],[\"如果数据结构是红黑树\",{\"1\":{\"221\":1}}],[\"如果数据库存在\",{\"1\":{\"178\":1}}],[\"如果数据中存在变量没有达到最小值或最大值\",{\"1\":{\"55\":1}}],[\"如果删除一个不存在的数据库\",{\"1\":{\"178\":1}}],[\"如果要使用\",{\"1\":{\"129\":1}}],[\"如果用时在时限的一半到两倍之间\",{\"1\":{\"55\":1}}],[\"如果拍出错就会显示\",{\"1\":{\"53\":1}}],[\"如果勾选了\",{\"1\":{\"52\":1}}],[\"如果需要有序的数据\",{\"1\":{\"228\":1}}],[\"如果需要自己编写\",{\"1\":{\"49\":1}}],[\"如果需要在题面中添加图片\",{\"1\":{\"47\":1}}],[\"如果是树节点在红黑树中查找节点\",{\"1\":{\"400\":1}}],[\"如果是链表节点\",{\"1\":{\"399\":1}}],[\"如果是独占式锁的话\",{\"1\":{\"377\":1}}],[\"如果是的话\",{\"1\":{\"359\":1}}],[\"如果是闰年输出yes\",{\"1\":{\"239\":1}}],[\"如果是升序\",{\"1\":{\"197\":1}}],[\"如果是\",{\"1\":{\"48\":1,\"134\":1,\"417\":1}}],[\"不保证线程\",{\"1\":{\"488\":1}}],[\"不提供\",{\"1\":{\"484\":1}}],[\"不加以注意的也容易出现线程安全的问题\",{\"1\":{\"437\":1}}],[\"不执行任何代码\",{\"1\":{\"415\":1}}],[\"不要调用\",{\"1\":{\"413\":1}}],[\"不要死记硬背\",{\"1\":{\"146\":1}}],[\"不采用\",{\"1\":{\"403\":1}}],[\"不为\",{\"1\":{\"399\":1}}],[\"不为0则更新同步状态\",{\"1\":{\"367\":1}}],[\"不相同\",{\"1\":{\"393\":1,\"449\":1}}],[\"不响应中断的支持\",{\"1\":{\"378\":1}}],[\"不成功释放同步状态抛出异常\",{\"1\":{\"378\":1}}],[\"不支持\",{\"1\":{\"375\":1}}],[\"不支持锁升级\",{\"1\":{\"371\":1}}],[\"不难理解与\",{\"1\":{\"367\":1}}],[\"不仅支持重入性\",{\"1\":{\"358\":1}}],[\"不仅有队列\",{\"1\":{\"330\":1}}],[\"不断通过切换线程\",{\"1\":{\"348\":1}}],[\"不久以后会拥有超强的计算能力\",{\"1\":{\"346\":1}}],[\"不建议把null添加到队列中\",{\"1\":{\"331\":1}}],[\"不建议安装在c盘\",{\"1\":{\"32\":1}}],[\"不推荐\",{\"1\":{\"324\":1}}],[\"不可再分的\",{\"1\":{\"494\":1}}],[\"不可变类的意思是创建该类的实例后\",{\"1\":{\"484\":1}}],[\"不可变类\",{\"1\":{\"484\":1}}],[\"不可变字符串\",{\"1\":{\"323\":1}}],[\"不可嵌套\",{\"1\":{\"159\":1}}],[\"不存在则返回null\",{\"1\":{\"294\":2,\"295\":2}}],[\"不添加修饰符\",{\"1\":{\"282\":1}}],[\"不管运行多少次都是小于\",{\"1\":{\"494\":1}}],[\"不管怎么重排序\",{\"1\":{\"430\":1}}],[\"不管条件的值如何\",{\"1\":{\"244\":1}}],[\"不管其是存放的数据块还是奇偶校验块\",{\"1\":{\"134\":1}}],[\"不在指定的集合范围之内\",{\"1\":{\"212\":1}}],[\"不适用与分布式\",{\"1\":{\"200\":1}}],[\"不参与分组\",{\"1\":{\"196\":1}}],[\"不满足\",{\"1\":{\"196\":1}}],[\"不是最新版本的值了\",{\"1\":{\"449\":1}}],[\"不是最终的题目名\",{\"1\":{\"45\":1}}],[\"不是顺序执行的\",{\"1\":{\"430\":1}}],[\"不是线程安全的\",{\"1\":{\"407\":1}}],[\"不是有序的\",{\"1\":{\"228\":1}}],[\"不是树结构最下面的节点\",{\"1\":{\"221\":1}}],[\"不是\",{\"1\":{\"194\":1}}],[\"不等于\",{\"1\":{\"194\":1,\"239\":1}}],[\"不带任何的查询条件\",{\"1\":{\"193\":1}}],[\"不带任何条件\",{\"1\":{\"192\":1}}],[\"不超过255个字符的二进制数据\",{\"1\":{\"183\":1}}],[\"不重复的\",{\"1\":{\"182\":1}}],[\"不用引号\",{\"1\":{\"156\":1}}],[\"不会对写\",{\"1\":{\"489\":1}}],[\"不会改变程序执行结果的重排序\",{\"1\":{\"435\":1}}],[\"不会取变量\",{\"1\":{\"156\":1}}],[\"不会执行\",{\"1\":{\"156\":1}}],[\"不会被引用\",{\"1\":{\"86\":1,\"93\":1}}],[\"不需要加\",{\"1\":{\"151\":1}}],[\"不需要创建\",{\"1\":{\"141\":1}}],[\"不需要管\",{\"1\":{\"23\":1}}],[\"不同的情况做不同的处理\",{\"1\":{\"508\":1}}],[\"不同的线程处理不同段的数据\",{\"1\":{\"348\":1}}],[\"不同的键可能会产生相同的哈希值\",{\"1\":{\"226\":1}}],[\"不同的数据库有不同的实现\",{\"1\":{\"198\":1}}],[\"不同\",{\"1\":{\"134\":1}}],[\"不能让这个被构造的对象被其他线程可见\",{\"1\":{\"490\":1}}],[\"不能重排序\",{\"1\":{\"488\":1}}],[\"不能重名\",{\"1\":{\"233\":1}}],[\"不能被重排序\",{\"1\":{\"488\":1}}],[\"不能被100整除时\",{\"1\":{\"239\":1}}],[\"不能对基本数据类型变量重新赋值\",{\"1\":{\"479\":1}}],[\"不能对聚合函数进行判断\",{\"1\":{\"196\":1}}],[\"不能带来巨大的价值\",{\"1\":{\"441\":1}}],[\"不能进行重排序\",{\"1\":{\"430\":1}}],[\"不能多继承可以实现多个接口\",{\"1\":{\"413\":1}}],[\"不能中断任何线程\",{\"1\":{\"315\":1}}],[\"不能写入\",{\"1\":{\"260\":1}}],[\"不能修改\",{\"1\":{\"260\":1}}],[\"不能创建两个名称相同的数据库\",{\"1\":{\"176\":1}}],[\"不能自行指定安装的路径\",{\"1\":{\"67\":1}}],[\"不能使用\",{\"1\":{\"47\":1}}],[\"jmm在不改变正确语义的前提下\",{\"1\":{\"469\":1}}],[\"jmm的设计图为\",{\"1\":{\"435\":1}}],[\"jmm\",{\"0\":{\"427\":1,\"429\":1,\"435\":1,\"436\":1},\"1\":{\"427\":1,\"429\":3,\"430\":2,\"431\":1,\"432\":7,\"434\":4,\"435\":13,\"436\":1,\"441\":1,\"445\":1,\"467\":1,\"469\":4,\"487\":2,\"488\":2}}],[\"jit\",{\"1\":{\"423\":1}}],[\"jdk6\",{\"1\":{\"403\":1}}],[\"jdk\",{\"1\":{\"391\":2,\"484\":1}}],[\"jdk1\",{\"1\":{\"391\":1,\"399\":1,\"449\":1}}],[\"jdk7\",{\"1\":{\"304\":1}}],[\"just\",{\"1\":{\"398\":1,\"508\":1,\"518\":1}}],[\"juc\",{\"0\":{\"539\":1},\"2\":{\"356\":1,\"362\":1,\"373\":1,\"383\":1,\"389\":1,\"405\":1,\"411\":1,\"425\":1,\"439\":1,\"463\":1,\"472\":1,\"492\":1,\"501\":1,\"510\":1,\"526\":1}}],[\"jupyter\",{\"1\":{\"99\":3},\"2\":{\"72\":1,\"123\":1}}],[\"jps\",{\"1\":{\"349\":1}}],[\"jpg\",{\"1\":{\"142\":9}}],[\"jvm\",{\"1\":{\"297\":1,\"323\":1,\"413\":1,\"422\":1,\"451\":1,\"452\":1,\"456\":2,\"458\":1,\"466\":1,\"494\":2}}],[\"j\",{\"1\":{\"245\":4,\"249\":7,\"254\":6,\"255\":4,\"273\":5,\"435\":1,\"450\":1}}],[\"jbods\",{\"1\":{\"134\":1}}],[\"jl=城市\",{\"1\":{\"88\":1}}],[\"jl=489\",{\"1\":{\"88\":1,\"93\":1}}],[\"jointhread\",{\"1\":{\"420\":3}}],[\"joindemo\",{\"1\":{\"420\":1}}],[\"join方法源码关键是\",{\"1\":{\"420\":1}}],[\"join\",{\"0\":{\"420\":1},\"1\":{\"85\":2,\"86\":2,\"92\":2,\"93\":2,\"96\":1,\"207\":1,\"208\":2,\"315\":1,\"316\":2,\"317\":4,\"324\":2,\"417\":2,\"420\":9,\"433\":3}}],[\"jobyear\",{\"1\":{\"96\":1}}],[\"jobsalary\",{\"1\":{\"96\":1}}],[\"jobskilltags\",{\"1\":{\"92\":1,\"93\":1}}],[\"jobtitle\",{\"1\":{\"96\":1}}],[\"jobarea\",{\"1\":{\"95\":1,\"96\":1}}],[\"jobarea=020000\",{\"1\":{\"95\":1,\"96\":1}}],[\"jobknowledgewelfarefeatures\",{\"1\":{\"92\":1,\"93\":1}}],[\"jobdegree\",{\"1\":{\"85\":1,\"86\":1,\"96\":1}}],[\"jobexperience\",{\"1\":{\"85\":1,\"86\":1}}],[\"jobname\",{\"1\":{\"85\":1,\"86\":1}}],[\"joblist\",{\"1\":{\"82\":1,\"85\":4,\"86\":4,\"92\":2,\"93\":2,\"96\":2}}],[\"job\",{\"1\":{\"82\":1,\"85\":10,\"86\":11,\"92\":10,\"93\":10,\"95\":1,\"96\":1}}],[\"java对象头\",{\"1\":{\"446\":1}}],[\"javap\",{\"1\":{\"443\":1}}],[\"java并发编程的艺术\",{\"1\":{\"348\":1,\"417\":1,\"469\":1,\"507\":1}}],[\"javafx\",{\"0\":{\"337\":1}}],[\"javadoc\",{\"1\":{\"308\":1}}],[\"javaee\",{\"1\":{\"306\":2}}],[\"javase\",{\"1\":{\"306\":1,\"452\":1}}],[\"javascript\",{\"1\":{\"30\":2}}],[\"java\",{\"0\":{\"231\":1,\"335\":1,\"336\":1,\"426\":1,\"452\":1,\"535\":1},\"1\":{\"75\":1,\"77\":1,\"81\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1,\"134\":2,\"236\":3,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"254\":3,\"256\":1,\"257\":1,\"259\":2,\"261\":1,\"269\":1,\"273\":1,\"276\":1,\"277\":1,\"278\":1,\"291\":3,\"292\":1,\"293\":3,\"294\":4,\"295\":4,\"297\":1,\"300\":2,\"302\":1,\"303\":2,\"304\":2,\"310\":8,\"316\":1,\"321\":1,\"324\":1,\"330\":2,\"337\":1,\"349\":13,\"358\":1,\"364\":2,\"375\":3,\"385\":1,\"386\":12,\"391\":2,\"393\":1,\"409\":1,\"413\":3,\"417\":2,\"422\":1,\"423\":5,\"427\":1,\"428\":1,\"432\":3,\"436\":2,\"441\":2,\"442\":1,\"445\":2,\"446\":1,\"451\":2,\"452\":2,\"456\":2,\"465\":3,\"466\":1,\"469\":1,\"476\":1,\"485\":3,\"494\":3,\"497\":2,\"503\":1,\"504\":2,\"505\":1,\"508\":1},\"2\":{\"229\":1,\"319\":1,\"339\":1}}],[\"jetbrains\",{\"1\":{\"68\":1,\"70\":1}}],[\"jsr\",{\"1\":{\"432\":1}}],[\"jstack\",{\"1\":{\"349\":1}}],[\"jscode\",{\"1\":{\"107\":1}}],[\"js®\",{\"1\":{\"30\":1}}],[\"js\",{\"0\":{\"30\":1},\"1\":{\"75\":1,\"77\":1,\"95\":2,\"101\":1,\"107\":1,\"115\":1,\"121\":1},\"2\":{\"36\":1}}],[\"json串\",{\"1\":{\"141\":1}}],[\"json返回的是一个字典类型\",{\"1\":{\"84\":1}}],[\"json网址\",{\"1\":{\"84\":1}}],[\"json\",{\"1\":{\"81\":2,\"82\":1,\"84\":7,\"85\":3,\"86\":10,\"91\":6,\"92\":2,\"93\":8,\"95\":1,\"96\":8,\"198\":1,\"337\":1}}],[\"json所在的文件夹目录\",{\"1\":{\"23\":1}}],[\"json文件\",{\"1\":{\"23\":1,\"76\":1}}],[\"应用\",{\"1\":{\"423\":1}}],[\"应用程序试图加载类时\",{\"1\":{\"300\":1}}],[\"应用程序没有处于请求操作所要求的适当状态下\",{\"1\":{\"300\":1}}],[\"应用程序编程接口\",{\"1\":{\"133\":1}}],[\"应用程序服务器中间件\",{\"1\":{\"9\":1}}],[\"应当调用\",{\"1\":{\"413\":1}}],[\"应插入的位置\",{\"1\":{\"336\":1}}],[\"应该保证用\",{\"1\":{\"484\":1}}],[\"应该从哪些方面考虑\",{\"1\":{\"434\":1}}],[\"应该使用\",{\"1\":{\"402\":1}}],[\"应该都知道\",{\"1\":{\"399\":1}}],[\"应该了解的概念\",{\"0\":{\"350\":1}}],[\"应该在字段的规定范围内\",{\"1\":{\"188\":1}}],[\"应该会自动生成\",{\"1\":{\"27\":1}}],[\"yield\",{\"0\":{\"422\":1},\"1\":{\"398\":2,\"414\":1,\"422\":3}}],[\"your\",{\"1\":{\"324\":2}}],[\"yyyy\",{\"1\":{\"183\":4}}],[\"yxc\",{\"1\":{\"151\":2,\"156\":3,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"237\":1,\"260\":1,\"310\":3,\"318\":1}}],[\"yml\",{\"1\":{\"139\":1}}],[\"yml`文件\",{\"1\":{\"26\":1}}],[\"yaxis\",{\"1\":{\"103\":1,\"104\":2,\"107\":3}}],[\"yet\",{\"1\":{\"517\":1}}],[\"year\",{\"1\":{\"183\":1,\"239\":4,\"240\":4}}],[\"yellow\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"yes\",{\"1\":{\"22\":1,\"239\":2,\"240\":1,\"247\":1}}],[\"y\",{\"1\":{\"71\":1,\"104\":3,\"106\":2,\"107\":5,\"233\":1,\"235\":5,\"236\":1,\"244\":3,\"276\":2,\"282\":9,\"283\":2}}],[\"分配对象的内存空间\",{\"1\":{\"497\":1}}],[\"分配给各个线程的时间\",{\"1\":{\"348\":1}}],[\"分析中\",{\"1\":{\"498\":1}}],[\"分析完\",{\"1\":{\"468\":1}}],[\"分析并设计表结构\",{\"1\":{\"199\":1}}],[\"分代年龄和锁标记位\",{\"1\":{\"452\":1}}],[\"分发处理发送给给\",{\"1\":{\"413\":1}}],[\"分割成若干个\",{\"1\":{\"403\":1}}],[\"分割字符串\",{\"1\":{\"260\":1}}],[\"分段锁的思想\",{\"1\":{\"348\":1}}],[\"分别睡眠\",{\"1\":{\"508\":1}}],[\"分别保存了对应基本类型的最大值与最小值\",{\"1\":{\"338\":1}}],[\"分别关联两方主键\",{\"1\":{\"202\":1}}],[\"分子除以分母\",{\"1\":{\"234\":1}}],[\"分页操作在业务系统开发时\",{\"1\":{\"198\":1}}],[\"分页查询是数据库的方言\",{\"1\":{\"198\":1}}],[\"分页查询语法\",{\"1\":{\"198\":1}}],[\"分页查询\",{\"0\":{\"198\":1},\"1\":{\"192\":1}}],[\"分页参数\",{\"1\":{\"192\":1}}],[\"分组之后\",{\"1\":{\"196\":1}}],[\"分组后过滤条件\",{\"1\":{\"196\":1}}],[\"分组后条件列表\",{\"1\":{\"192\":1}}],[\"分组字段\",{\"1\":{\"197\":1}}],[\"分组字段名\",{\"1\":{\"196\":1}}],[\"分组字段列表\",{\"1\":{\"192\":1}}],[\"分组其实就是按列进行分类\",{\"1\":{\"196\":1}}],[\"分组\",{\"1\":{\"196\":1}}],[\"分组查询通常会使用聚合函数进行计算\",{\"1\":{\"196\":1}}],[\"分组查询\",{\"0\":{\"196\":1},\"1\":{\"192\":1}}],[\"分库分表等\",{\"1\":{\"173\":1}}],[\"分类\",{\"0\":{\"172\":1,\"206\":1},\"1\":{\"172\":1}}],[\"分支具体查看`\",{\"1\":{\"26\":1}}],[\"分支\",{\"1\":{\"26\":1,\"27\":1}}],[\"分布式计算中间件等\",{\"1\":{\"9\":1}}],[\"分布式应用软件借助这种软件在不同的技术之间共享资源\",{\"1\":{\"9\":1}}],[\"将节点插入到同步队列中\",{\"1\":{\"519\":1}}],[\"将节点状态由\",{\"1\":{\"517\":1}}],[\"将新值赋值给变量\",{\"1\":{\"494\":1}}],[\"将新的键值对插入到红黑树中\",{\"1\":{\"399\":1}}],[\"将工作内存同步到主内存中就需要执行\",{\"1\":{\"494\":1}}],[\"将计算后的值再赋值给变量a\",{\"1\":{\"494\":1}}],[\"将对象头中的\",{\"1\":{\"458\":1}}],[\"将对象头的偏向锁指向当前线程\",{\"1\":{\"454\":1}}],[\"将多线程执行变成串行化\",{\"1\":{\"407\":1}}],[\"将多维数组转化为字符串\",{\"1\":{\"257\":1}}],[\"将原数组中的元素复制到新数组中去\",{\"1\":{\"401\":1}}],[\"将会立即返回\",{\"1\":{\"385\":1}}],[\"将会报错\",{\"1\":{\"178\":1}}],[\"将头结点的状态更改为\",{\"1\":{\"379\":1}}],[\"将头结点从等待队列中移除\",{\"1\":{\"379\":1}}],[\"将该节点尾插入到同步队列中\",{\"1\":{\"379\":1}}],[\"将该节点移入到同步队列中去\",{\"1\":{\"379\":1}}],[\"将该线程从等待队列中转移到同步队列中\",{\"1\":{\"375\":1}}],[\"将该字符串对应的系统变量转换为integer\",{\"1\":{\"324\":1}}],[\"将该字段值置为\",{\"1\":{\"190\":1}}],[\"将同步状态减去读状态即可\",{\"1\":{\"370\":1}}],[\"将所有的值添加到给定的集合中\",{\"1\":{\"336\":1}}],[\"将所有元素的初值为0\",{\"1\":{\"255\":1}}],[\"将集合的所有元素设置为\",{\"1\":{\"336\":1}}],[\"将元素添加到队尾\",{\"1\":{\"332\":1}}],[\"将元素添加到队首\",{\"1\":{\"332\":1}}],[\"将元素e放在index位置\",{\"1\":{\"327\":1}}],[\"将关联映射中的值改为新值\",{\"1\":{\"329\":1}}],[\"将数组列表的存储容量削减到其当前大小\",{\"1\":{\"327\":1}}],[\"将数组转化为字符串\",{\"1\":{\"257\":1}}],[\"将已知编码的byte\",{\"1\":{\"324\":1}}],[\"将char\",{\"1\":{\"324\":1}}],[\"将字符串转换为char\",{\"1\":{\"324\":1}}],[\"将字符串转换为boolean类型\",{\"1\":{\"324\":1}}],[\"将字符串转换为int类型\",{\"1\":{\"324\":1}}],[\"将字符串转化成字符数组\",{\"1\":{\"260\":1}}],[\"将任意基本类型或引用类型转换为字符串\",{\"1\":{\"324\":1}}],[\"将线程设置为守护线程\",{\"1\":{\"315\":1}}],[\"将此\",{\"1\":{\"301\":1}}],[\"将第i个元素设置为val\",{\"1\":{\"291\":1}}],[\"将第一行全部变成0\",{\"1\":{\"255\":1}}],[\"将实参的引用\",{\"1\":{\"273\":1}}],[\"将实参的初始值拷贝给形参\",{\"1\":{\"272\":1}}],[\"将这个变量所在缓存行的数据写回到系统内存\",{\"1\":{\"466\":1}}],[\"将这\",{\"1\":{\"254\":2}}],[\"将得到\",{\"1\":{\"234\":5}}],[\"将其他的字段放在另外一张表当中\",{\"1\":{\"201\":1}}],[\"将其修改为当前操作时间\",{\"1\":{\"189\":1}}],[\"将大表中的一些基础字段放在一张表当中\",{\"1\":{\"201\":1}}],[\"将一列数据作为一个整体\",{\"1\":{\"195\":1}}],[\"将一个对象拆分成\",{\"1\":{\"134\":1}}],[\"将业务数据存储在云上\",{\"1\":{\"133\":1}}],[\"将\",{\"1\":{\"129\":1,\"139\":1,\"189\":1,\"249\":1,\"317\":2,\"391\":1,\"399\":1,\"413\":2,\"467\":1,\"470\":1,\"494\":1}}],[\"将具体数据固定在表格的右边\",{\"1\":{\"104\":1}}],[\"将错解传上来可以便捷地卡掉它们\",{\"1\":{\"54\":1}}],[\"将项目\",{\"1\":{\"49\":1}}],[\"将本地\",{\"1\":{\"26\":1}}],[\"将当前处理器缓存行的数据写回系统内存\",{\"1\":{\"466\":1}}],[\"将当前节点通过\",{\"1\":{\"517\":1}}],[\"将当前节点尾插入的方式插入同步队列中\",{\"1\":{\"516\":1}}],[\"将当前节点插入到等待对列之后\",{\"1\":{\"378\":1}}],[\"将当前节点包装成\",{\"1\":{\"378\":1}}],[\"将当前线程构建成node类型\",{\"1\":{\"516\":1}}],[\"将当前线程添加到等待队列中\",{\"1\":{\"378\":1}}],[\"将当前线程包装成node\",{\"1\":{\"378\":2}}],[\"将当前暂存区中的更改提交到本地\",{\"1\":{\"26\":1}}],[\"将当前目录下的所有更改\",{\"1\":{\"26\":1}}],[\"`lf`之类换行符的报错\",{\"1\":{\"26\":1}}],[\"准备进行下一次提交\",{\"1\":{\"26\":1}}],[\"other\",{\"1\":{\"523\":2}}],[\"otherwise\",{\"1\":{\"366\":1,\"369\":1,\"508\":2}}],[\"ok\",{\"1\":{\"518\":1}}],[\"our\",{\"1\":{\"508\":1}}],[\"outofmemoryerror\",{\"1\":{\"297\":1}}],[\"outer\",{\"1\":{\"208\":2}}],[\"out\",{\"1\":{\"141\":3,\"142\":6,\"235\":9,\"236\":1,\"237\":7,\"239\":30,\"240\":5,\"241\":1,\"243\":4,\"244\":2,\"245\":4,\"247\":2,\"248\":1,\"249\":3,\"254\":5,\"255\":2,\"256\":2,\"259\":5,\"260\":2,\"261\":2,\"262\":2,\"266\":1,\"269\":2,\"270\":3,\"272\":1,\"273\":2,\"275\":1,\"276\":1,\"277\":4,\"278\":1,\"284\":2,\"288\":3,\"289\":3,\"302\":3,\"303\":2,\"304\":2,\"310\":3,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"324\":2,\"349\":4,\"378\":1,\"381\":2,\"387\":1,\"413\":3,\"419\":2,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"479\":1,\"494\":1}}],[\"outputstreamwriter\",{\"1\":{\"237\":2}}],[\"output\",{\"1\":{\"75\":5,\"77\":2,\"304\":1}}],[\"oome\",{\"1\":{\"401\":1}}],[\"os\",{\"1\":{\"386\":2}}],[\"oss\",{\"1\":{\"133\":3}}],[\"owner\",{\"1\":{\"366\":2}}],[\"over\",{\"1\":{\"517\":1}}],[\"overflow\",{\"1\":{\"359\":1}}],[\"overload\",{\"1\":{\"307\":1}}],[\"override\",{\"1\":{\"307\":1,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"333\":1,\"349\":2,\"381\":2,\"413\":3,\"419\":2,\"420\":1,\"423\":1,\"441\":1,\"461\":1,\"470\":1,\"479\":1,\"494\":1}}],[\"oldval\",{\"1\":{\"399\":9}}],[\"oldvalue\",{\"1\":{\"336\":1}}],[\"oldregex\",{\"1\":{\"260\":1}}],[\"oldchar\",{\"1\":{\"260\":1,\"324\":1}}],[\"o\",{\"1\":{\"227\":1,\"310\":6,\"322\":1,\"324\":14,\"325\":4,\"327\":6,\"328\":4,\"329\":9,\"330\":6,\"331\":5,\"332\":6,\"333\":3,\"336\":1,\"393\":3,\"399\":1,\"449\":6}}],[\"onto\",{\"1\":{\"379\":1}}],[\"onlyifabsent\",{\"1\":{\"399\":5}}],[\"only\",{\"1\":{\"366\":1}}],[\"on\",{\"1\":{\"207\":1,\"208\":2,\"222\":2,\"370\":1,\"386\":2,\"516\":1,\"523\":1}}],[\"objectinputstream\",{\"1\":{\"508\":1}}],[\"objectname\",{\"1\":{\"142\":1}}],[\"objectwriteresponse2\",{\"1\":{\"142\":1}}],[\"objectwriteresponse\",{\"1\":{\"142\":5}}],[\"object\",{\"0\":{\"142\":1},\"1\":{\"86\":1,\"93\":1,\"133\":1,\"139\":3,\"142\":6,\"300\":1,\"310\":2,\"318\":14,\"349\":2,\"375\":9,\"377\":2,\"386\":10,\"400\":1,\"417\":2,\"421\":4,\"443\":3,\"481\":1,\"484\":1,\"508\":1}}],[\"operate\",{\"1\":{\"329\":2}}],[\"open\",{\"1\":{\"77\":1,\"86\":1,\"93\":1,\"226\":1}}],[\"opt\",{\"1\":{\"126\":4}}],[\"opts\",{\"1\":{\"102\":1,\"103\":3,\"104\":1,\"107\":6,\"111\":1,\"112\":1,\"115\":3,\"119\":1,\"121\":2}}],[\"opts=opts\",{\"1\":{\"102\":6,\"103\":4,\"104\":7,\"105\":3,\"106\":2,\"107\":22,\"111\":5,\"112\":3,\"113\":2,\"114\":2,\"115\":12,\"119\":2,\"121\":3}}],[\"options\",{\"1\":{\"85\":3,\"86\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"order\",{\"1\":{\"192\":2,\"197\":1}}],[\"org\",{\"1\":{\"125\":1,\"126\":1,\"132\":1,\"134\":1,\"310\":3,\"318\":1}}],[\"orient=\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"origin\",{\"1\":{\"26\":2}}],[\"orangered\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"or\",{\"1\":{\"76\":5,\"77\":5,\"194\":1,\"366\":2,\"369\":2,\"379\":1,\"402\":2,\"517\":1,\"518\":2}}],[\"oj\",{\"2\":{\"60\":1}}],[\"off\",{\"1\":{\"399\":1}}],[\"offerlast\",{\"1\":{\"332\":1}}],[\"offerfirst\",{\"1\":{\"332\":1}}],[\"offer\",{\"1\":{\"331\":1,\"333\":1}}],[\"of\",{\"1\":{\"23\":1,\"85\":2,\"86\":1,\"92\":2,\"93\":1,\"369\":1,\"377\":2,\"379\":1,\"397\":1,\"402\":5,\"516\":1,\"518\":1,\"523\":3}}],[\"仓库的pages\",{\"1\":{\"27\":1}}],[\"仓库中的更改推送到远程仓库\",{\"1\":{\"26\":1}}],[\"仓库\",{\"1\":{\"26\":2}}],[\"仓库地址是一个普通的形如\",{\"1\":{\"26\":1}}],[\"<k\",{\"1\":{\"395\":3}}],[\"<0x048c2d18>\",{\"1\":{\"386\":2}}],[\"<0x00000007d5ff53d8\",{\"1\":{\"349\":2}}],[\"<0x00000007d5ff53a8\",{\"1\":{\"349\":2}}],[\"<>\",{\"1\":{\"194\":1,\"213\":1}}],[\"<<\",{\"1\":{\"149\":1,\"366\":1,\"369\":1,\"395\":3,\"401\":6,\"402\":1}}],[\"<<abc\",{\"1\":{\"149\":1}}],[\"<<eof\",{\"1\":{\"149\":1}}],[\"<version>8\",{\"1\":{\"138\":1}}],[\"<groupid>io\",{\"1\":{\"138\":1}}],[\"<dependency>\",{\"1\":{\"138\":1}}],[\"<description>minio文件存储服务<\",{\"1\":{\"129\":1}}],[\"<zipdateformat>yyyymmdd<\",{\"1\":{\"129\":1}}],[\"<zipolderthannumdays>5<zipolderthannumdays>\",{\"1\":{\"129\":1}}],[\"<artifactid>minio<\",{\"1\":{\"138\":1}}],[\"<arguments>server\",{\"1\":{\"129\":1}}],[\"<autorollattime>00\",{\"1\":{\"129\":1}}],[\"<pattern>yyyymmdd<\",{\"1\":{\"129\":1}}],[\"<sizethreshold>10240<\",{\"1\":{\"129\":1}}],[\"<service>\",{\"1\":{\"129\":1}}],[\"<log\",{\"1\":{\"129\":1}}],[\"<logpath>\",{\"1\":{\"129\":1}}],[\"<\",{\"1\":{\"129\":3,\"138\":1,\"194\":1,\"239\":3,\"243\":2,\"244\":2,\"245\":3,\"247\":1,\"249\":3,\"254\":5,\"255\":3,\"260\":1,\"262\":1,\"273\":1,\"302\":2,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"324\":1,\"359\":1,\"360\":1,\"369\":1,\"377\":1,\"397\":2,\"398\":1,\"400\":1,\"401\":3,\"402\":6,\"441\":2,\"461\":2,\"494\":2,\"508\":1,\"518\":1,\"522\":1}}],[\"<executable>\",{\"1\":{\"129\":1}}],[\"<name>minio\",{\"1\":{\"129\":1}}],[\"<id>minio\",{\"1\":{\"129\":1}}],[\"<=\",{\"1\":{\"194\":1,\"239\":3,\"243\":1,\"245\":1,\"248\":1,\"249\":1,\"254\":1,\"265\":1,\"266\":1,\"278\":1,\"370\":2,\"401\":3,\"402\":2,\"420\":1,\"518\":1,\"520\":2}}],[\"<=kw=\",{\"1\":{\"91\":1,\"93\":1}}],[\"<=jl=\",{\"1\":{\"91\":1,\"93\":1}}],[\"<=city=\",{\"1\":{\"84\":1,\"86\":1}}],[\"<=query=\",{\"1\":{\"84\":1,\"86\":1}}],[\"<repo>\",{\"1\":{\"26\":2,\"27\":1}}],[\"<username>\",{\"1\":{\"26\":2,\"27\":1}}],[\"也会将当前线程插入同步队列等一系列的方法\",{\"1\":{\"508\":1}}],[\"也会被移除\",{\"1\":{\"324\":1}}],[\"也就说前面对\",{\"1\":{\"488\":1}}],[\"也就是必须已经获得对象锁\",{\"1\":{\"421\":1}}],[\"也就是调用这些方法后线程会进入\",{\"1\":{\"417\":1}}],[\"也就是为了保证内存可见性\",{\"1\":{\"394\":1}}],[\"也就是每次调用\",{\"1\":{\"379\":1}}],[\"也就是当前线程是同步队列中的头结点\",{\"1\":{\"378\":1}}],[\"也就是一个\",{\"1\":{\"377\":1}}],[\"也就是\",{\"1\":{\"377\":1,\"399\":1}}],[\"也就是在同一时刻只有一个线程能够获取锁\",{\"1\":{\"364\":1}}],[\"也就是理解了同步语义的第一条\",{\"1\":{\"359\":1}}],[\"也就是形成了多核\",{\"1\":{\"346\":1}}],[\"也就是将一张大表拆分成两张小表\",{\"1\":{\"201\":1}}],[\"也就是即使你启动了\",{\"1\":{\"126\":1}}],[\"也就是你package\",{\"1\":{\"23\":1}}],[\"也就是说该对象引用不能在构造函数中\",{\"1\":{\"490\":1}}],[\"也就是说当线程\",{\"1\":{\"467\":1}}],[\"也就是说不会将线程挂起\",{\"1\":{\"451\":1}}],[\"也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过\",{\"1\":{\"449\":1}}],[\"也就是说软件技术和硬件技术都为同一个目标而进行奋斗\",{\"1\":{\"430\":1}}],[\"也就是说可以正常执行一次打印\",{\"1\":{\"423\":1}}],[\"也就是说都有机会获得当前线程让出的时间片\",{\"1\":{\"422\":1}}],[\"也就是说在调用\",{\"1\":{\"419\":1}}],[\"也就是说数组的可用大小为\",{\"1\":{\"398\":1}}],[\"也就是说只能调用一次\",{\"1\":{\"385\":1}}],[\"也就是说摩尔定律的有效性超过了半个世纪戛然而止\",{\"1\":{\"346\":1}}],[\"也就是说\",{\"1\":{\"9\":1,\"221\":1,\"397\":1,\"432\":1,\"434\":1,\"485\":1,\"489\":1,\"494\":2,\"497\":1,\"513\":1}}],[\"也至于在并发编程中很多程序员遇到线程安全的问题就会使用\",{\"1\":{\"465\":1}}],[\"也省去了收银员跟你找零的时间了\",{\"1\":{\"446\":1}}],[\"也无需担心内存可见性问题\",{\"1\":{\"430\":1}}],[\"也实现了\",{\"1\":{\"413\":1}}],[\"也做一个反序处理\",{\"1\":{\"401\":1}}],[\"也免不了会出现拉链过长的情况\",{\"1\":{\"399\":1}}],[\"也对\",{\"1\":{\"378\":1}}],[\"也提供了同样的方法\",{\"1\":{\"375\":1}}],[\"也有一个很著名的\",{\"1\":{\"346\":1}}],[\"也有降序排序\",{\"1\":{\"197\":1}}],[\"也可能没有运行\",{\"1\":{\"414\":1}}],[\"也可为字符数组\",{\"1\":{\"324\":1}}],[\"也可以是任意同步组件\",{\"1\":{\"506\":1}}],[\"也可以是在不同线程之间\",{\"1\":{\"432\":1}}],[\"也可以支持共享式获取同步状态\",{\"1\":{\"506\":1}}],[\"也可以插入其他指令\",{\"1\":{\"494\":1}}],[\"也可以利用上面第二种方式\",{\"1\":{\"413\":1}}],[\"也可以理解成临界值\",{\"1\":{\"393\":1}}],[\"也可以通过\",{\"1\":{\"333\":1}}],[\"也可以作为栈\",{\"1\":{\"330\":1}}],[\"也可以调用静态函数\",{\"1\":{\"282\":1}}],[\"也可以调用函数本身\",{\"1\":{\"278\":1}}],[\"也可以格式化输出\",{\"1\":{\"261\":1}}],[\"也可以修改多个变量\",{\"1\":{\"245\":1}}],[\"也可以没有\",{\"1\":{\"189\":1,\"190\":1}}],[\"也可以替换成\",{\"1\":{\"178\":1}}],[\"也可以直接定义数组中某个元素的值\",{\"1\":{\"161\":1}}],[\"也可以不处理\",{\"1\":{\"299\":1}}],[\"也可以不用引号\",{\"1\":{\"156\":1}}],[\"也可以不加引号\",{\"1\":{\"151\":1}}],[\"也可以用双引号\",{\"1\":{\"156\":1}}],[\"也可以将一套逻辑组织成一个文件\",{\"1\":{\"146\":1}}],[\"也可以提醒自己需要卡掉它们\",{\"1\":{\"54\":1}}],[\"也可以选择后再点\",{\"1\":{\"49\":1}}],[\"也被称为元数据\",{\"1\":{\"306\":1}}],[\"也必须把两个类型都写出来\",{\"1\":{\"268\":1}}],[\"也称为散列表\",{\"1\":{\"226\":1}}],[\"也是大费周章才计算出来的\",{\"1\":{\"402\":1}}],[\"也是在实际编程中使用频率很高的一个锁\",{\"1\":{\"358\":1}}],[\"也是一名\",{\"1\":{\"346\":1}}],[\"也是非常常见的一个功能\",{\"1\":{\"198\":1}}],[\"也是不错的选择\",{\"1\":{\"44\":1}}],[\"也能通过剩余的数据块和校验块恢复原始数据\",{\"1\":{\"134\":1}}],[\"也能使用云存储服务提供的\",{\"1\":{\"133\":1}}],[\"也不需要进行额外的同步\",{\"1\":{\"427\":1}}],[\"也不需要互相传文件\",{\"1\":{\"44\":1}}],[\"也不要下载这个插件\",{\"1\":{\"23\":1}}],[\"的条件是前驱节点是头结点并且成功获得了同步状态\",{\"1\":{\"518\":1}}],[\"的过程\",{\"1\":{\"518\":1}}],[\"的过程中\",{\"1\":{\"403\":1}}],[\"的核心也包括了这些方面\",{\"1\":{\"512\":1}}],[\"的功能实际上别切分成各自的两部分\",{\"1\":{\"508\":1}}],[\"的更新也是利用了\",{\"1\":{\"508\":1}}],[\"的使用\",{\"1\":{\"508\":1}}],[\"的使命是为创建编程竞赛题目提供平台\",{\"1\":{\"44\":1}}],[\"的子类所重写的方法\",{\"1\":{\"508\":1}}],[\"的子类的方法时就会调用被重写的方法\",{\"1\":{\"507\":1}}],[\"的子类进行重写实现\",{\"1\":{\"507\":1}}],[\"的静态内部类\",{\"1\":{\"508\":1,\"513\":1}}],[\"的静态内存类\",{\"1\":{\"507\":1,\"508\":1}}],[\"的静态方法\",{\"1\":{\"419\":1,\"421\":2}}],[\"的理解\",{\"1\":{\"505\":1}}],[\"的形式如下\",{\"1\":{\"504\":1}}],[\"的这个值自然而然就是一个过期的值\",{\"1\":{\"494\":1}}],[\"的这种用法有点类似于我们用\",{\"1\":{\"275\":1}}],[\"的结果\",{\"1\":{\"494\":1}}],[\"的结合思考\",{\"0\":{\"380\":1}}],[\"的非原子性协定\",{\"1\":{\"494\":1}}],[\"的分析同理可得这两条语句不具备原子性\",{\"1\":{\"494\":1}}],[\"的感觉\",{\"1\":{\"494\":1}}],[\"的写入对线程\",{\"1\":{\"488\":1}}],[\"的普通域\",{\"1\":{\"487\":1}}],[\"的不可更改性\",{\"1\":{\"484\":1}}],[\"的不同值来代表不同含义\",{\"1\":{\"403\":1}}],[\"的例子\",{\"0\":{\"484\":1}}],[\"的属性改成\",{\"1\":{\"479\":1}}],[\"的具体使用场景\",{\"0\":{\"475\":1}}],[\"的具体底层实现\",{\"1\":{\"443\":1}}],[\"的变量进行写操作\",{\"1\":{\"466\":1}}],[\"的作者经过研究发现\",{\"1\":{\"453\":1}}],[\"的问题\",{\"0\":{\"451\":1}}],[\"的应用场景\",{\"0\":{\"450\":1}}],[\"的内存模型正好是共享内存的并发模型结构\",{\"1\":{\"445\":1}}],[\"的内存语义实现\",{\"0\":{\"469\":1}}],[\"的内存语义\",{\"0\":{\"468\":1},\"1\":{\"445\":1,\"468\":1,\"469\":1}}],[\"的内部类\",{\"1\":{\"377\":1}}],[\"的执行结果\",{\"1\":{\"445\":1}}],[\"的执行结果对线程\",{\"1\":{\"444\":1}}],[\"的执行结果对\",{\"1\":{\"444\":1,\"445\":1,\"467\":1}}],[\"的执行顺序\",{\"1\":{\"467\":1}}],[\"的执行顺序先于\",{\"1\":{\"444\":1,\"467\":1}}],[\"的执行顺序排在\",{\"1\":{\"432\":1}}],[\"的定义中的一条\",{\"1\":{\"444\":1}}],[\"的监视器占有者释放后\",{\"1\":{\"443\":1}}],[\"的监视器\",{\"1\":{\"443\":1}}],[\"的访问\",{\"1\":{\"443\":1}}],[\"的同级目录之后\",{\"1\":{\"443\":1}}],[\"的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程\",{\"1\":{\"378\":1}}],[\"的现象\",{\"1\":{\"437\":1}}],[\"的关键\",{\"1\":{\"506\":1}}],[\"的关键字和\",{\"1\":{\"435\":1}}],[\"的关系\",{\"0\":{\"436\":1},\"1\":{\"434\":1}}],[\"的设计是使用模板方法设计模式\",{\"1\":{\"507\":1}}],[\"的设计\",{\"0\":{\"435\":1},\"1\":{\"441\":1}}],[\"的设计方案\",{\"1\":{\"399\":1}}],[\"的概念来指定两个操作之间的执行顺序\",{\"1\":{\"432\":1}}],[\"的概念最初由\",{\"1\":{\"432\":1}}],[\"的编译器重排序规则会禁止一些特定类型的编译器重排序\",{\"1\":{\"430\":1}}],[\"的编排\",{\"1\":{\"134\":1}}],[\"的工作内存该变量值就会失效\",{\"1\":{\"470\":1}}],[\"的工作内存中去\",{\"1\":{\"445\":1}}],[\"的工作内存后并进行操作\",{\"1\":{\"429\":1}}],[\"的工作流\",{\"1\":{\"22\":1}}],[\"的处理速度和主存的读写速度不是一个量级的\",{\"1\":{\"429\":1}}],[\"的中断标志位清零\",{\"1\":{\"419\":1}}],[\"的节点\",{\"1\":{\"408\":1}}],[\"的节点的话\",{\"1\":{\"399\":1}}],[\"的两倍即\",{\"1\":{\"401\":1}}],[\"的位置上\",{\"1\":{\"401\":2}}],[\"的要求\",{\"1\":{\"401\":1}}],[\"的性能\",{\"1\":{\"399\":2}}],[\"的性能会持平甚至在某些情况更优\",{\"1\":{\"391\":1}}],[\"的性能会更高些\",{\"1\":{\"183\":1}}],[\"的解释在源码上也写的很清楚了\",{\"1\":{\"399\":1}}],[\"的低\",{\"1\":{\"399\":1}}],[\"的时候方法结束说明获得成功获取锁\",{\"1\":{\"522\":1}}],[\"的时候才会结束\",{\"1\":{\"420\":1}}],[\"的时候采用红黑树的设计\",{\"1\":{\"403\":1}}],[\"的时候摒弃了\",{\"1\":{\"403\":1}}],[\"的时候需要锁住\",{\"1\":{\"403\":1}}],[\"的时候\",{\"1\":{\"399\":1}}],[\"的时候会将链表转换成红黑树\",{\"1\":{\"399\":1}}],[\"的时候就会找到数据大概是\",{\"1\":{\"221\":1}}],[\"的大小总是\",{\"1\":{\"399\":1}}],[\"的大小为\",{\"1\":{\"397\":1}}],[\"的大小一定是\",{\"1\":{\"397\":1}}],[\"的大小\",{\"1\":{\"397\":1}}],[\"的大小应该就代表了\",{\"1\":{\"397\":1}}],[\"的大部分功能都不需要学\",{\"1\":{\"45\":1}}],[\"的说明请看上面的说明\",{\"1\":{\"397\":1}}],[\"的一些操作的原子性\",{\"1\":{\"403\":1}}],[\"的一些属性\",{\"1\":{\"393\":1}}],[\"的一个内部类无可厚非\",{\"1\":{\"377\":1}}],[\"的一个内部类\",{\"1\":{\"377\":1}}],[\"的幂次方特性\",{\"1\":{\"397\":1}}],[\"的幂次方数\",{\"1\":{\"397\":1}}],[\"的幂次方\",{\"1\":{\"393\":1,\"397\":1,\"399\":1}}],[\"的版本网上资料很多\",{\"1\":{\"391\":1}}],[\"的情况\",{\"1\":{\"391\":1,\"399\":1,\"497\":1}}],[\"的信息\",{\"1\":{\"386\":1}}],[\"的阻塞对象的重载方法\",{\"1\":{\"386\":1}}],[\"的线程\",{\"1\":{\"413\":1}}],[\"的线程都会与一个许可关联\",{\"1\":{\"385\":1}}],[\"的线程进入到等待队列\",{\"1\":{\"378\":1}}],[\"的底层实现\",{\"1\":{\"385\":1}}],[\"的底层实现时说过\",{\"1\":{\"378\":1}}],[\"的用法\",{\"1\":{\"381\":1}}],[\"的前提条件是当前线程已经获取了\",{\"1\":{\"379\":1}}],[\"的模板方法可以很方便的给同步组件的实现者进行调用\",{\"1\":{\"508\":1}}],[\"的模板方法设计模式\",{\"0\":{\"507\":1}}],[\"的模板方法\",{\"1\":{\"378\":1,\"508\":1}}],[\"的方式入队\",{\"1\":{\"516\":1}}],[\"的方式时\",{\"1\":{\"507\":1}}],[\"的方式被推荐定义继承\",{\"1\":{\"507\":1}}],[\"的方式进行加锁以实现线程安全性\",{\"1\":{\"399\":1}}],[\"的方式\",{\"1\":{\"399\":1,\"507\":1}}],[\"的方式实际上是指在对象\",{\"1\":{\"377\":1}}],[\"的方法实现自己想要表达的同步语义\",{\"1\":{\"508\":1}}],[\"的方法将线程设置为守护线程\",{\"1\":{\"423\":1}}],[\"的方法\",{\"1\":{\"417\":1,\"520\":1}}],[\"的方法前我们需要了解下面几个常用的利用\",{\"1\":{\"395\":1}}],[\"的方法去修改\",{\"1\":{\"393\":1}}],[\"的方法是同步的\",{\"1\":{\"330\":1}}],[\"的实现依赖于同步器\",{\"1\":{\"507\":1}}],[\"的实现原理\",{\"0\":{\"489\":1}}],[\"的实现原理又依赖于\",{\"1\":{\"377\":1}}],[\"的实现\",{\"1\":{\"484\":1}}],[\"的实现需要硬件指令集的支撑\",{\"1\":{\"449\":1}}],[\"的实现对比\",{\"1\":{\"403\":1}}],[\"的实现中可以看到大量的\",{\"1\":{\"393\":1}}],[\"的实现类有\",{\"1\":{\"330\":1}}],[\"的原因正是我们在上面说的\",{\"1\":{\"369\":1}}],[\"的互斥性时可以按照\",{\"1\":{\"364\":1}}],[\"的逻辑判断\",{\"1\":{\"360\":1}}],[\"的逻辑空间\",{\"1\":{\"139\":1}}],[\"的构造方法无参时是构造非公平锁\",{\"1\":{\"360\":1}}],[\"的几个方法\",{\"1\":{\"375\":1}}],[\"的几个\",{\"0\":{\"409\":1},\"1\":{\"359\":1,\"506\":1}}],[\"的话才会执行\",{\"1\":{\"518\":1}}],[\"的话就\",{\"1\":{\"508\":1}}],[\"的话就可以直接将值插入即可\",{\"1\":{\"399\":1}}],[\"的话说明当前节点\",{\"1\":{\"399\":1}}],[\"的话表示\",{\"1\":{\"393\":1}}],[\"的话\",{\"1\":{\"358\":1,\"378\":1,\"399\":2}}],[\"的系统中\",{\"1\":{\"352\":1}}],[\"的计算能力\",{\"1\":{\"346\":1}}],[\"的计划\",{\"1\":{\"346\":1}}],[\"的背景下\",{\"1\":{\"346\":1}}],[\"的发展为并发编程提供的硬件基础\",{\"1\":{\"346\":1}}],[\"的元素\",{\"1\":{\"333\":1,\"395\":2}}],[\"的元素个数\",{\"1\":{\"221\":1,\"402\":1}}],[\"的特性\",{\"1\":{\"330\":1}}],[\"的包装类型\",{\"1\":{\"329\":1}}],[\"的简短描述\",{\"1\":{\"301\":1}}],[\"的区别\",{\"0\":{\"297\":1}}],[\"的函数不要求非得有\",{\"1\":{\"275\":1}}],[\"的函数中\",{\"1\":{\"275\":1}}],[\"的ascii值为32\",{\"1\":{\"267\":1}}],[\"的矩阵中\",{\"1\":{\"249\":1}}],[\"的数据容器\",{\"1\":{\"393\":1,\"397\":1}}],[\"的数据列是一个正数序列开始增长\",{\"1\":{\"182\":1}}],[\"的数组\",{\"1\":{\"393\":1}}],[\"的数字\",{\"1\":{\"259\":1}}],[\"的数是否是质数\",{\"1\":{\"247\":1}}],[\"的运算\",{\"1\":{\"235\":1}}],[\"的运行环境\",{\"1\":{\"29\":1,\"64\":1}}],[\"的高度\",{\"1\":{\"221\":1}}],[\"的顺序保存的\",{\"1\":{\"221\":1}}],[\"的效率\",{\"1\":{\"220\":1}}],[\"的事务是自动提交\",{\"1\":{\"217\":1}}],[\"的任何一个\",{\"1\":{\"210\":1}}],[\"的所有数据\",{\"1\":{\"208\":2}}],[\"的所有组合情况\",{\"1\":{\"205\":1}}],[\"的行\",{\"1\":{\"195\":1}}],[\"的员工\",{\"1\":{\"189\":1}}],[\"的值然后将该变量拷贝到自己的本地内存\",{\"1\":{\"445\":1}}],[\"的值为\",{\"1\":{\"444\":1}}],[\"的值\",{\"1\":{\"183\":2,\"265\":1,\"402\":1,\"445\":1,\"494\":2}}],[\"的签名url\",{\"1\":{\"142\":1}}],[\"的状态\",{\"1\":{\"142\":1,\"417\":1}}],[\"的常用\",{\"0\":{\"140\":1}}],[\"的操作过程\",{\"0\":{\"449\":1}}],[\"的操作归根结底是由该类提供就好\",{\"1\":{\"409\":1}}],[\"的操作\",{\"1\":{\"139\":1,\"337\":1}}],[\"的基本对象\",{\"1\":{\"139\":1}}],[\"的存储机制使用纠删码\",{\"1\":{\"134\":1}}],[\"的产品\",{\"1\":{\"134\":1}}],[\"的替代品\",{\"1\":{\"134\":1}}],[\"的最后一个\",{\"1\":{\"85\":1,\"92\":1}}],[\"的安装教程\",{\"1\":{\"70\":1}}],[\"的地方\",{\"1\":{\"56\":1}}],[\"的\",{\"0\":{\"374\":1,\"444\":1,\"467\":1},\"1\":{\"55\":1,\"169\":1,\"337\":1,\"367\":1,\"369\":1,\"375\":5,\"378\":2,\"379\":4,\"386\":1,\"391\":3,\"395\":1,\"397\":1,\"399\":5,\"401\":2,\"402\":1,\"409\":1,\"423\":1,\"435\":1,\"444\":1,\"445\":1,\"467\":1,\"481\":1,\"484\":1,\"487\":1,\"494\":1,\"507\":2,\"508\":1,\"515\":1,\"519\":1}}],[\"的其它代码的\",{\"1\":{\"48\":1}}],[\"的语法\",{\"1\":{\"47\":1}}],[\"的源码为\",{\"1\":{\"378\":1,\"379\":1}}],[\"的源码\",{\"1\":{\"377\":1}}],[\"的源\",{\"1\":{\"27\":1}}],[\"的格式\",{\"1\":{\"26\":1}}],[\"的仓库\",{\"1\":{\"26\":1}}],[\"的报错是正常的\",{\"1\":{\"23\":1}}],[\"ignore\",{\"1\":{\"402\":1}}],[\"i+n\",{\"1\":{\"401\":2}}],[\"i++\",{\"1\":{\"377\":1,\"420\":1,\"437\":1,\"441\":2,\"461\":2,\"494\":2,\"508\":1}}],[\"ie\",{\"1\":{\"378\":1}}],[\"i7\",{\"1\":{\"346\":1}}],[\"imin\",{\"1\":{\"338\":1}}],[\"imax\",{\"1\":{\"338\":1}}],[\"implementation\",{\"1\":{\"399\":1}}],[\"implements\",{\"1\":{\"288\":1,\"289\":1,\"314\":2,\"317\":1,\"381\":2,\"394\":1,\"441\":1,\"461\":1,\"505\":1,\"508\":1}}],[\"import\",{\"1\":{\"77\":4,\"86\":3,\"93\":4,\"96\":3,\"107\":6,\"115\":5,\"121\":3,\"236\":3,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"254\":3,\"256\":1,\"259\":2,\"261\":1,\"269\":1,\"273\":1,\"276\":1,\"277\":1,\"278\":1,\"281\":1,\"302\":1,\"303\":2,\"304\":1,\"310\":4,\"316\":1}}],[\"illegalaccessexception\",{\"1\":{\"300\":1,\"310\":1}}],[\"illegalargumentexception\",{\"1\":{\"300\":1,\"397\":1}}],[\"illegalthreadstateexception\",{\"1\":{\"300\":1,\"423\":1}}],[\"illegalstateexception\",{\"1\":{\"300\":1}}],[\"illegalmonitorstateexception\",{\"1\":{\"300\":1,\"359\":1,\"367\":1,\"378\":1,\"379\":1,\"508\":1}}],[\"it\",{\"1\":{\"366\":2,\"369\":1,\"370\":1,\"508\":1,\"517\":3,\"518\":1,\"523\":2}}],[\"itcast数据库存在时删除\",{\"1\":{\"178\":1}}],[\"itcast\",{\"1\":{\"178\":2}}],[\"iterable<result<item>>\",{\"1\":{\"142\":1}}],[\"iterrows\",{\"1\":{\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"118\":1,\"121\":1}}],[\"itemoffset\",{\"1\":{\"409\":1}}],[\"itemresult\",{\"1\":{\"142\":2}}],[\"itemstyleopts\",{\"1\":{\"112\":1,\"115\":1}}],[\"itemstyle\",{\"1\":{\"112\":1,\"115\":1}}],[\"item\",{\"1\":{\"96\":3,\"142\":3,\"408\":4}}],[\"item中\",{\"1\":{\"96\":1}}],[\"id=1\",{\"1\":{\"189\":1}}],[\"id\",{\"1\":{\"182\":1,\"189\":1,\"205\":2,\"454\":1}}],[\"id>\",{\"1\":{\"129\":1}}],[\"ide\",{\"1\":{\"68\":2}}],[\"i\",{\"1\":{\"91\":1,\"93\":1,\"96\":2,\"243\":13,\"245\":17,\"247\":4,\"248\":5,\"249\":9,\"254\":29,\"255\":8,\"260\":5,\"262\":5,\"265\":4,\"266\":4,\"273\":5,\"291\":2,\"302\":9,\"314\":9,\"316\":3,\"317\":6,\"318\":4,\"377\":2,\"395\":9,\"399\":17,\"400\":2,\"401\":22,\"402\":3,\"420\":2,\"423\":5,\"441\":4,\"444\":1,\"461\":4,\"467\":1,\"494\":4,\"508\":2,\"518\":1}}],[\"icon\",{\"1\":{\"85\":1}}],[\"if\",{\"0\":{\"239\":1},\"1\":{\"76\":6,\"77\":9,\"84\":1,\"85\":2,\"86\":6,\"91\":2,\"92\":2,\"93\":7,\"101\":1,\"102\":2,\"107\":4,\"111\":1,\"112\":1,\"115\":4,\"118\":1,\"121\":1,\"141\":1,\"176\":3,\"178\":3,\"186\":2,\"239\":24,\"240\":4,\"243\":2,\"247\":3,\"248\":2,\"249\":2,\"254\":1,\"275\":1,\"276\":1,\"277\":2,\"278\":1,\"303\":1,\"318\":1,\"329\":1,\"359\":6,\"360\":4,\"366\":10,\"367\":2,\"369\":10,\"370\":7,\"371\":2,\"378\":14,\"379\":7,\"397\":1,\"398\":5,\"399\":27,\"400\":5,\"401\":20,\"402\":11,\"430\":6,\"432\":5,\"467\":1,\"488\":1,\"490\":1,\"497\":3,\"507\":1,\"508\":3,\"515\":1,\"516\":10,\"517\":2,\"518\":11,\"519\":5,\"520\":9,\"522\":6,\"523\":12}}],[\"ioexception\",{\"1\":{\"299\":1,\"303\":5,\"304\":2,\"508\":1}}],[\"ios\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"io\",{\"0\":{\"529\":1},\"1\":{\"27\":1,\"48\":1,\"50\":1,\"128\":1,\"132\":1,\"220\":1,\"221\":3,\"236\":2,\"237\":2,\"303\":1,\"304\":1,\"505\":1,\"508\":1}}],[\"islocked\",{\"1\":{\"508\":1}}],[\"isalive\",{\"1\":{\"420\":2}}],[\"isinterrupted\",{\"1\":{\"419\":11}}],[\"isover\",{\"1\":{\"470\":6}}],[\"isonsyncqueue\",{\"1\":{\"378\":3}}],[\"isolation\",{\"1\":{\"218\":2}}],[\"isheldexclusively\",{\"1\":{\"367\":1,\"379\":1,\"508\":2}}],[\"isblank\",{\"1\":{\"324\":1}}],[\"isbucketexists\",{\"1\":{\"141\":4}}],[\"isempty\",{\"1\":{\"291\":1,\"293\":1,\"294\":1,\"295\":1,\"324\":1,\"328\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1}}],[\"isprime\",{\"1\":{\"247\":3,\"249\":3}}],[\"issue\",{\"1\":{\"44\":1,\"56\":1}}],[\"is\",{\"1\":{\"23\":1,\"102\":4,\"103\":2,\"104\":4,\"106\":3,\"107\":13,\"111\":3,\"112\":2,\"114\":3,\"115\":8,\"120\":1,\"121\":1,\"194\":1,\"239\":5,\"260\":3,\"266\":1,\"324\":2,\"349\":2,\"366\":4,\"369\":2,\"378\":1,\"379\":1,\"402\":2,\"484\":1,\"508\":1,\"518\":5,\"523\":2}}],[\"invoke\",{\"1\":{\"310\":1}}],[\"invocationtargetexception\",{\"1\":{\"310\":2}}],[\"inverse=true\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"inherited\",{\"1\":{\"308\":1}}],[\"innodb\",{\"1\":{\"221\":1}}],[\"inner\",{\"1\":{\"207\":1}}],[\"instead\",{\"1\":{\"402\":1}}],[\"instancce\",{\"1\":{\"466\":1}}],[\"instance是volatile变量\",{\"1\":{\"466\":1}}],[\"instance\",{\"1\":{\"466\":1,\"497\":9}}],[\"instanceof\",{\"1\":{\"399\":3,\"401\":1}}],[\"instantiationexception\",{\"1\":{\"300\":1,\"310\":1}}],[\"installation\",{\"1\":{\"67\":1}}],[\"installed\",{\"1\":{\"23\":1}}],[\"install\",{\"1\":{\"23\":1,\"67\":1,\"99\":2,\"129\":1}}],[\"insertions\",{\"1\":{\"402\":1}}],[\"insert\",{\"0\":{\"188\":1},\"1\":{\"187\":1,\"188\":6,\"210\":1,\"220\":1}}],[\"increment\",{\"1\":{\"182\":3,\"394\":1}}],[\"include\",{\"1\":{\"48\":1}}],[\"includegraphics\",{\"1\":{\"47\":1}}],[\"indicate\",{\"1\":{\"379\":1,\"517\":2}}],[\"industryname\",{\"1\":{\"92\":1,\"93\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"299\":1,\"300\":1}}],[\"indexofsublist\",{\"1\":{\"336\":1}}],[\"indexof\",{\"1\":{\"260\":2,\"324\":2}}],[\"index=false\",{\"1\":{\"75\":1}}],[\"index\",{\"1\":{\"44\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"118\":1,\"121\":1,\"133\":1,\"162\":1,\"220\":1,\"222\":3,\"324\":4,\"325\":1,\"327\":4}}],[\"inputstreamreader\",{\"1\":{\"236\":2}}],[\"input\",{\"1\":{\"86\":2,\"93\":2,\"304\":1}}],[\"int会被隐式转化成字符串\",{\"1\":{\"260\":1}}],[\"into\",{\"1\":{\"188\":4}}],[\"intel\",{\"1\":{\"346\":3}}],[\"integer>\",{\"1\":{\"329\":4}}],[\"integer\",{\"1\":{\"183\":1,\"329\":1,\"338\":2,\"401\":1,\"402\":2}}],[\"internal\",{\"1\":{\"402\":1,\"508\":1}}],[\"interruptdemo\",{\"1\":{\"419\":1}}],[\"interruptmode\",{\"1\":{\"378\":7}}],[\"interrupted\",{\"0\":{\"419\":1},\"1\":{\"378\":5,\"419\":1,\"433\":1,\"516\":3,\"517\":2,\"519\":1,\"520\":2,\"522\":3}}],[\"interruptedexception\",{\"1\":{\"300\":1,\"314\":3,\"316\":1,\"317\":2,\"318\":2,\"349\":1,\"375\":3,\"377\":1,\"378\":2,\"381\":1,\"387\":1,\"413\":1,\"419\":4,\"420\":2,\"423\":2,\"441\":1,\"461\":1,\"470\":1,\"494\":1,\"505\":2,\"508\":3,\"519\":4,\"520\":4}}],[\"interrupt\",{\"1\":{\"315\":1,\"419\":3}}],[\"interface\",{\"1\":{\"285\":1,\"286\":1,\"287\":1}}],[\"interval=5000\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"interactive\",{\"1\":{\"50\":1}}],[\"interactor\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1}}],[\"int\",{\"1\":{\"76\":2,\"77\":5,\"183\":1,\"233\":6,\"235\":5,\"236\":1,\"237\":1,\"239\":9,\"240\":2,\"241\":1,\"243\":6,\"244\":2,\"245\":9,\"247\":2,\"248\":2,\"249\":4,\"252\":2,\"253\":3,\"254\":18,\"255\":8,\"256\":3,\"257\":2,\"259\":4,\"260\":3,\"262\":1,\"265\":4,\"266\":5,\"268\":5,\"269\":2,\"270\":2,\"272\":2,\"273\":4,\"275\":3,\"276\":4,\"277\":4,\"278\":3,\"282\":8,\"283\":2,\"286\":1,\"288\":1,\"289\":1,\"302\":6,\"303\":1,\"310\":7,\"314\":3,\"316\":2,\"317\":4,\"318\":1,\"324\":6,\"325\":1,\"327\":7,\"333\":1,\"359\":5,\"360\":3,\"366\":10,\"367\":3,\"369\":4,\"370\":4,\"375\":1,\"377\":1,\"378\":5,\"379\":1,\"393\":1,\"394\":5,\"395\":3,\"397\":9,\"398\":2,\"399\":6,\"400\":2,\"401\":11,\"402\":9,\"420\":2,\"422\":1,\"441\":3,\"444\":2,\"461\":3,\"467\":2,\"479\":4,\"487\":4,\"488\":3,\"490\":2,\"494\":5,\"506\":1,\"507\":3,\"508\":3,\"512\":8,\"513\":6,\"515\":1,\"516\":1,\"517\":1,\"518\":2,\"519\":2,\"520\":2,\"522\":3,\"523\":2}}],[\"in\",{\"1\":{\"47\":2,\"52\":1,\"75\":1,\"76\":12,\"77\":17,\"84\":2,\"85\":3,\"86\":5,\"91\":2,\"92\":4,\"93\":6,\"95\":1,\"96\":2,\"101\":2,\"102\":4,\"104\":2,\"106\":1,\"107\":9,\"111\":3,\"112\":3,\"114\":1,\"115\":9,\"118\":4,\"121\":5,\"194\":1,\"212\":2,\"213\":2,\"236\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"254\":3,\"261\":1,\"276\":1,\"278\":1,\"302\":1,\"303\":1,\"304\":1,\"329\":2,\"369\":1,\"379\":1,\"394\":1,\"423\":1,\"508\":1,\"518\":2,\"523\":3}}],[\"information\",{\"1\":{\"349\":1}}],[\"info\",{\"0\":{\"46\":1},\"1\":{\"50\":1,\"77\":16,\"96\":2}}],[\"initiating\",{\"1\":{\"401\":1}}],[\"initialize\",{\"1\":{\"516\":1}}],[\"initialization\",{\"1\":{\"398\":1}}],[\"initial\",{\"1\":{\"513\":1,\"517\":1}}],[\"initialcapacity\",{\"1\":{\"327\":1,\"397\":8}}],[\"inittable\",{\"0\":{\"398\":1},\"1\":{\"398\":1,\"399\":2}}],[\"initopts\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1}}],[\"init\",{\"1\":{\"22\":1,\"26\":1,\"86\":1,\"93\":1,\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1,\"245\":3}}],[\"✖\",{\"1\":{\"23\":1}}],[\"^\",{\"1\":{\"84\":2,\"86\":2,\"91\":2,\"93\":2,\"399\":1}}],[\"^2\",{\"1\":{\"23\":1}}],[\"^3\",{\"1\":{\"23\":1}}],[\"8h20min\",{\"1\":{\"520\":1}}],[\"8h30min\",{\"1\":{\"520\":1}}],[\"8h10min+10min=8h20min\",{\"1\":{\"520\":1}}],[\"8h10min\",{\"1\":{\"520\":1}}],[\"8的不同实现\",{\"1\":{\"403\":1}}],[\"8转换\",{\"1\":{\"324\":1}}],[\"8编码转换\",{\"1\":{\"324\":2}}],[\"85\",{\"1\":{\"239\":1}}],[\"8+6\",{\"1\":{\"221\":1}}],[\"838\",{\"1\":{\"183\":2}}],[\"8388607\",{\"1\":{\"183\":1}}],[\"8388608\",{\"1\":{\"183\":1}}],[\"8bytes\",{\"1\":{\"183\":2}}],[\"82\",{\"1\":{\"112\":1,\"115\":1}}],[\"800ms\",{\"1\":{\"423\":1}}],[\"800\",{\"1\":{\"423\":1}}],[\"80\",{\"1\":{\"112\":1,\"115\":1,\"324\":1}}],[\"8751\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"8\",{\"0\":{\"219\":1,\"220\":1,\"221\":1,\"222\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"304\":1},\"1\":{\"23\":1,\"76\":1,\"77\":2,\"86\":1,\"93\":1,\"183\":1,\"221\":1,\"233\":2,\"245\":1,\"255\":1,\"256\":1,\"324\":3,\"337\":1,\"346\":2,\"377\":1,\"391\":2,\"397\":1,\"399\":8,\"402\":1,\"403\":5,\"420\":1,\"494\":1,\"508\":1}}],[\"l2或其他\",{\"1\":{\"466\":1}}],[\"l1\",{\"1\":{\"466\":1}}],[\"lc\",{\"1\":{\"401\":3}}],[\"ln\",{\"1\":{\"401\":8}}],[\"lmbench3\",{\"1\":{\"348\":1}}],[\"lmin\",{\"1\":{\"338\":1}}],[\"lmax\",{\"1\":{\"338\":1}}],[\"looksupport\",{\"1\":{\"517\":2,\"518\":2}}],[\"loop\",{\"1\":{\"369\":1,\"523\":4}}],[\"lotail\",{\"1\":{\"401\":4}}],[\"lo\",{\"1\":{\"401\":4}}],[\"lost\",{\"1\":{\"398\":1}}],[\"lockinterruptibly\",{\"1\":{\"505\":1,\"508\":1,\"519\":1}}],[\"locking\",{\"1\":{\"497\":1}}],[\"locked\",{\"1\":{\"349\":2,\"402\":1,\"508\":1}}],[\"lockstate\",{\"1\":{\"394\":2}}],[\"locksupprt\",{\"1\":{\"386\":1}}],[\"locksupprot\",{\"1\":{\"385\":1}}],[\"locksupportdemo\",{\"1\":{\"386\":4,\"387\":1}}],[\"locksupport方法介绍\",{\"0\":{\"386\":1}}],[\"locksupport\",{\"0\":{\"384\":1,\"385\":1},\"1\":{\"378\":4,\"379\":2,\"385\":5,\"386\":7,\"387\":5,\"417\":4,\"517\":1,\"518\":1,\"520\":2}}],[\"locks\",{\"1\":{\"316\":1,\"370\":1,\"385\":1,\"386\":2,\"417\":1}}],[\"lock\",{\"0\":{\"502\":1,\"504\":1,\"505\":1},\"1\":{\"316\":5,\"349\":5,\"358\":1,\"359\":1,\"360\":1,\"364\":2,\"366\":2,\"369\":2,\"370\":1,\"371\":8,\"375\":4,\"377\":10,\"378\":8,\"379\":4,\"380\":7,\"381\":8,\"394\":3,\"399\":1,\"417\":3,\"450\":1,\"466\":5,\"494\":4,\"498\":1,\"503\":1,\"504\":9,\"505\":3,\"507\":1,\"508\":6,\"515\":2,\"519\":2,\"520\":1}}],[\"localhost\",{\"1\":{\"128\":1,\"139\":1}}],[\"longadder\",{\"1\":{\"402\":1}}],[\"long\",{\"1\":{\"198\":1,\"233\":1,\"338\":2,\"375\":5,\"386\":4,\"395\":3,\"402\":13,\"417\":3,\"420\":2,\"421\":1,\"494\":1,\"505\":1,\"508\":1,\"512\":2,\"520\":3}}],[\"longtext\",{\"1\":{\"183\":1}}],[\"longblob\",{\"1\":{\"183\":1}}],[\"log10\",{\"1\":{\"335\":1}}],[\"logn\",{\"1\":{\"322\":1,\"333\":2,\"336\":1}}],[\"log>\",{\"1\":{\"129\":1}}],[\"logpath>\",{\"1\":{\"129\":1}}],[\"logs<\",{\"1\":{\"129\":1}}],[\"log\",{\"1\":{\"126\":4,\"335\":3}}],[\"low\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"load\",{\"1\":{\"494\":7}}],[\"loadload屏障也会被省略掉\",{\"1\":{\"489\":1}}],[\"loadload\",{\"1\":{\"469\":2,\"487\":1,\"489\":1}}],[\"loadfactor\",{\"1\":{\"393\":1,\"397\":2}}],[\"loadstore\",{\"1\":{\"469\":2}}],[\"loads\",{\"1\":{\"96\":1}}],[\"loader\",{\"1\":{\"23\":1}}],[\"lea\",{\"1\":{\"503\":1}}],[\"learn\",{\"1\":{\"349\":2,\"386\":2,\"423\":1}}],[\"leslie\",{\"1\":{\"432\":1}}],[\"legendopts\",{\"1\":{\"112\":1,\"115\":1}}],[\"legend\",{\"1\":{\"112\":1,\"115\":1}}],[\"left\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"208\":1,\"394\":1}}],[\"left=\",{\"1\":{\"102\":2,\"103\":1,\"104\":1,\"105\":2,\"106\":1,\"107\":7,\"111\":2,\"114\":1,\"115\":3,\"120\":1,\"121\":1}}],[\"length\",{\"1\":{\"142\":1,\"260\":2,\"262\":1,\"273\":1,\"322\":1,\"324\":1,\"325\":1,\"398\":2,\"399\":1,\"400\":1,\"401\":2,\"402\":3}}],[\"len\",{\"1\":{\"76\":3,\"77\":3}}],[\"lamport\",{\"1\":{\"432\":1}}],[\"lazysetnext\",{\"1\":{\"409\":1}}],[\"lang\",{\"1\":{\"310\":8,\"349\":8,\"386\":4,\"423\":2}}],[\"language\",{\"1\":{\"172\":4,\"174\":1,\"187\":1}}],[\"labelopts\",{\"1\":{\"103\":1,\"104\":3,\"106\":1,\"107\":5,\"114\":1,\"115\":1}}],[\"label\",{\"1\":{\"103\":1,\"104\":1,\"106\":1,\"107\":3,\"114\":1,\"115\":1}}],[\"lastrun\",{\"1\":{\"401\":5}}],[\"lastwaiter\",{\"1\":{\"377\":1,\"378\":5,\"379\":2}}],[\"lastindexofsublist\",{\"1\":{\"336\":1}}],[\"lastindexof\",{\"1\":{\"260\":2,\"324\":2}}],[\"last\",{\"1\":{\"85\":2,\"86\":1,\"92\":2,\"93\":1,\"328\":1,\"377\":1}}],[\"later稍后重启系统\",{\"1\":{\"70\":1}}],[\"latex\",{\"1\":{\"47\":1}}],[\"like\",{\"1\":{\"194\":1,\"221\":1}}],[\"limit\",{\"1\":{\"192\":2,\"198\":3}}],[\"light\",{\"1\":{\"121\":1}}],[\"lightskyblue\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"link\",{\"1\":{\"402\":1}}],[\"links\",{\"1\":{\"394\":1}}],[\"linkedhashset\",{\"1\":{\"328\":2}}],[\"linkedlist\",{\"1\":{\"327\":2,\"330\":1,\"331\":1}}],[\"linkedlist<>\",{\"1\":{\"291\":1,\"293\":1,\"327\":1,\"331\":1,\"332\":1}}],[\"line\",{\"1\":{\"103\":2,\"105\":1,\"107\":4,\"115\":1,\"236\":1,\"304\":5}}],[\"linux\",{\"0\":{\"126\":1,\"531\":1},\"1\":{\"2\":1,\"126\":1,\"146\":2},\"2\":{\"165\":1}}],[\"listed\",{\"1\":{\"349\":1}}],[\"listen\",{\"1\":{\"85\":2,\"86\":2,\"92\":2,\"93\":2}}],[\"list2\",{\"1\":{\"336\":2}}],[\"list1\",{\"1\":{\"336\":2}}],[\"list<t>\",{\"1\":{\"407\":1}}],[\"list<integer>\",{\"1\":{\"327\":2}}],[\"list<e>\",{\"1\":{\"327\":2,\"328\":1,\"336\":4}}],[\"list<>\",{\"1\":{\"291\":1}}],[\"list<bucket>\",{\"1\":{\"141\":1}}],[\"listobjectsargs\",{\"1\":{\"142\":1}}],[\"listobjects\",{\"1\":{\"142\":4}}],[\"listbuckets\",{\"1\":{\"141\":2}}],[\"list\",{\"0\":{\"291\":1,\"327\":1},\"1\":{\"92\":1,\"93\":1,\"101\":2,\"103\":1,\"106\":1,\"107\":4,\"114\":1,\"115\":3,\"198\":3,\"327\":3,\"328\":2,\"331\":1,\"407\":1}}],[\"lib\",{\"1\":{\"23\":1}}],[\"license\",{\"1\":{\"23\":1,\"132\":1}}],[\"know\",{\"1\":{\"523\":1}}],[\"keys\",{\"1\":{\"329\":1}}],[\"keyset\",{\"1\":{\"329\":2}}],[\"key\",{\"1\":{\"182\":2,\"200\":5,\"221\":7,\"226\":1,\"294\":2,\"295\":6,\"329\":7,\"391\":2,\"394\":4,\"399\":20,\"400\":9,\"401\":2}}],[\"keywordtype\",{\"1\":{\"95\":1}}],[\"keywordtype=\",{\"1\":{\"95\":1,\"96\":1}}],[\"keyword=java\",{\"1\":{\"95\":1,\"96\":1}}],[\"keyword=keyword\",{\"1\":{\"75\":2,\"86\":1,\"93\":1}}],[\"keyword\",{\"1\":{\"75\":6,\"77\":7,\"84\":1,\"86\":9,\"91\":1,\"93\":9,\"95\":1,\"101\":6,\"107\":6,\"115\":6,\"118\":3,\"121\":5}}],[\"keywords\",{\"1\":{\"75\":2,\"77\":2,\"121\":2}}],[\"ksh\",{\"1\":{\"146\":1}}],[\"k8s\",{\"1\":{\"134\":1}}],[\"kw=招聘岗位\",{\"1\":{\"88\":1}}],[\"kw=python\",{\"1\":{\"88\":1,\"93\":1}}],[\"k\",{\"1\":{\"76\":3,\"77\":2,\"146\":1,\"249\":3,\"302\":2,\"329\":5,\"391\":1,\"394\":1,\"397\":1,\"399\":3,\"400\":1,\"401\":1}}],[\"kotlin\",{\"1\":{\"23\":1}}],[\"katex\",{\"1\":{\"23\":2}}],[\"5n=1\",{\"1\":{\"401\":1}}],[\"5n\",{\"1\":{\"401\":3}}],[\"57\",{\"1\":{\"259\":1}}],[\"59\",{\"1\":{\"183\":6,\"324\":1}}],[\"535\",{\"1\":{\"183\":2}}],[\"58\",{\"1\":{\"105\":1,\"107\":1}}],[\"500\",{\"1\":{\"423\":1,\"441\":1,\"461\":1,\"470\":1}}],[\"5000\",{\"1\":{\"101\":1,\"107\":1}}],[\"50\",{\"1\":{\"105\":2,\"107\":2,\"183\":1}}],[\"51jobcdn\",{\"1\":{\"95\":1}}],[\"51job\",{\"1\":{\"95\":1,\"96\":1}}],[\"56\",{\"1\":{\"23\":1,\"235\":1}}],[\"54\",{\"1\":{\"23\":4}}],[\"5\",{\"0\":{\"35\":1,\"155\":1,\"196\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"214\":1,\"237\":1,\"249\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1,\"269\":1,\"278\":1,\"295\":1,\"301\":1,\"401\":1,\"417\":1,\"431\":1,\"432\":1,\"433\":1,\"460\":1,\"469\":1,\"489\":1},\"1\":{\"23\":2,\"103\":1,\"105\":1,\"106\":2,\"107\":4,\"114\":2,\"115\":2,\"138\":1,\"156\":1,\"233\":1,\"235\":2,\"237\":1,\"239\":4,\"241\":1,\"245\":1,\"254\":1,\"255\":1,\"256\":1,\"266\":2,\"272\":1,\"273\":1,\"302\":3,\"318\":2,\"324\":1,\"378\":1,\"386\":2,\"397\":3,\"399\":2,\"401\":1,\"420\":1,\"422\":1,\"444\":3,\"445\":2,\"449\":1,\"451\":1,\"487\":1,\"488\":1}}],[\"3s\",{\"1\":{\"508\":1}}],[\"34\",{\"1\":{\"349\":1}}],[\"32\",{\"1\":{\"267\":1,\"452\":1}}],[\"32767\",{\"1\":{\"183\":1}}],[\"32768\",{\"1\":{\"183\":1}}],[\"33\",{\"1\":{\"252\":1}}],[\"3306\",{\"1\":{\"169\":1}}],[\"31\",{\"1\":{\"183\":2}}],[\"38\",{\"1\":{\"183\":1}}],[\"3bytes\",{\"1\":{\"183\":1}}],[\"35\",{\"1\":{\"112\":1,\"115\":1}}],[\"35025\",{\"1\":{\"34\":1}}],[\"304\",{\"1\":{\"386\":1}}],[\"3000\",{\"1\":{\"349\":1,\"387\":1,\"508\":1}}],[\"308\",{\"1\":{\"183\":1}}],[\"30\",{\"1\":{\"23\":1,\"76\":2,\"77\":2,\"102\":1,\"107\":1,\"111\":1,\"115\":1,\"234\":1,\"255\":1}}],[\"3\",{\"0\":{\"33\":1,\"71\":1,\"94\":1,\"117\":1,\"153\":1,\"157\":1,\"158\":1,\"159\":1,\"163\":1,\"177\":1,\"183\":1,\"185\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":2,\"194\":1,\"202\":1,\"207\":1,\"208\":1,\"212\":1,\"218\":1,\"222\":1,\"235\":1,\"241\":1,\"243\":1,\"244\":1,\"245\":2,\"246\":1,\"247\":1,\"248\":1,\"249\":1,\"254\":1,\"256\":1,\"257\":1,\"261\":1,\"267\":1,\"274\":1,\"275\":1,\"276\":1,\"283\":1,\"288\":1,\"293\":1,\"299\":1,\"317\":1,\"318\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":2,\"354\":1,\"360\":1,\"368\":1,\"369\":1,\"370\":1,\"379\":1,\"380\":1,\"387\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":1,\"399\":2,\"400\":1,\"401\":1,\"402\":1,\"415\":1,\"421\":1,\"429\":1,\"437\":1,\"445\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":1,\"450\":2,\"451\":1,\"452\":1,\"453\":2,\"454\":2,\"455\":2,\"456\":3,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"467\":1,\"483\":1,\"484\":1,\"498\":1,\"507\":1,\"508\":1,\"514\":1,\"515\":1,\"516\":1,\"517\":1,\"518\":1,\"519\":2,\"520\":1,\"524\":1},\"1\":{\"23\":5,\"112\":1,\"115\":1,\"142\":1,\"158\":2,\"161\":1,\"162\":1,\"171\":1,\"183\":5,\"221\":1,\"233\":2,\"235\":3,\"237\":1,\"239\":1,\"240\":1,\"241\":1,\"243\":1,\"245\":2,\"253\":1,\"255\":3,\"256\":1,\"269\":1,\"270\":1,\"273\":1,\"275\":1,\"277\":2,\"284\":1,\"306\":1,\"307\":1,\"308\":1,\"310\":2,\"359\":2,\"366\":5,\"367\":1,\"369\":2,\"378\":2,\"386\":1,\"387\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":3,\"398\":1,\"399\":2,\"400\":1,\"401\":3,\"403\":1,\"413\":2,\"420\":1,\"430\":3,\"444\":1,\"467\":3,\"487\":1,\"488\":3,\"490\":1,\"494\":2,\"497\":2,\"507\":1,\"513\":1,\"520\":10}}],[\"ws\",{\"1\":{\"379\":3,\"517\":5,\"518\":3,\"523\":3}}],[\"wrong\",{\"1\":{\"379\":1}}],[\"wrt\",{\"1\":{\"369\":1}}],[\"write操作\",{\"1\":{\"494\":1}}],[\"write操作使用\",{\"1\":{\"494\":1}}],[\"writelock\",{\"1\":{\"364\":3,\"371\":2}}],[\"write\",{\"1\":{\"237\":1,\"304\":1,\"366\":1,\"369\":1,\"370\":1,\"371\":4,\"394\":2,\"494\":2}}],[\"writeheader\",{\"1\":{\"77\":1,\"86\":1,\"93\":1}}],[\"writertwo\",{\"1\":{\"488\":2}}],[\"writerone\",{\"1\":{\"488\":1}}],[\"writerow\",{\"1\":{\"77\":1,\"85\":1,\"86\":1,\"92\":1,\"93\":1}}],[\"writers\",{\"1\":{\"370\":1}}],[\"writershouldblock\",{\"1\":{\"366\":1}}],[\"writer\",{\"1\":{\"77\":3,\"85\":1,\"86\":3,\"92\":1,\"93\":3,\"394\":1,\"444\":1,\"467\":2,\"468\":1,\"487\":3,\"490\":2,\"494\":1}}],[\"would\",{\"1\":{\"366\":1}}],[\"world\",{\"1\":{\"146\":5,\"148\":1,\"237\":2,\"260\":4,\"262\":1,\"269\":1,\"273\":1,\"402\":1}}],[\"word\",{\"1\":{\"119\":1,\"121\":1,\"452\":5,\"454\":2,\"455\":1,\"458\":3,\"459\":1}}],[\"words\",{\"1\":{\"118\":1,\"119\":1,\"121\":2}}],[\"words=\",{\"1\":{\"118\":1,\"121\":1}}],[\"wordcloud\",{\"1\":{\"23\":1,\"119\":1,\"121\":2}}],[\"worker2\",{\"1\":{\"314\":5,\"316\":3,\"317\":6}}],[\"worker1\",{\"1\":{\"314\":5,\"316\":3,\"317\":6}}],[\"worker\",{\"1\":{\"314\":5,\"316\":6,\"317\":13,\"318\":12}}],[\"work=y\",{\"1\":{\"106\":1,\"107\":1}}],[\"work\",{\"1\":{\"101\":7,\"102\":3,\"103\":1,\"104\":2,\"106\":2,\"107\":17,\"111\":4,\"112\":3,\"113\":3,\"114\":4,\"115\":21,\"317\":2,\"508\":1}}],[\"workingexp\",{\"1\":{\"92\":1,\"93\":1}}],[\"workcity\",{\"1\":{\"92\":1,\"93\":1}}],[\"workflows\",{\"1\":{\"26\":1}}],[\"whether\",{\"1\":{\"508\":1}}],[\"when\",{\"1\":{\"394\":1,\"399\":1,\"402\":2}}],[\"where\",{\"1\":{\"189\":2,\"190\":1,\"192\":2,\"194\":1,\"196\":6,\"197\":1,\"205\":1,\"207\":1,\"210\":2}}],[\"which\",{\"1\":{\"349\":2,\"369\":1,\"379\":1,\"518\":1}}],[\"while中transferforsignal方法对头结点做真正的处理\",{\"1\":{\"379\":1}}],[\"while语句与\",{\"1\":{\"244\":1}}],[\"while\",{\"0\":{\"243\":1,\"244\":1},\"1\":{\"243\":5,\"244\":5,\"245\":1,\"304\":1,\"378\":10,\"379\":2,\"381\":1,\"394\":1,\"398\":1,\"400\":1,\"401\":1,\"402\":1,\"419\":3,\"420\":2,\"423\":2,\"470\":1,\"517\":1,\"523\":1}}],[\"wget\",{\"1\":{\"126\":1}}],[\"will\",{\"1\":{\"517\":1}}],[\"wirterone\",{\"1\":{\"488\":1}}],[\"wirtelock\",{\"1\":{\"364\":1}}],[\"with\",{\"0\":{\"304\":1},\"1\":{\"304\":1,\"329\":2,\"369\":1,\"401\":1}}],[\"winsw\",{\"1\":{\"129\":4}}],[\"windows\",{\"0\":{\"128\":1,\"129\":1},\"1\":{\"128\":2,\"129\":3}}],[\"width=1\",{\"1\":{\"112\":1,\"115\":1}}],[\"width=\",{\"1\":{\"106\":2,\"107\":2,\"114\":2,\"115\":2,\"120\":1,\"121\":2}}],[\"wikis\",{\"1\":{\"41\":1}}],[\"wednesday\",{\"1\":{\"241\":1}}],[\"we\",{\"1\":{\"95\":1,\"96\":1,\"329\":2,\"371\":1,\"508\":1,\"517\":1,\"523\":3}}],[\"welfarelist\",{\"1\":{\"85\":1,\"86\":1}}],[\"web\",{\"1\":{\"82\":1,\"86\":1,\"128\":1}}],[\"web前端\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"webpack\",{\"1\":{\"23\":1}}],[\"web中间件\",{\"1\":{\"9\":1}}],[\"www\",{\"1\":{\"82\":1,\"84\":1,\"86\":2,\"88\":1,\"93\":1,\"125\":1,\"134\":1}}],[\"w\",{\"1\":{\"76\":3,\"77\":3,\"86\":1,\"93\":1,\"366\":4}}],[\"way\",{\"1\":{\"523\":1}}],[\"was\",{\"1\":{\"517\":1}}],[\"wake\",{\"1\":{\"379\":1}}],[\"walkthrough\",{\"1\":{\"366\":1,\"369\":1}}],[\"waline\",{\"1\":{\"23\":1}}],[\"waiter\",{\"1\":{\"381\":8,\"394\":2}}],[\"waitstatus\",{\"1\":{\"378\":2,\"379\":5,\"513\":1,\"517\":3,\"518\":4,\"523\":1}}],[\"waiting\",{\"1\":{\"349\":4,\"370\":1,\"379\":1,\"386\":5,\"394\":1,\"412\":2,\"417\":6,\"518\":1}}],[\"wait\",{\"0\":{\"318\":1},\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"318\":1,\"375\":6,\"386\":2,\"417\":2,\"420\":1,\"421\":6,\"508\":1}}],[\"wapi\",{\"1\":{\"84\":1,\"86\":1}}],[\"want\",{\"1\":{\"70\":1,\"329\":2}}],[\"wa\",{\"1\":{\"57\":1}}],[\"fwd\",{\"1\":{\"401\":4}}],[\"fh\",{\"1\":{\"399\":8,\"401\":6}}],[\"fmin\",{\"1\":{\"338\":1}}],[\"fmax\",{\"1\":{\"338\":1}}],[\"f2\",{\"1\":{\"270\":2,\"273\":2}}],[\"f4\",{\"1\":{\"268\":1}}],[\"f3\",{\"1\":{\"268\":1,\"270\":2}}],[\"f1\",{\"1\":{\"268\":1,\"270\":2,\"273\":2}}],[\"f输出\",{\"1\":{\"237\":1}}],[\"futuretask\",{\"1\":{\"413\":1}}],[\"future\",{\"1\":{\"413\":2}}],[\"future<string>\",{\"1\":{\"413\":1}}],[\"fulladdcount\",{\"1\":{\"402\":1}}],[\"fullyrelease\",{\"1\":{\"378\":5}}],[\"fulltryacquireshared\",{\"1\":{\"369\":2}}],[\"full\",{\"1\":{\"221\":1,\"369\":2,\"516\":1}}],[\"function\",{\"1\":{\"102\":1,\"107\":1}}],[\"fast\",{\"1\":{\"516\":1}}],[\"failure\",{\"1\":{\"516\":1}}],[\"failed\",{\"1\":{\"378\":3,\"516\":3,\"517\":1,\"519\":3,\"520\":3,\"522\":3,\"523\":1}}],[\"fails\",{\"1\":{\"369\":2,\"379\":1,\"518\":1,\"523\":1}}],[\"fail\",{\"1\":{\"366\":2,\"369\":1}}],[\"fairsync\",{\"1\":{\"360\":1}}],[\"fair\",{\"1\":{\"360\":2}}],[\"fact\",{\"1\":{\"265\":3,\"266\":2,\"267\":4}}],[\"family=\",{\"1\":{\"119\":1,\"121\":1}}],[\"false\",{\"1\":{\"76\":1,\"77\":2,\"233\":1,\"247\":1,\"249\":1,\"318\":1,\"359\":3,\"360\":2,\"366\":2,\"378\":4,\"379\":1,\"381\":1,\"401\":4,\"419\":3,\"420\":1,\"456\":1,\"467\":1,\"470\":1,\"508\":7,\"512\":1,\"516\":3,\"517\":3,\"518\":1,\"519\":1,\"520\":5,\"522\":2,\"523\":1}}],[\"fff\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"found\",{\"1\":{\"349\":1,\"527\":1}}],[\"foo\",{\"1\":{\"302\":2,\"303\":2}}],[\"font\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1,\"119\":1,\"121\":1}}],[\"forward\",{\"1\":{\"508\":1}}],[\"forwardnode\",{\"1\":{\"401\":1}}],[\"forwarding\",{\"1\":{\"399\":1}}],[\"forwardingnode<k\",{\"1\":{\"394\":1,\"401\":2}}],[\"forwardingnode\",{\"1\":{\"394\":3,\"399\":3}}],[\"for循环退出\",{\"1\":{\"401\":1}}],[\"forname\",{\"1\":{\"310\":1}}],[\"formatted\",{\"1\":{\"324\":2}}],[\"formatter=jscode\",{\"1\":{\"102\":1,\"107\":1}}],[\"formatter=\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"107\":3,\"111\":1,\"112\":1,\"115\":2}}],[\"format\",{\"1\":{\"260\":1,\"282\":1,\"283\":1,\"324\":2}}],[\"foreign\",{\"1\":{\"182\":1,\"200\":5}}],[\"foreach\",{\"1\":{\"141\":1,\"142\":1}}],[\"for\",{\"0\":{\"245\":1},\"1\":{\"68\":1,\"75\":1,\"76\":1,\"77\":4,\"84\":2,\"85\":2,\"86\":4,\"91\":2,\"92\":3,\"93\":5,\"96\":2,\"101\":1,\"102\":3,\"104\":2,\"106\":1,\"107\":7,\"111\":3,\"112\":3,\"114\":1,\"115\":8,\"118\":3,\"121\":4,\"245\":5,\"247\":1,\"248\":1,\"249\":4,\"254\":7,\"255\":3,\"256\":2,\"260\":2,\"262\":1,\"265\":1,\"266\":1,\"273\":1,\"289\":1,\"302\":2,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"329\":5,\"349\":1,\"366\":1,\"369\":2,\"370\":1,\"377\":1,\"386\":2,\"394\":4,\"397\":1,\"399\":5,\"401\":4,\"402\":3,\"420\":1,\"441\":2,\"461\":2,\"484\":1,\"494\":2,\"508\":1,\"516\":4,\"517\":1,\"518\":1,\"519\":1,\"520\":1,\"522\":1,\"523\":1}}],[\"featuretask\",{\"1\":{\"413\":2}}],[\"fe\",{\"1\":{\"91\":1,\"93\":1}}],[\"feed\",{\"1\":{\"23\":1}}],[\"f\",{\"1\":{\"75\":4,\"77\":4,\"85\":1,\"86\":11,\"92\":1,\"93\":11,\"101\":1,\"107\":1,\"115\":1,\"118\":1,\"121\":1,\"237\":2,\"243\":4,\"245\":4,\"252\":1,\"254\":7,\"272\":2,\"399\":18,\"401\":10}}],[\"flag\",{\"1\":{\"381\":3,\"467\":4,\"468\":1}}],[\"flush\",{\"1\":{\"237\":1,\"304\":1}}],[\"floorentry\",{\"1\":{\"295\":1}}],[\"floor\",{\"1\":{\"294\":1,\"335\":1}}],[\"float与double都用\",{\"1\":{\"237\":1}}],[\"float\",{\"1\":{\"76\":2,\"77\":2,\"183\":1,\"233\":1,\"236\":1,\"237\":1,\"252\":2,\"338\":2,\"397\":2}}],[\"flowchart\",{\"1\":{\"23\":1}}],[\"fl\",{\"1\":{\"55\":2}}],[\"free\",{\"1\":{\"359\":3,\"367\":3,\"370\":1}}],[\"freemarker\",{\"1\":{\"52\":1}}],[\"friday\",{\"1\":{\"241\":1}}],[\"from\",{\"1\":{\"77\":1,\"86\":1,\"93\":1,\"96\":2,\"107\":4,\"115\":3,\"121\":2,\"190\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"205\":4,\"207\":2,\"208\":2,\"210\":3,\"222\":1,\"402\":1,\"518\":1}}],[\"frontmatter\",{\"1\":{\"1\":1}}],[\"finnaly\",{\"1\":{\"423\":2}}],[\"finishing\",{\"1\":{\"401\":4}}],[\"find\",{\"1\":{\"400\":1,\"518\":1}}],[\"finalreferenceescapedemo\",{\"1\":{\"490\":4}}],[\"finalreferencedemo\",{\"1\":{\"488\":8}}],[\"final域\",{\"1\":{\"487\":1}}],[\"finaldemo\",{\"1\":{\"487\":14}}],[\"finalexampleparent\",{\"1\":{\"481\":1,\"482\":1,\"483\":1}}],[\"finalexample\",{\"1\":{\"479\":1,\"481\":1}}],[\"finalize\",{\"1\":{\"413\":1,\"433\":2}}],[\"final\",{\"0\":{\"473\":1,\"474\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":2,\"484\":1,\"485\":1,\"486\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1},\"1\":{\"233\":1,\"288\":1,\"289\":1,\"316\":1,\"317\":1,\"318\":2,\"359\":3,\"360\":2,\"366\":2,\"367\":1,\"369\":1,\"370\":1,\"378\":3,\"379\":2,\"394\":9,\"395\":3,\"397\":1,\"398\":1,\"399\":3,\"401\":1,\"402\":3,\"419\":1,\"420\":3,\"474\":2,\"477\":1,\"478\":5,\"479\":9,\"481\":6,\"482\":5,\"483\":5,\"484\":6,\"485\":1,\"487\":22,\"488\":18,\"489\":6,\"490\":5,\"507\":2,\"508\":1,\"515\":1,\"516\":4,\"517\":1,\"518\":1,\"519\":3,\"520\":4,\"522\":3,\"523\":1}}],[\"finally\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"302\":1,\"316\":1,\"371\":2,\"377\":1,\"378\":1,\"381\":2,\"398\":1,\"423\":6,\"504\":2,\"508\":1,\"516\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"fifo\",{\"1\":{\"360\":1,\"379\":1,\"506\":1,\"518\":1}}],[\"firstwaiter\",{\"1\":{\"377\":2,\"378\":3,\"379\":4}}],[\"firstreaderholdcount++\",{\"1\":{\"369\":1}}],[\"firstreaderholdcount\",{\"1\":{\"369\":1,\"370\":3}}],[\"firstreader\",{\"1\":{\"369\":2,\"370\":2}}],[\"first\",{\"1\":{\"328\":1,\"337\":1,\"377\":1,\"379\":14,\"394\":1,\"401\":1}}],[\"field\",{\"1\":{\"310\":6}}],[\"fieldnames=\",{\"1\":{\"77\":1,\"86\":1,\"93\":1}}],[\"fib\",{\"1\":{\"278\":4}}],[\"fillinstacktrace\",{\"1\":{\"301\":1}}],[\"fill\",{\"1\":{\"257\":1,\"336\":1}}],[\"filewriter\",{\"1\":{\"304\":1}}],[\"filereader\",{\"1\":{\"304\":1}}],[\"fileoutputstream\",{\"1\":{\"142\":1}}],[\"fileinputstream\",{\"1\":{\"142\":1}}],[\"file\",{\"1\":{\"75\":5,\"77\":4,\"86\":2,\"93\":2,\"101\":2,\"107\":2,\"115\":2,\"118\":2,\"121\":2,\"142\":5}}],[\"file2\",{\"1\":{\"75\":4}}],[\"file1\",{\"1\":{\"75\":4}}],[\"filename\",{\"1\":{\"47\":1,\"142\":1}}],[\"files\",{\"0\":{\"54\":1},\"1\":{\"47\":1,\"48\":2}}],[\"fix\",{\"1\":{\"44\":1}}],[\"hc\",{\"1\":{\"401\":3}}],[\"hn\",{\"1\":{\"401\":8}}],[\"hitail\",{\"1\":{\"401\":4}}],[\"hi\",{\"1\":{\"288\":1,\"289\":1,\"324\":2,\"401\":4}}],[\"high\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"h数据库服务器的ip地址\",{\"1\":{\"169\":1}}],[\"hh\",{\"1\":{\"156\":4,\"183\":3}}],[\"hdfs\",{\"1\":{\"134\":1}}],[\"hard\",{\"1\":{\"508\":1}}],[\"harmlessly\",{\"1\":{\"379\":1}}],[\"hackers\",{\"1\":{\"397\":1}}],[\"have\",{\"1\":{\"371\":1}}],[\"having\",{\"1\":{\"192\":1,\"196\":5,\"369\":1}}],[\"happens\",{\"0\":{\"426\":1,\"431\":1,\"432\":1,\"436\":1,\"444\":1,\"467\":1},\"1\":{\"432\":16,\"433\":14,\"434\":1,\"435\":4,\"436\":2,\"441\":1,\"444\":12,\"445\":3,\"467\":9,\"468\":1}}],[\"happen\",{\"1\":{\"366\":1,\"467\":1}}],[\"hasqueuedthreads\",{\"1\":{\"508\":2}}],[\"hasqueuedpredecessors\",{\"1\":{\"360\":2}}],[\"hasdcode\",{\"1\":{\"452\":1}}],[\"has\",{\"1\":{\"370\":1,\"379\":1,\"517\":1}}],[\"hashentry\",{\"1\":{\"391\":1}}],[\"hashtable\",{\"1\":{\"391\":1}}],[\"hashcode\",{\"1\":{\"337\":1,\"399\":4,\"400\":1,\"452\":1,\"481\":2,\"484\":2}}],[\"hashmap<>\",{\"1\":{\"329\":4}}],[\"hashmap<k\",{\"1\":{\"295\":1}}],[\"hashmap\",{\"1\":{\"329\":2,\"391\":4,\"399\":1,\"401\":1,\"407\":1}}],[\"hashset\",{\"1\":{\"328\":2}}],[\"hashset<>\",{\"1\":{\"328\":2}}],[\"hashset<integer>\",{\"1\":{\"327\":1}}],[\"hashset<k>\",{\"1\":{\"294\":1}}],[\"hash\",{\"1\":{\"221\":1,\"226\":1,\"394\":2,\"399\":34,\"400\":4,\"401\":4}}],[\"hasattr\",{\"1\":{\"86\":1,\"93\":1}}],[\"hadoop\",{\"1\":{\"134\":1}}],[\"hao\",{\"1\":{\"134\":1}}],[\"hup\",{\"1\":{\"126\":1}}],[\"height\",{\"1\":{\"479\":5}}],[\"height=\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1,\"479\":1}}],[\"head\",{\"1\":{\"408\":4,\"516\":3,\"517\":1,\"518\":2,\"519\":1,\"520\":1,\"522\":1,\"523\":4}}],[\"heros\",{\"1\":{\"289\":2}}],[\"hero\",{\"1\":{\"287\":1,\"288\":1,\"289\":5}}],[\"help\",{\"1\":{\"516\":1,\"517\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"helptransfer\",{\"1\":{\"399\":1}}],[\"helper\",{\"1\":{\"23\":1,\"508\":1}}],[\"held\",{\"1\":{\"349\":2,\"369\":1,\"518\":1}}],[\"hello\",{\"1\":{\"146\":5,\"148\":1,\"156\":5,\"237\":2,\"260\":4,\"262\":1,\"267\":1,\"269\":1,\"273\":1,\"314\":3,\"324\":5}}],[\"h\",{\"1\":{\"49\":2,\"169\":1,\"399\":3,\"400\":5,\"401\":3,\"518\":4,\"523\":8}}],[\"http\",{\"1\":{\"128\":1,\"132\":1,\"133\":1,\"139\":1}}],[\"https\",{\"1\":{\"26\":2,\"27\":1,\"49\":1,\"82\":1,\"84\":1,\"86\":2,\"88\":1,\"91\":1,\"93\":2,\"95\":2,\"96\":1,\"125\":3,\"126\":1,\"128\":1,\"129\":1,\"132\":1,\"133\":1,\"134\":4}}],[\"html\",{\"0\":{\"100\":1,\"109\":1,\"117\":1},\"1\":{\"47\":2,\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"hotspot\",{\"1\":{\"409\":1,\"453\":1}}],[\"holding\",{\"1\":{\"394\":1}}],[\"holdcounter\",{\"1\":{\"369\":1,\"370\":1}}],[\"hold\",{\"1\":{\"369\":1,\"371\":1}}],[\"hope\",{\"1\":{\"15\":1,\"21\":1,\"22\":3,\"23\":4},\"2\":{\"24\":1}}],[\"home\",{\"1\":{\"1\":1,\"34\":4,\"146\":1}}],[\"rs\",{\"1\":{\"402\":5}}],[\"rwl\",{\"1\":{\"371\":6}}],[\"rh\",{\"1\":{\"369\":7,\"370\":6}}],[\"rgba\",{\"1\":{\"112\":1,\"115\":1}}],[\"race\",{\"1\":{\"398\":1}}],[\"random\",{\"1\":{\"335\":1}}],[\"range=\",{\"1\":{\"119\":1,\"121\":1}}],[\"range\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"102\":2,\"107\":2,\"111\":2,\"115\":2,\"401\":1}}],[\"radius=\",{\"1\":{\"112\":1,\"115\":1}}],[\"right=\",{\"1\":{\"105\":2,\"106\":1,\"107\":3,\"114\":1,\"115\":1}}],[\"right\",{\"1\":{\"85\":1,\"104\":1,\"107\":1,\"208\":1,\"394\":1}}],[\"round\",{\"1\":{\"335\":1}}],[\"role\",{\"1\":{\"286\":1,\"287\":1}}],[\"rollback\",{\"1\":{\"217\":1}}],[\"roll\",{\"1\":{\"129\":1}}],[\"root\",{\"1\":{\"126\":4,\"394\":1}}],[\"rows\",{\"1\":{\"198\":1}}],[\"row\",{\"1\":{\"77\":6,\"101\":5,\"107\":5,\"115\":5,\"118\":2,\"121\":2,\"256\":2}}],[\"roaming\",{\"1\":{\"34\":1}}],[\"r\",{\"1\":{\"71\":1,\"76\":2,\"77\":2,\"84\":2,\"86\":2,\"91\":2,\"93\":2,\"153\":1,\"324\":1,\"336\":2,\"369\":3,\"430\":3,\"522\":3}}],[\"rj\",{\"1\":{\"55\":1}}],[\"runable\",{\"1\":{\"412\":1,\"413\":4,\"417\":3}}],[\"runbit\",{\"1\":{\"401\":4}}],[\"runnable\",{\"1\":{\"314\":3,\"317\":1,\"349\":2,\"381\":2,\"413\":4,\"423\":1,\"441\":1,\"461\":1,\"470\":1,\"494\":1}}],[\"runtimeexception\",{\"1\":{\"142\":1,\"299\":2,\"314\":3,\"318\":1}}],[\"runtime\",{\"1\":{\"430\":2},\"2\":{\"37\":1}}],[\"run\",{\"1\":{\"23\":1,\"26\":1,\"49\":1,\"75\":2,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"127\":1,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"349\":6,\"381\":2,\"413\":7,\"416\":2,\"419\":3,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"470\":1,\"494\":1}}],[\"reports\",{\"1\":{\"508\":1}}],[\"reportinterruptafterwait\",{\"1\":{\"378\":2}}],[\"represented\",{\"1\":{\"402\":1}}],[\"replaceall\",{\"1\":{\"336\":1}}],[\"replace\",{\"1\":{\"75\":6,\"77\":3,\"86\":6,\"93\":6,\"118\":3,\"121\":3,\"260\":2,\"324\":1}}],[\"repl\",{\"1\":{\"23\":1}}],[\"reinterrupt\",{\"1\":{\"378\":1}}],[\"rechecking\",{\"1\":{\"523\":1}}],[\"recheck\",{\"1\":{\"371\":1,\"401\":1,\"523\":1}}],[\"releasing\",{\"1\":{\"370\":1,\"371\":1}}],[\"releaseshared\",{\"0\":{\"523\":1},\"1\":{\"512\":1,\"523\":2}}],[\"releases\",{\"1\":{\"129\":1,\"359\":2,\"367\":3,\"508\":3,\"523\":1}}],[\"release\",{\"0\":{\"518\":1},\"1\":{\"126\":1,\"128\":1,\"371\":1,\"378\":2,\"508\":1,\"512\":1,\"517\":1,\"518\":1,\"523\":2}}],[\"reentreadwritelocks\",{\"1\":{\"385\":1}}],[\"reentrantwritereadlock源码中\",{\"1\":{\"371\":1}}],[\"reentrant\",{\"1\":{\"366\":2,\"369\":2}}],[\"reentrantreadwritelock\",{\"0\":{\"363\":1},\"1\":{\"364\":1}}],[\"reentrantlock\",{\"0\":{\"357\":1},\"1\":{\"316\":3,\"358\":4,\"359\":2,\"360\":5,\"364\":1,\"367\":1,\"381\":2,\"385\":1,\"391\":3,\"403\":1,\"504\":1,\"505\":4,\"507\":1}}],[\"reed\",{\"1\":{\"134\":1}}],[\"referencedemo\",{\"1\":{\"490\":5}}],[\"reference\",{\"1\":{\"413\":1}}],[\"references\",{\"1\":{\"200\":2}}],[\"reflect\",{\"1\":{\"310\":7}}],[\"retry\",{\"1\":{\"369\":1,\"517\":2}}],[\"retention\",{\"1\":{\"308\":1}}],[\"returned\",{\"1\":{\"402\":1}}],[\"returns\",{\"1\":{\"397\":1,\"402\":1}}],[\"return\",{\"0\":{\"274\":1},\"1\":{\"76\":7,\"77\":7,\"84\":3,\"86\":3,\"91\":4,\"93\":4,\"102\":1,\"107\":2,\"111\":1,\"112\":1,\"113\":1,\"115\":3,\"139\":1,\"265\":2,\"266\":1,\"269\":2,\"274\":4,\"275\":6,\"276\":5,\"277\":4,\"278\":2,\"282\":3,\"283\":1,\"288\":1,\"289\":1,\"310\":1,\"333\":1,\"359\":4,\"360\":3,\"366\":6,\"367\":1,\"369\":3,\"370\":1,\"378\":2,\"379\":2,\"391\":1,\"395\":2,\"397\":1,\"398\":1,\"399\":4,\"400\":4,\"401\":3,\"402\":6,\"409\":2,\"413\":1,\"479\":1,\"487\":1,\"497\":1,\"507\":1,\"508\":10,\"516\":5,\"517\":4,\"518\":2,\"519\":1,\"520\":4,\"522\":1,\"523\":2}}],[\"red\",{\"1\":{\"284\":1,\"394\":2}}],[\"redirect\",{\"1\":{\"23\":1}}],[\"regex\",{\"1\":{\"260\":1,\"324\":1}}],[\"removals\",{\"1\":{\"402\":1}}],[\"remove\",{\"1\":{\"293\":1,\"294\":1,\"295\":1,\"327\":2,\"328\":1,\"331\":1,\"370\":1}}],[\"removeobjectargs\",{\"1\":{\"142\":1}}],[\"removeobject\",{\"1\":{\"142\":2}}],[\"removebucketargs\",{\"1\":{\"141\":1}}],[\"removebucket\",{\"1\":{\"141\":2}}],[\"remote\",{\"1\":{\"26\":1}}],[\"rename\",{\"1\":{\"185\":1}}],[\"render\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"renormalize\",{\"1\":{\"26\":1}}],[\"reset\",{\"1\":{\"508\":1,\"523\":1}}],[\"result\",{\"1\":{\"413\":3,\"441\":1,\"461\":1}}],[\"resizing\",{\"1\":{\"402\":1}}],[\"resizers\",{\"1\":{\"402\":1}}],[\"resize\",{\"1\":{\"401\":1,\"402\":2,\"403\":2}}],[\"resizestamp\",{\"1\":{\"401\":1,\"402\":1}}],[\"resync\",{\"1\":{\"379\":1}}],[\"res\",{\"1\":{\"265\":4,\"266\":5,\"310\":2}}],[\"response\",{\"1\":{\"85\":3,\"86\":3,\"92\":3,\"93\":3}}],[\"resources\",{\"0\":{\"304\":1}}],[\"resource\",{\"1\":{\"47\":1,\"48\":1,\"139\":1,\"141\":1,\"304\":1,\"349\":13}}],[\"readobject\",{\"1\":{\"508\":1}}],[\"readonly\",{\"1\":{\"153\":2}}],[\"reader\",{\"1\":{\"394\":1,\"444\":1,\"467\":2,\"468\":1,\"487\":2,\"488\":2,\"490\":2}}],[\"readers\",{\"1\":{\"370\":1}}],[\"readershouldblock\",{\"1\":{\"369\":1}}],[\"readholds\",{\"1\":{\"369\":2,\"370\":2}}],[\"readlock\",{\"1\":{\"364\":4,\"371\":4}}],[\"readline\",{\"1\":{\"236\":1,\"304\":1}}],[\"read\",{\"1\":{\"75\":2,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"118\":1,\"121\":1,\"366\":1,\"370\":2,\"371\":3,\"394\":1,\"487\":1,\"494\":7}}],[\"reboot\",{\"1\":{\"70\":1}}],[\"re\",{\"1\":{\"55\":1,\"76\":2,\"77\":3,\"84\":2,\"86\":3,\"91\":2,\"93\":3},\"2\":{\"78\":1}}],[\"reverseorder\",{\"1\":{\"293\":1,\"322\":1,\"333\":1}}],[\"reverse\",{\"1\":{\"260\":1}}],[\"reversal\",{\"1\":{\"104\":1,\"107\":1}}],[\"revealjs\",{\"1\":{\"23\":1}}],[\"review\",{\"1\":{\"47\":1}}],[\"rc\",{\"1\":{\"23\":11}}],[\"4ghz\",{\"1\":{\"346\":2}}],[\"42\",{\"1\":{\"267\":1}}],[\"4294967295\",{\"1\":{\"183\":1}}],[\"404\",{\"1\":{\"527\":1}}],[\"400\",{\"1\":{\"239\":1,\"240\":1}}],[\"402823466351\",{\"1\":{\"183\":1}}],[\"402823466\",{\"1\":{\"183\":2}}],[\"4bytes\",{\"1\":{\"183\":2}}],[\"456d\",{\"1\":{\"237\":1}}],[\"45\",{\"1\":{\"104\":1,\"105\":1,\"107\":2,\"260\":1}}],[\"489\",{\"1\":{\"91\":1,\"93\":1}}],[\"48\",{\"1\":{\"23\":1,\"259\":1}}],[\"47\",{\"1\":{\"23\":2}}],[\"4\",{\"0\":{\"34\":1,\"154\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":2,\"178\":1,\"186\":1,\"191\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":2,\"196\":1,\"197\":1,\"198\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":2,\"214\":1,\"236\":1,\"246\":1,\"247\":1,\"248\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1,\"256\":1,\"257\":1,\"262\":1,\"268\":1,\"277\":1,\"284\":1,\"289\":1,\"294\":1,\"300\":1,\"354\":1,\"371\":1,\"381\":1,\"400\":1,\"403\":1,\"416\":1,\"422\":1,\"430\":1,\"451\":1,\"457\":1,\"458\":1,\"459\":1,\"461\":1,\"468\":1,\"485\":1,\"486\":1,\"487\":1,\"488\":1,\"499\":1,\"520\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1},\"1\":{\"23\":2,\"76\":1,\"77\":1,\"158\":2,\"171\":1,\"183\":3,\"233\":3,\"235\":1,\"237\":2,\"239\":2,\"240\":1,\"241\":1,\"245\":1,\"255\":4,\"256\":1,\"270\":1,\"273\":1,\"275\":1,\"277\":2,\"284\":1,\"307\":1,\"308\":1,\"310\":2,\"346\":1,\"369\":1,\"378\":1,\"393\":1,\"394\":2,\"397\":2,\"398\":2,\"399\":2,\"400\":1,\"401\":7,\"413\":1,\"420\":1,\"444\":1,\"452\":1,\"467\":1,\"487\":1,\"488\":1,\"490\":1,\"494\":2,\"520\":2}}],[\"7和1\",{\"1\":{\"403\":1}}],[\"75=1\",{\"1\":{\"401\":1}}],[\"75\",{\"1\":{\"398\":5,\"401\":3}}],[\"70\",{\"1\":{\"239\":1}}],[\"78\",{\"1\":{\"235\":1}}],[\"777\",{\"1\":{\"183\":2}}],[\"722\",{\"1\":{\"349\":2}}],[\"72\",{\"1\":{\"103\":1,\"107\":1}}],[\"7976931348623157\",{\"1\":{\"183\":3}}],[\"79\",{\"1\":{\"23\":1}}],[\"7\",{\"0\":{\"198\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":1,\"287\":1,\"288\":1,\"289\":1,\"303\":1,\"423\":1},\"1\":{\"23\":2,\"241\":1,\"245\":1,\"255\":1,\"256\":1,\"386\":2,\"399\":2,\"403\":2,\"420\":1,\"456\":1,\"508\":1}}],[\"skip\",{\"1\":{\"517\":1}}],[\"skill\",{\"1\":{\"92\":2,\"93\":2}}],[\"skills\",{\"1\":{\"85\":1,\"86\":1,\"118\":2,\"121\":2}}],[\"sqrt\",{\"1\":{\"335\":1}}],[\"sqlexception\",{\"1\":{\"299\":1}}],[\"sql语句\",{\"1\":{\"217\":1}}],[\"sql优化\",{\"1\":{\"173\":1}}],[\"sql\",{\"0\":{\"170\":1,\"171\":1,\"533\":1},\"1\":{\"170\":1,\"171\":3,\"172\":1,\"205\":1,\"208\":1,\"210\":1,\"216\":4,\"217\":2,\"218\":1}}],[\"s2\",{\"1\":{\"324\":1}}],[\"s1\",{\"1\":{\"324\":1}}],[\"sb\",{\"1\":{\"262\":7,\"273\":5,\"325\":1}}],[\"sweep\",{\"1\":{\"401\":1}}],[\"swap\",{\"1\":{\"275\":2,\"448\":1}}],[\"swtich\",{\"1\":{\"241\":1}}],[\"switch\",{\"0\":{\"241\":1},\"1\":{\"241\":1}}],[\"small\",{\"1\":{\"239\":2}}],[\"smallint\",{\"1\":{\"183\":1}}],[\"slot\",{\"1\":{\"226\":1}}],[\"sleepthread\",{\"1\":{\"419\":14}}],[\"sleepthread睡眠1000ms\",{\"1\":{\"419\":1}}],[\"sleep\",{\"0\":{\"421\":1},\"1\":{\"93\":1,\"314\":3,\"315\":1,\"318\":1,\"349\":1,\"387\":1,\"417\":1,\"419\":1,\"421\":8,\"422\":2,\"423\":2,\"441\":1,\"461\":1,\"470\":1,\"494\":1,\"508\":1}}],[\"successor\",{\"1\":{\"518\":2}}],[\"sure\",{\"1\":{\"517\":1}}],[\"sun\",{\"1\":{\"386\":3,\"393\":3,\"402\":1,\"409\":1}}],[\"sunday\",{\"1\":{\"241\":1}}],[\"suppresswarnings\",{\"1\":{\"307\":1,\"398\":1,\"401\":1}}],[\"super\",{\"1\":{\"283\":3,\"394\":1,\"413\":1,\"419\":1}}],[\"sumcount\",{\"1\":{\"402\":5}}],[\"sum\",{\"1\":{\"195\":2,\"243\":3,\"245\":6,\"248\":3,\"402\":3}}],[\"submit\",{\"1\":{\"413\":1}}],[\"subdivide\",{\"1\":{\"401\":1}}],[\"substring\",{\"1\":{\"260\":1,\"324\":2}}],[\"subset=\",{\"1\":{\"75\":1}}],[\"subtitle=\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"sublist\",{\"1\":{\"91\":1,\"93\":1,\"327\":1}}],[\"sublevelmodellist\",{\"1\":{\"84\":2,\"86\":1}}],[\"sub\",{\"1\":{\"84\":2,\"86\":2,\"91\":2,\"93\":2}}],[\"ss\",{\"1\":{\"183\":3,\"324\":1}}],[\"since\",{\"1\":{\"402\":1}}],[\"singleton\",{\"0\":{\"341\":1},\"1\":{\"497\":7}}],[\"signalling\",{\"1\":{\"518\":1}}],[\"signaler\",{\"1\":{\"381\":7}}],[\"signalthread\",{\"1\":{\"380\":1}}],[\"signalall\",{\"0\":{\"379\":1,\"380\":1},\"1\":{\"375\":2,\"378\":3,\"379\":3,\"380\":3,\"381\":1}}],[\"signal\",{\"0\":{\"374\":1,\"379\":1,\"380\":1},\"1\":{\"375\":2,\"378\":3,\"379\":9,\"380\":3,\"513\":1,\"517\":8,\"518\":1,\"523\":3}}],[\"signed\",{\"1\":{\"183\":1}}],[\"sid\",{\"1\":{\"141\":1}}],[\"sizectl\",{\"1\":{\"393\":3,\"397\":4,\"398\":5,\"401\":6,\"402\":3,\"403\":1}}],[\"sizethreshold>\",{\"1\":{\"129\":1}}],[\"size\",{\"0\":{\"402\":1},\"1\":{\"119\":1,\"121\":1,\"129\":1,\"221\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"327\":2,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1,\"397\":1,\"402\":7,\"403\":2}}],[\"size=25\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"syncnized\",{\"1\":{\"461\":1}}],[\"synchronize\",{\"1\":{\"504\":1}}],[\"synchronized了\",{\"1\":{\"446\":1}}],[\"synchronized优化\",{\"0\":{\"446\":1}}],[\"synchronizeddemo\",{\"1\":{\"441\":2,\"443\":5,\"461\":3}}],[\"synchronizedlist\",{\"1\":{\"407\":1}}],[\"synchronizedmap\",{\"1\":{\"391\":2}}],[\"synchronized\",{\"0\":{\"317\":1,\"440\":1,\"441\":1,\"442\":1,\"444\":1,\"496\":1},\"1\":{\"317\":4,\"318\":1,\"349\":4,\"358\":2,\"364\":1,\"391\":5,\"399\":2,\"401\":1,\"403\":1,\"407\":2,\"417\":2,\"420\":2,\"441\":2,\"442\":3,\"443\":5,\"444\":3,\"445\":2,\"449\":2,\"461\":1,\"465\":2,\"494\":3,\"496\":3,\"497\":1,\"498\":1,\"499\":1,\"504\":4,\"519\":1}}],[\"synchronzied\",{\"1\":{\"391\":2,\"399\":1}}],[\"synchronzedmap\",{\"1\":{\"391\":1}}],[\"synchronzed\",{\"1\":{\"386\":2,\"498\":1}}],[\"sync\",{\"1\":{\"360\":2,\"505\":2,\"508\":15}}],[\"system\",{\"1\":{\"141\":3,\"142\":6,\"235\":9,\"236\":3,\"237\":7,\"239\":39,\"240\":7,\"241\":2,\"243\":5,\"244\":2,\"245\":5,\"247\":3,\"248\":1,\"249\":3,\"254\":8,\"255\":2,\"256\":2,\"259\":5,\"260\":2,\"261\":3,\"262\":2,\"266\":1,\"269\":2,\"270\":3,\"272\":1,\"273\":2,\"275\":1,\"276\":2,\"277\":4,\"278\":2,\"284\":2,\"288\":3,\"289\":3,\"302\":4,\"303\":3,\"304\":2,\"310\":3,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"324\":2,\"349\":4,\"381\":2,\"387\":1,\"413\":3,\"419\":2,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"479\":1,\"494\":1,\"520\":5}}],[\"symbol\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"sdk\",{\"1\":{\"134\":7}}],[\"s3\",{\"1\":{\"132\":1,\"134\":5,\"141\":2}}],[\"score\",{\"1\":{\"324\":2}}],[\"sc\",{\"1\":{\"236\":6,\"239\":22,\"240\":6,\"241\":2,\"243\":2,\"245\":2,\"247\":2,\"254\":8,\"260\":1,\"261\":3,\"276\":3,\"278\":2,\"302\":3,\"303\":2,\"398\":7,\"401\":4,\"402\":9}}],[\"scanner\",{\"1\":{\"236\":3,\"239\":27,\"240\":6,\"241\":3,\"243\":3,\"245\":3,\"247\":3,\"254\":9,\"256\":1,\"261\":3,\"276\":3,\"277\":1,\"278\":3,\"302\":3,\"303\":3}}],[\"schemas\",{\"1\":{\"178\":1}}],[\"schema\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1,\"178\":2}}],[\"scroll\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":2}}],[\"script\",{\"1\":{\"53\":1}}],[\"scripts\",{\"1\":{\"23\":1}}],[\"spread\",{\"1\":{\"399\":6,\"400\":1}}],[\"springboot\",{\"0\":{\"137\":1},\"1\":{\"139\":1}}],[\"spinfortimeoutthreshold\",{\"1\":{\"520\":1}}],[\"spinlock\",{\"1\":{\"402\":1}}],[\"spin\",{\"1\":{\"398\":1}}],[\"spider\",{\"1\":{\"75\":4,\"86\":2,\"93\":2}}],[\"splice\",{\"1\":{\"379\":1}}],[\"split\",{\"1\":{\"76\":1,\"77\":1,\"118\":1,\"121\":1,\"260\":2,\"324\":2}}],[\"spark\",{\"1\":{\"134\":1}}],[\"shmin\",{\"1\":{\"338\":1}}],[\"shmax\",{\"1\":{\"338\":1}}],[\"shouldparkafterfailedacquire\",{\"1\":{\"516\":1,\"517\":6,\"519\":1,\"520\":1,\"522\":1}}],[\"should\",{\"1\":{\"369\":1,\"402\":1}}],[\"short\",{\"1\":{\"233\":1,\"338\":2}}],[\"show\",{\"1\":{\"175\":1,\"178\":1,\"184\":2,\"221\":1,\"222\":1}}],[\"show=true\",{\"1\":{\"102\":2,\"103\":1,\"104\":1,\"106\":1,\"107\":5,\"111\":1,\"112\":1,\"114\":1,\"115\":3}}],[\"show=false\",{\"1\":{\"102\":1,\"103\":1,\"104\":3,\"107\":5,\"111\":1,\"112\":1,\"115\":2}}],[\"sh\",{\"1\":{\"146\":8,\"158\":4}}],[\"shell脚本在逐行执行\",{\"1\":{\"146\":1}}],[\"shell\",{\"0\":{\"145\":1},\"1\":{\"126\":1,\"146\":7,\"158\":1}}],[\"shtml\",{\"1\":{\"125\":1}}],[\"shift+enter\",{\"1\":{\"71\":1}}],[\"shift\",{\"1\":{\"71\":3,\"366\":2,\"369\":1,\"401\":1,\"402\":2}}],[\"sharedcount\",{\"1\":{\"366\":1,\"369\":1}}],[\"shared\",{\"1\":{\"23\":1,\"366\":3,\"369\":3,\"370\":1,\"522\":1}}],[\"store\",{\"1\":{\"494\":5}}],[\"storeload\",{\"1\":{\"469\":2}}],[\"storestore屏障可以省略\",{\"1\":{\"489\":1}}],[\"storestore\",{\"1\":{\"469\":2,\"487\":1,\"489\":1}}],[\"storage\",{\"1\":{\"133\":1,\"484\":1}}],[\"stop\",{\"1\":{\"402\":1}}],[\"still\",{\"1\":{\"371\":1}}],[\"step\",{\"1\":{\"369\":2}}],[\"student\",{\"1\":{\"280\":2}}],[\"stderr\",{\"1\":{\"126\":1}}],[\"stdout\",{\"1\":{\"126\":2}}],[\"stride\",{\"1\":{\"401\":7}}],[\"striped64\",{\"1\":{\"402\":1}}],[\"strip\",{\"1\":{\"324\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"300\":1}}],[\"string不能被修改\",{\"1\":{\"262\":1}}],[\"stringbuffer线程安全\",{\"1\":{\"262\":1}}],[\"stringbuffer\",{\"0\":{\"262\":1}}],[\"stringbuilder线程不安全\",{\"1\":{\"262\":1}}],[\"stringbuilder\",{\"0\":{\"262\":1,\"325\":1},\"1\":{\"262\":2,\"273\":4,\"323\":5,\"325\":2}}],[\"string转double\",{\"1\":{\"260\":1}}],[\"string可以通过加号拼接\",{\"1\":{\"260\":1}}],[\"string\",{\"0\":{\"260\":1,\"324\":1},\"1\":{\"139\":4,\"141\":2,\"142\":1,\"233\":1,\"235\":3,\"236\":5,\"237\":3,\"239\":9,\"240\":2,\"241\":2,\"243\":4,\"244\":1,\"245\":4,\"247\":1,\"248\":1,\"249\":2,\"252\":1,\"253\":1,\"254\":4,\"255\":2,\"256\":1,\"259\":2,\"260\":17,\"261\":3,\"266\":1,\"269\":2,\"270\":1,\"272\":2,\"273\":2,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"282\":2,\"283\":5,\"284\":1,\"288\":1,\"289\":2,\"300\":1,\"301\":2,\"302\":1,\"303\":1,\"304\":2,\"310\":4,\"314\":2,\"316\":1,\"317\":2,\"318\":1,\"323\":3,\"324\":24,\"325\":1,\"349\":9,\"377\":1,\"381\":1,\"386\":2,\"387\":1,\"413\":3,\"419\":1,\"420\":1,\"423\":1,\"441\":1,\"443\":1,\"461\":1,\"470\":1,\"474\":1,\"479\":2,\"482\":1,\"484\":3,\"494\":1,\"508\":1}}],[\"str2\",{\"1\":{\"261\":2,\"323\":1}}],[\"str1\",{\"1\":{\"261\":2,\"323\":1}}],[\"strs\",{\"1\":{\"260\":1}}],[\"stream\",{\"1\":{\"142\":1}}],[\"stress\",{\"1\":{\"53\":1}}],[\"str\",{\"1\":{\"76\":1,\"77\":1,\"84\":1,\"86\":1,\"91\":2,\"93\":2,\"102\":1,\"104\":1,\"107\":3,\"111\":2,\"112\":1,\"113\":1,\"115\":4,\"118\":1,\"121\":1,\"236\":3,\"260\":10,\"324\":10,\"325\":1,\"482\":1}}],[\"stamp\",{\"1\":{\"401\":1,\"402\":2}}],[\"stack类\",{\"1\":{\"330\":1}}],[\"stack<e>\",{\"1\":{\"330\":1}}],[\"stack<>\",{\"1\":{\"292\":1,\"330\":1}}],[\"stack\",{\"1\":{\"330\":6,\"349\":1}}],[\"stacktraceelement\",{\"1\":{\"301\":1}}],[\"state\",{\"1\":{\"366\":2,\"369\":2,\"371\":2,\"386\":2,\"450\":1,\"508\":5}}],[\"statements\",{\"1\":{\"52\":1}}],[\"statement\",{\"1\":{\"47\":1,\"141\":1,\"245\":4}}],[\"static修饰的变量\",{\"1\":{\"477\":1}}],[\"static\",{\"1\":{\"233\":1,\"235\":3,\"236\":2,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":4,\"244\":1,\"245\":4,\"247\":1,\"248\":1,\"249\":2,\"252\":1,\"253\":1,\"254\":4,\"255\":2,\"256\":1,\"259\":2,\"261\":1,\"265\":2,\"266\":2,\"269\":3,\"270\":5,\"272\":2,\"273\":3,\"275\":2,\"276\":2,\"277\":3,\"278\":2,\"282\":2,\"284\":1,\"289\":1,\"302\":2,\"303\":2,\"304\":1,\"310\":1,\"314\":2,\"316\":3,\"317\":3,\"318\":1,\"349\":4,\"366\":3,\"377\":1,\"381\":6,\"387\":1,\"393\":1,\"394\":7,\"395\":3,\"397\":1,\"399\":2,\"402\":1,\"408\":1,\"413\":1,\"419\":1,\"420\":2,\"421\":1,\"422\":1,\"423\":1,\"441\":2,\"443\":2,\"461\":2,\"470\":2,\"479\":3,\"487\":3,\"494\":2,\"497\":1,\"508\":3,\"517\":1}}],[\"status\",{\"1\":{\"221\":1,\"517\":1,\"518\":2,\"523\":2}}],[\"statobjectargs\",{\"1\":{\"142\":1}}],[\"statobjectresponse\",{\"1\":{\"142\":3}}],[\"statobject\",{\"1\":{\"142\":2}}],[\"standardcharsets\",{\"1\":{\"324\":2}}],[\"standard\",{\"1\":{\"57\":1}}],[\"startswith\",{\"1\":{\"260\":1}}],[\"start\",{\"1\":{\"45\":1,\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"217\":1,\"314\":4,\"315\":1,\"316\":2,\"317\":4,\"318\":2,\"336\":1,\"349\":2,\"377\":1,\"381\":2,\"387\":1,\"413\":3,\"414\":1,\"417\":1,\"419\":2,\"420\":1,\"423\":2,\"433\":3,\"441\":1,\"461\":1,\"470\":1,\"494\":1,\"508\":1}}],[\"started\",{\"2\":{\"19\":1}}],[\"so\",{\"1\":{\"366\":1,\"369\":1,\"517\":1,\"523\":1}}],[\"sort\",{\"1\":{\"257\":1,\"322\":2}}],[\"solomon\",{\"1\":{\"134\":1}}],[\"solution\",{\"1\":{\"57\":1}}],[\"solutions\",{\"1\":{\"44\":2,\"48\":1,\"55\":1}}],[\"soupager\",{\"1\":{\"92\":7,\"93\":3}}],[\"sou\",{\"1\":{\"88\":1,\"93\":1}}],[\"source\",{\"1\":{\"48\":1,\"49\":1}}],[\"se5\",{\"1\":{\"504\":1}}],[\"see\",{\"1\":{\"397\":1,\"402\":1}}],[\"segment\",{\"1\":{\"391\":4,\"403\":8}}],[\"sec\",{\"1\":{\"397\":1}}],[\"second\",{\"1\":{\"337\":1}}],[\"securityexception\",{\"1\":{\"300\":1}}],[\"secretkey\",{\"1\":{\"139\":2}}],[\"separate\",{\"1\":{\"226\":1}}],[\"select\",{\"1\":{\"134\":1,\"175\":2,\"192\":1,\"193\":4,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"205\":4,\"207\":2,\"208\":2,\"210\":6}}],[\"selfinterrupt\",{\"1\":{\"378\":1,\"507\":1,\"515\":1,\"522\":1}}],[\"self\",{\"1\":{\"84\":11,\"85\":3,\"86\":30,\"91\":12,\"92\":3,\"93\":31}}],[\"serializable\",{\"1\":{\"505\":1,\"508\":1}}],[\"serial\",{\"1\":{\"430\":6,\"432\":5}}],[\"series\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"107\":3,\"111\":1,\"112\":1,\"115\":2}}],[\"service\",{\"1\":{\"413\":2}}],[\"service>\",{\"1\":{\"129\":1}}],[\"server<\",{\"1\":{\"129\":2}}],[\"server\",{\"1\":{\"126\":4,\"127\":1,\"128\":2,\"129\":5}}],[\"sensorsdata\",{\"1\":{\"96\":1}}],[\"sessionpage\",{\"1\":{\"77\":1,\"84\":1,\"86\":2,\"91\":1,\"93\":2,\"96\":1}}],[\"setheadandpropagate\",{\"1\":{\"522\":1}}],[\"sethead\",{\"1\":{\"516\":1,\"517\":4,\"519\":1,\"520\":1}}],[\"setpriority\",{\"1\":{\"422\":1}}],[\"setter\",{\"1\":{\"484\":1}}],[\"settabat\",{\"1\":{\"395\":2,\"401\":6}}],[\"setting\",{\"1\":{\"394\":1,\"508\":1}}],[\"setstate\",{\"1\":{\"359\":2,\"360\":1,\"366\":1,\"367\":1,\"506\":1,\"507\":1,\"508\":3}}],[\"setexclusiveownerthread\",{\"1\":{\"359\":2,\"360\":1,\"366\":1,\"367\":1,\"508\":2}}],[\"setvalue\",{\"1\":{\"329\":1}}],[\"set<map\",{\"1\":{\"329\":1}}],[\"set<e>\",{\"1\":{\"328\":2}}],[\"set<integer>\",{\"1\":{\"327\":1}}],[\"set<k>\",{\"1\":{\"294\":1,\"329\":1}}],[\"setdaemon\",{\"1\":{\"315\":1,\"423\":3}}],[\"setname\",{\"1\":{\"314\":2,\"318\":2}}],[\"setcolor\",{\"1\":{\"283\":1}}],[\"setcharat\",{\"1\":{\"262\":1}}],[\"sety\",{\"1\":{\"282\":1}}],[\"setx\",{\"1\":{\"282\":1}}],[\"setbucketpolicyargs\",{\"1\":{\"141\":1}}],[\"setbucketpolicy\",{\"1\":{\"141\":1}}],[\"set\",{\"0\":{\"294\":1,\"328\":1},\"1\":{\"35\":2,\"102\":1,\"103\":2,\"104\":1,\"107\":4,\"111\":1,\"112\":1,\"115\":2,\"119\":1,\"121\":1,\"189\":2,\"291\":1,\"310\":1,\"327\":1,\"328\":3,\"366\":1,\"369\":1,\"379\":2,\"394\":2,\"517\":1,\"523\":1}}],[\"searchtype\",{\"1\":{\"95\":1}}],[\"searchtype=2\",{\"1\":{\"95\":1,\"96\":1}}],[\"search\",{\"1\":{\"23\":1,\"85\":1,\"86\":1,\"89\":1,\"91\":1,\"92\":1,\"93\":2,\"95\":2,\"96\":1,\"127\":1,\"330\":1}}],[\"s\",{\"1\":{\"30\":1,\"134\":2,\"237\":1,\"239\":4,\"261\":2,\"283\":1,\"324\":8,\"402\":5,\"508\":2,\"518\":7}}],[\"saturated\",{\"1\":{\"369\":1}}],[\"saturate\",{\"1\":{\"366\":1}}],[\"saturday\",{\"1\":{\"241\":1}}],[\"satrt\",{\"1\":{\"327\":1}}],[\"salary60\",{\"1\":{\"92\":1,\"93\":1}}],[\"salarydesc\",{\"1\":{\"85\":1,\"86\":1}}],[\"salary\",{\"1\":{\"76\":2,\"77\":8}}],[\"safely\",{\"1\":{\"517\":1}}],[\"safe\",{\"1\":{\"75\":7,\"77\":2,\"86\":4,\"93\":4,\"118\":2,\"121\":2}}],[\"savedstate\",{\"1\":{\"378\":8}}],[\"save\",{\"1\":{\"47\":1}}],[\"sass\",{\"1\":{\"23\":2}}],[\"sandpack\",{\"1\":{\"23\":1}}],[\"src\",{\"1\":{\"23\":3}}],[\"0l\",{\"1\":{\"402\":3,\"520\":2}}],[\"0x00dcf000\",{\"1\":{\"386\":1}}],[\"0x00d6f000\",{\"1\":{\"386\":1}}],[\"0x00010000\",{\"1\":{\"369\":1}}],[\"0x0000ffff\",{\"1\":{\"366\":2}}],[\"0x00000007d5ff53d8\",{\"1\":{\"349\":1}}],[\"0x00000007d5ff53a8\",{\"1\":{\"349\":1}}],[\"0x000000000b697c10\",{\"1\":{\"349\":1}}],[\"0x000000000b695360\",{\"1\":{\"349\":1}}],[\"0接收到通知\",{\"1\":{\"381\":1}}],[\"0当前条件不满足等待\",{\"1\":{\"381\":1}}],[\"0表示相等\",{\"1\":{\"260\":1}}],[\"0表示正常退出\",{\"1\":{\"159\":1}}],[\"04d\",{\"1\":{\"237\":1}}],[\"07\",{\"1\":{\"183\":1}}],[\"03\",{\"1\":{\"183\":1}}],[\"01\",{\"1\":{\"183\":8}}],[\"00<\",{\"1\":{\"129\":1}}],[\"00\",{\"1\":{\"129\":1,\"183\":5}}],[\"0\",{\"1\":{\"23\":37,\"77\":2,\"102\":4,\"104\":4,\"107\":8,\"111\":2,\"112\":6,\"115\":8,\"132\":1,\"156\":1,\"161\":1,\"162\":1,\"169\":2,\"183\":17,\"198\":1,\"234\":1,\"239\":4,\"240\":3,\"243\":2,\"245\":3,\"247\":1,\"248\":1,\"249\":3,\"253\":1,\"254\":11,\"255\":6,\"256\":1,\"259\":1,\"260\":1,\"262\":1,\"267\":1,\"273\":1,\"275\":5,\"277\":2,\"302\":2,\"314\":3,\"316\":2,\"317\":4,\"318\":1,\"324\":1,\"329\":1,\"335\":1,\"349\":3,\"359\":5,\"360\":3,\"366\":5,\"367\":1,\"369\":3,\"370\":3,\"377\":2,\"378\":4,\"379\":2,\"393\":1,\"397\":3,\"398\":9,\"399\":9,\"400\":4,\"401\":19,\"402\":6,\"420\":2,\"430\":1,\"441\":3,\"444\":1,\"445\":1,\"456\":1,\"461\":3,\"467\":1,\"488\":4,\"494\":3,\"508\":6,\"513\":1,\"517\":3,\"518\":6,\"522\":4,\"523\":3}}],[\"volatile包含禁止指令重排序的语义\",{\"1\":{\"497\":1}}],[\"volatiledemo\",{\"1\":{\"470\":1}}],[\"volatileexample\",{\"1\":{\"467\":1,\"494\":1}}],[\"volatile\",{\"0\":{\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"468\":1,\"469\":1,\"497\":1},\"1\":{\"381\":1,\"393\":3,\"394\":6,\"402\":4,\"403\":1,\"408\":5,\"429\":2,\"433\":3,\"435\":2,\"465\":4,\"466\":4,\"467\":8,\"468\":6,\"469\":14,\"470\":3,\"488\":1,\"494\":3,\"497\":4,\"498\":2,\"499\":1,\"503\":1,\"513\":4}}],[\"void\",{\"1\":{\"141\":4,\"142\":6,\"233\":1,\"235\":3,\"236\":2,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":4,\"244\":1,\"245\":4,\"247\":1,\"248\":1,\"249\":2,\"252\":1,\"253\":1,\"254\":4,\"255\":2,\"256\":1,\"259\":2,\"261\":1,\"266\":1,\"268\":1,\"269\":2,\"270\":4,\"272\":2,\"273\":3,\"275\":5,\"276\":2,\"277\":1,\"278\":1,\"282\":2,\"283\":1,\"284\":1,\"286\":2,\"287\":1,\"288\":3,\"289\":4,\"301\":1,\"302\":2,\"303\":2,\"304\":1,\"310\":1,\"314\":5,\"316\":2,\"317\":5,\"318\":2,\"349\":4,\"371\":1,\"375\":3,\"377\":1,\"378\":2,\"379\":3,\"381\":3,\"386\":7,\"387\":1,\"395\":1,\"401\":1,\"402\":1,\"409\":1,\"413\":3,\"419\":3,\"420\":5,\"421\":1,\"422\":1,\"423\":2,\"441\":2,\"443\":2,\"444\":2,\"461\":2,\"467\":2,\"470\":2,\"479\":1,\"481\":1,\"482\":2,\"483\":1,\"487\":2,\"488\":3,\"490\":2,\"494\":2,\"505\":2,\"507\":1,\"508\":5,\"512\":4,\"515\":1,\"517\":1,\"518\":1,\"519\":2,\"522\":2,\"523\":1}}],[\"vs\",{\"0\":{\"479\":1},\"1\":{\"360\":1,\"421\":1,\"432\":1,\"449\":1}}],[\"vmstat\",{\"1\":{\"348\":1}}],[\"vector\",{\"1\":{\"330\":1,\"407\":2}}],[\"vertical\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"verify\",{\"1\":{\"57\":1}}],[\"version>\",{\"1\":{\"138\":1}}],[\"version\",{\"1\":{\"23\":1,\"141\":1,\"369\":2}}],[\"v>的个数\",{\"1\":{\"329\":1}}],[\"v>>\",{\"1\":{\"329\":1}}],[\"v>多的函数\",{\"1\":{\"295\":1}}],[\"v>\",{\"0\":{\"337\":1},\"1\":{\"295\":4,\"337\":1,\"391\":2,\"393\":2,\"394\":17,\"395\":11,\"397\":1,\"398\":4,\"399\":13,\"400\":2,\"401\":24,\"402\":1}}],[\"v1\",{\"1\":{\"268\":2}}],[\"varchar\",{\"1\":{\"183\":4,\"185\":4}}],[\"val\",{\"1\":{\"257\":1,\"265\":2,\"266\":2,\"291\":1,\"333\":2,\"394\":1,\"399\":8,\"400\":3,\"401\":2,\"409\":6}}],[\"valid\",{\"1\":{\"241\":1}}],[\"validate\",{\"1\":{\"55\":1}}],[\"validator\",{\"1\":{\"44\":1,\"47\":1,\"48\":1,\"49\":1,\"51\":4,\"55\":1,\"57\":2}}],[\"value>\",{\"1\":{\"329\":1}}],[\"valueof\",{\"1\":{\"324\":2}}],[\"values\",{\"1\":{\"101\":1,\"107\":1,\"115\":1,\"188\":4,\"329\":4,\"336\":1,\"394\":1,\"402\":1}}],[\"value\",{\"1\":{\"101\":1,\"102\":4,\"104\":1,\"107\":6,\"111\":1,\"112\":1,\"115\":3,\"295\":1,\"329\":4,\"336\":1,\"338\":16,\"391\":2,\"394\":4,\"399\":12,\"400\":1,\"401\":1,\"402\":7,\"484\":3}}],[\"v4\",{\"1\":{\"134\":1}}],[\"v2\",{\"1\":{\"132\":1,\"134\":1,\"268\":2}}],[\"v\",{\"1\":{\"34\":2,\"329\":3,\"336\":9,\"391\":2,\"393\":3,\"394\":1,\"395\":4,\"399\":3,\"400\":1,\"401\":1,\"402\":3,\"443\":1,\"449\":7}}],[\"v8\",{\"1\":{\"30\":1}}],[\"via\",{\"1\":{\"402\":1}}],[\"visualmapopts\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"visualmap\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"view\",{\"1\":{\"23\":1,\"49\":1,\"55\":1}}],[\"vite\",{\"1\":{\"23\":4}}],[\"vue3\",{\"1\":{\"23\":1}}],[\"vueuse\",{\"1\":{\"23\":1}}],[\"vue\",{\"1\":{\"23\":2}}],[\"vuepress\",{\"1\":{\"15\":1,\"18\":1,\"21\":1,\"22\":3,\"23\":18,\"25\":1,\"29\":1},\"2\":{\"17\":1,\"19\":1,\"24\":1,\"28\":1}}],[\"vp\",{\"1\":{\"23\":1}}],[\"adapted\",{\"1\":{\"402\":1}}],[\"advance\",{\"1\":{\"401\":10}}],[\"added\",{\"1\":{\"523\":1}}],[\"additionally\",{\"1\":{\"523\":1}}],[\"adding\",{\"1\":{\"399\":1}}],[\"addwaiter\",{\"1\":{\"507\":1,\"515\":3,\"516\":3,\"518\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"addcount\",{\"1\":{\"399\":1,\"402\":3}}],[\"addconditionwaiter\",{\"1\":{\"378\":4}}],[\"addall\",{\"1\":{\"336\":1}}],[\"addressing\",{\"1\":{\"226\":1}}],[\"address\",{\"1\":{\"126\":3,\"127\":1,\"128\":1}}],[\"add\",{\"1\":{\"26\":3,\"49\":1,\"53\":1,\"102\":1,\"103\":2,\"104\":2,\"105\":3,\"106\":2,\"107\":10,\"111\":1,\"112\":1,\"113\":2,\"114\":2,\"115\":6,\"119\":1,\"120\":1,\"121\":3,\"185\":2,\"200\":1,\"291\":1,\"293\":1,\"294\":1,\"310\":2,\"327\":2,\"328\":1,\"331\":1}}],[\"awaitsignal\",{\"1\":{\"381\":1}}],[\"awaitthread\",{\"1\":{\"380\":5}}],[\"awaituninterruptibly\",{\"1\":{\"378\":2}}],[\"awaituntil\",{\"1\":{\"375\":1}}],[\"awaitutil\",{\"1\":{\"378\":1}}],[\"awaitnanos\",{\"1\":{\"375\":1,\"378\":1}}],[\"await\",{\"0\":{\"374\":1,\"378\":1,\"380\":1},\"1\":{\"375\":3,\"377\":4,\"378\":17,\"379\":3,\"380\":4,\"381\":2}}],[\"aws\",{\"1\":{\"134\":2,\"141\":2}}],[\"aqs可重写的方法如下图\",{\"1\":{\"507\":1}}],[\"aqs的角度\",{\"1\":{\"508\":1}}],[\"aqs的底层实现\",{\"1\":{\"379\":1}}],[\"aqs的底层实现分析可以看这篇文章\",{\"1\":{\"366\":1}}],[\"aqs的实现原理\",{\"1\":{\"377\":1}}],[\"aqs\",{\"0\":{\"502\":1,\"506\":1,\"507\":1,\"511\":1,\"512\":1},\"1\":{\"359\":1,\"366\":3,\"367\":1,\"369\":2,\"377\":9,\"378\":5,\"385\":1,\"505\":1,\"506\":1,\"507\":18,\"508\":22,\"512\":7,\"513\":5,\"515\":1,\"518\":1,\"519\":1,\"520\":1,\"523\":1}}],[\"aba\",{\"1\":{\"451\":2}}],[\"abase\",{\"1\":{\"395\":3}}],[\"above\",{\"1\":{\"349\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"505\":2,\"508\":1}}],[\"abs\",{\"1\":{\"335\":1}}],[\"abc\",{\"1\":{\"149\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"anticipation\",{\"1\":{\"518\":1}}],[\"an\",{\"1\":{\"402\":2}}],[\"another\",{\"1\":{\"369\":1,\"371\":1}}],[\"annotation\",{\"1\":{\"306\":1}}],[\"android\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"and\",{\"1\":{\"75\":2,\"86\":1,\"93\":1,\"194\":2,\"366\":3,\"369\":1,\"370\":1,\"371\":1,\"379\":2,\"399\":1,\"402\":2,\"448\":1,\"517\":1}}],[\"age=\",{\"1\":{\"479\":1}}],[\"age\",{\"1\":{\"260\":2,\"479\":6}}],[\"again\",{\"1\":{\"146\":1}}],[\"a++\",{\"1\":{\"234\":1,\"444\":1,\"494\":2}}],[\"at\",{\"1\":{\"349\":4,\"386\":6,\"423\":2}}],[\"atomicreference\",{\"1\":{\"451\":1}}],[\"atomicstampedreference\",{\"1\":{\"451\":1}}],[\"atomic\",{\"1\":{\"348\":1,\"450\":1,\"451\":2,\"503\":1}}],[\"atomicity\",{\"1\":{\"218\":2}}],[\"athena\",{\"1\":{\"289\":3}}],[\"attempt\",{\"1\":{\"379\":1}}],[\"attack\",{\"1\":{\"287\":1,\"288\":2,\"289\":2}}],[\"attr\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"96\":2}}],[\"avoid\",{\"1\":{\"369\":1}}],[\"avg\",{\"1\":{\"195\":2}}],[\"aversal\",{\"1\":{\"77\":2}}],[\"aversal=0\",{\"1\":{\"77\":1}}],[\"aversalary\",{\"1\":{\"77\":2,\"101\":3,\"107\":3,\"115\":3}}],[\"am\",{\"1\":{\"423\":5}}],[\"amazon\",{\"1\":{\"134\":2}}],[\"amd64\",{\"1\":{\"126\":1,\"128\":1}}],[\"azure\",{\"1\":{\"134\":1}}],[\"ai\",{\"1\":{\"134\":1}}],[\"autorollattime>\",{\"1\":{\"129\":1}}],[\"auto\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1,\"182\":3}}],[\"autocrlf\",{\"1\":{\"26\":1}}],[\"axislabel\",{\"1\":{\"104\":2,\"107\":2}}],[\"axisopts\",{\"1\":{\"104\":2,\"107\":2}}],[\"axis\",{\"1\":{\"104\":1,\"107\":1}}],[\"axis=bar\",{\"1\":{\"104\":1,\"107\":1}}],[\"also\",{\"1\":{\"523\":1}}],[\"alive\",{\"1\":{\"423\":5}}],[\"alice\",{\"1\":{\"324\":1}}],[\"already\",{\"1\":{\"366\":1,\"401\":1,\"517\":1}}],[\"alter\",{\"1\":{\"185\":6,\"200\":1}}],[\"all\",{\"1\":{\"329\":2,\"508\":1}}],[\"allargsconstructor\",{\"1\":{\"198\":1}}],[\"allows\",{\"1\":{\"366\":1}}],[\"allow\",{\"1\":{\"141\":1,\"370\":1}}],[\"allcity\",{\"1\":{\"91\":1,\"93\":1}}],[\"al智能助手\",{\"1\":{\"41\":1}}],[\"apache\",{\"1\":{\"132\":1}}],[\"apparently\",{\"1\":{\"369\":1,\"518\":1}}],[\"application\",{\"1\":{\"139\":1}}],[\"append\",{\"1\":{\"101\":1,\"107\":1,\"115\":1,\"118\":1,\"121\":1,\"262\":1,\"273\":1,\"323\":1,\"325\":1}}],[\"appdate\",{\"1\":{\"34\":1}}],[\"api\",{\"0\":{\"140\":1,\"505\":1},\"1\":{\"91\":1,\"93\":1,\"133\":2,\"134\":2,\"139\":1,\"321\":1},\"2\":{\"340\":1}}],[\"area\",{\"1\":{\"430\":1}}],[\"are\",{\"1\":{\"370\":1,\"402\":1,\"523\":2}}],[\"arithmeticexception\",{\"1\":{\"300\":1,\"302\":1}}],[\"arg\",{\"1\":{\"507\":4,\"512\":8,\"515\":3,\"516\":3,\"518\":2,\"519\":5,\"520\":5,\"522\":6,\"523\":2}}],[\"args\",{\"1\":{\"233\":1,\"235\":3,\"236\":2,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":4,\"244\":1,\"245\":4,\"247\":1,\"248\":1,\"249\":2,\"252\":1,\"253\":1,\"254\":4,\"255\":2,\"256\":1,\"259\":2,\"261\":1,\"266\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"284\":1,\"289\":1,\"302\":1,\"303\":1,\"304\":1,\"310\":1,\"314\":2,\"316\":1,\"317\":2,\"318\":1,\"349\":1,\"377\":1,\"381\":1,\"387\":1,\"413\":1,\"419\":1,\"420\":1,\"423\":1,\"441\":1,\"443\":1,\"461\":1,\"470\":1,\"479\":1,\"494\":1,\"508\":1}}],[\"arguments>\",{\"1\":{\"129\":1}}],[\"arr2\",{\"1\":{\"322\":1}}],[\"arr1\",{\"1\":{\"322\":1}}],[\"arr\",{\"1\":{\"322\":5,\"324\":2,\"336\":1}}],[\"arraydeque是deque的一个实现类\",{\"1\":{\"330\":1}}],[\"arraydeque<>\",{\"1\":{\"330\":1}}],[\"arraydeque\",{\"1\":{\"330\":2}}],[\"arraylist<e>\",{\"1\":{\"327\":1}}],[\"arraylist<>\",{\"1\":{\"291\":1,\"327\":2,\"328\":1}}],[\"arraylist\",{\"1\":{\"327\":2,\"407\":4}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"300\":1,\"302\":1}}],[\"arraystoreexception\",{\"1\":{\"300\":1}}],[\"arrays\",{\"1\":{\"257\":5,\"259\":2,\"269\":2,\"273\":2,\"488\":6}}],[\"array\",{\"1\":{\"161\":4,\"162\":5,\"163\":4,\"164\":4,\"302\":4,\"327\":2}}],[\"array=\",{\"1\":{\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"arrow\",{\"1\":{\"85\":1}}],[\"arn\",{\"1\":{\"141\":1}}],[\"artifactid>\",{\"1\":{\"138\":1}}],[\"artplayer\",{\"1\":{\"23\":1}}],[\"assign\",{\"1\":{\"494\":2}}],[\"assert\",{\"1\":{\"370\":1,\"508\":2}}],[\"ashift\",{\"1\":{\"395\":3}}],[\"asking\",{\"1\":{\"517\":1}}],[\"ask\",{\"1\":{\"369\":1}}],[\"ascii码\",{\"0\":{\"259\":1}}],[\"asc\",{\"1\":{\"197\":1}}],[\"as\",{\"1\":{\"77\":1,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"107\":2,\"115\":2,\"121\":2,\"193\":2,\"207\":2,\"402\":10,\"430\":6,\"432\":5}}],[\"actual\",{\"1\":{\"402\":1,\"518\":1}}],[\"action\",{\"1\":{\"141\":1}}],[\"acquiring\",{\"1\":{\"371\":2}}],[\"acquireinterruptibly\",{\"0\":{\"519\":1},\"1\":{\"508\":1,\"512\":2,\"519\":2}}],[\"acquirequeued\",{\"1\":{\"378\":3,\"507\":1,\"515\":3,\"516\":3,\"517\":2}}],[\"acquired\",{\"1\":{\"371\":1}}],[\"acquire\",{\"0\":{\"515\":1},\"1\":{\"366\":2,\"507\":3,\"508\":1,\"512\":2,\"515\":3,\"517\":2,\"519\":1}}],[\"acquiresharedinterruptibly\",{\"0\":{\"524\":1},\"1\":{\"512\":2}}],[\"acquireshared\",{\"0\":{\"522\":1},\"1\":{\"512\":2,\"522\":2}}],[\"acquires\",{\"1\":{\"359\":3,\"360\":3,\"366\":4,\"369\":1,\"507\":2,\"508\":3,\"523\":1}}],[\"acid\",{\"1\":{\"218\":1}}],[\"acwing\",{\"1\":{\"152\":1}}],[\"acs\",{\"1\":{\"146\":6,\"155\":5,\"158\":2}}],[\"accesskey\",{\"1\":{\"139\":2}}],[\"account\",{\"1\":{\"133\":1}}],[\"ac\",{\"1\":{\"44\":2,\"57\":1,\"146\":2}}],[\"a\",{\"1\":{\"23\":1,\"85\":2,\"86\":1,\"92\":2,\"93\":1,\"205\":1,\"206\":1,\"233\":4,\"234\":23,\"235\":8,\"239\":38,\"240\":5,\"243\":4,\"245\":4,\"252\":1,\"253\":2,\"254\":18,\"255\":4,\"256\":2,\"257\":1,\"259\":10,\"260\":3,\"269\":2,\"273\":9,\"275\":11,\"276\":3,\"277\":6,\"310\":2,\"324\":4,\"327\":2,\"335\":10,\"336\":1,\"349\":14,\"366\":2,\"380\":1,\"386\":2,\"397\":1,\"402\":10,\"420\":2,\"429\":5,\"430\":6,\"432\":6,\"433\":13,\"435\":1,\"444\":10,\"445\":8,\"451\":4,\"461\":1,\"467\":8,\"468\":6,\"487\":11,\"488\":2,\"490\":4,\"494\":12,\"508\":1,\"517\":2,\"523\":2}}],[\"安顺\",{\"1\":{\"76\":1,\"77\":1}}],[\"安庆\",{\"1\":{\"76\":1,\"77\":1}}],[\"安徽\",{\"1\":{\"76\":16,\"77\":16}}],[\"安阳\",{\"1\":{\"76\":1,\"77\":1}}],[\"安康\",{\"1\":{\"76\":1,\"77\":1}}],[\"安装启动\",{\"0\":{\"126\":1,\"127\":1,\"128\":1}}],[\"安装与部署\",{\"0\":{\"125\":1}}],[\"安装jupyter\",{\"1\":{\"99\":1}}],[\"安装教程以idea为例子\",{\"1\":{\"70\":1}}],[\"安装教程\",{\"0\":{\"70\":1}}],[\"安装完成之后\",{\"1\":{\"67\":1}}],[\"安装完成\",{\"1\":{\"67\":1,\"70\":1}}],[\"安装\",{\"0\":{\"65\":1,\"68\":1}}],[\"安装依赖\",{\"0\":{\"23\":1}}],[\"安全中间件\",{\"1\":{\"9\":1}}],[\"22\",{\"1\":{\"479\":2}}],[\"2250738585072014\",{\"1\":{\"183\":1}}],[\"24\",{\"1\":{\"479\":1}}],[\"2n∗0\",{\"1\":{\"401\":1}}],[\"2n−0\",{\"1\":{\"401\":1}}],[\"2n​\",{\"1\":{\"401\":1}}],[\"2n\",{\"1\":{\"401\":1}}],[\"2d\",{\"1\":{\"233\":1}}],[\"2f\",{\"1\":{\"233\":1,\"237\":1,\"324\":1}}],[\"23\",{\"1\":{\"183\":1,\"221\":2,\"235\":1}}],[\"295\",{\"1\":{\"183\":2}}],[\"294\",{\"1\":{\"183\":2}}],[\"21\",{\"1\":{\"252\":1}}],[\"2155\",{\"1\":{\"183\":1}}],[\"215\",{\"1\":{\"183\":2}}],[\"2147483647\",{\"1\":{\"183\":1}}],[\"2147483648\",{\"1\":{\"183\":1}}],[\"2^64\",{\"1\":{\"183\":1}}],[\"263\",{\"1\":{\"183\":2}}],[\"2bytes\",{\"1\":{\"183\":1}}],[\"2>\",{\"1\":{\"126\":2}}],[\"2004年\",{\"1\":{\"346\":1}}],[\"200\",{\"1\":{\"234\":1}}],[\"2000w+\",{\"1\":{\"221\":1}}],[\"2038\",{\"1\":{\"183\":1}}],[\"2012\",{\"1\":{\"141\":1}}],[\"20\",{\"1\":{\"106\":4,\"107\":4,\"114\":4,\"115\":4,\"119\":1,\"121\":1,\"234\":1,\"255\":1,\"349\":1}}],[\"2023\",{\"1\":{\"95\":1}}],[\"255\",{\"1\":{\"183\":4}}],[\"25\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"2\",{\"0\":{\"23\":1,\"32\":1,\"67\":1,\"70\":1,\"76\":1,\"87\":1,\"109\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":2,\"153\":1,\"154\":1,\"155\":1,\"156\":1,\"159\":1,\"162\":1,\"170\":1,\"171\":1,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"176\":2,\"177\":1,\"178\":1,\"179\":2,\"180\":2,\"181\":2,\"182\":3,\"183\":2,\"184\":3,\"185\":2,\"186\":2,\"189\":1,\"193\":1,\"201\":1,\"206\":1,\"211\":1,\"217\":1,\"221\":1,\"234\":1,\"239\":1,\"240\":2,\"241\":1,\"244\":1,\"248\":1,\"253\":1,\"255\":1,\"260\":1,\"266\":1,\"271\":1,\"272\":1,\"273\":2,\"276\":1,\"282\":1,\"285\":1,\"286\":1,\"287\":2,\"288\":1,\"289\":1,\"292\":1,\"298\":1,\"308\":1,\"309\":1,\"310\":1,\"311\":2,\"315\":1,\"316\":1,\"347\":1,\"348\":1,\"349\":2,\"352\":1,\"359\":1,\"365\":1,\"366\":1,\"367\":2,\"370\":1,\"376\":1,\"377\":1,\"378\":2,\"379\":1,\"386\":1,\"392\":1,\"393\":1,\"394\":2,\"395\":1,\"398\":1,\"409\":1,\"414\":1,\"420\":1,\"428\":1,\"433\":1,\"436\":1,\"442\":1,\"443\":1,\"444\":2,\"445\":1,\"449\":1,\"452\":1,\"455\":1,\"459\":1,\"466\":1,\"475\":1,\"476\":1,\"477\":1,\"478\":2,\"479\":2,\"480\":2,\"481\":2,\"482\":3,\"483\":1,\"488\":1,\"495\":1,\"496\":1,\"497\":2,\"504\":1,\"505\":1,\"506\":2,\"507\":1,\"513\":1,\"517\":1,\"518\":1,\"523\":1},\"1\":{\"23\":16,\"77\":2,\"93\":1,\"95\":1,\"102\":1,\"107\":1,\"134\":2,\"158\":2,\"161\":1,\"162\":1,\"171\":1,\"183\":1,\"233\":4,\"234\":1,\"235\":4,\"237\":1,\"239\":2,\"240\":1,\"241\":1,\"243\":1,\"245\":2,\"247\":1,\"248\":1,\"249\":2,\"253\":2,\"254\":4,\"255\":1,\"256\":1,\"259\":1,\"269\":1,\"273\":1,\"278\":2,\"284\":1,\"306\":1,\"307\":1,\"308\":1,\"310\":1,\"314\":2,\"359\":2,\"366\":3,\"367\":1,\"369\":3,\"377\":1,\"378\":1,\"379\":3,\"393\":2,\"394\":2,\"395\":1,\"397\":9,\"398\":3,\"399\":6,\"400\":1,\"401\":3,\"402\":3,\"403\":2,\"413\":2,\"420\":1,\"430\":1,\"432\":1,\"435\":1,\"444\":2,\"445\":2,\"446\":1,\"455\":1,\"467\":2,\"487\":2,\"488\":3,\"490\":4,\"494\":2,\"497\":2,\"513\":2,\"516\":9,\"520\":4}}],[\"是带头结点的还是不带头节点的\",{\"1\":{\"513\":1}}],[\"是单向还是双向\",{\"1\":{\"513\":1}}],[\"是核心部分\",{\"1\":{\"512\":1}}],[\"是个没有完全初始化的对象\",{\"1\":{\"490\":1}}],[\"是引用数据类型呢\",{\"1\":{\"479\":1}}],[\"是阻塞式同步\",{\"1\":{\"465\":1}}],[\"是这么优秀的语言😀\",{\"1\":{\"446\":1}}],[\"是可以成功操作的\",{\"1\":{\"479\":1}}],[\"是可以共享的\",{\"1\":{\"428\":1}}],[\"是可见的\",{\"1\":{\"445\":2}}],[\"是其他并发容器实现的基础\",{\"1\":{\"441\":1}}],[\"是语言级的内存模型\",{\"1\":{\"435\":1}}],[\"是非常粗暴的在方法上用\",{\"1\":{\"407\":1}}],[\"是线程安全\",{\"1\":{\"407\":1}}],[\"是线程的阻塞原语\",{\"1\":{\"385\":1}}],[\"是很像的\",{\"1\":{\"401\":1}}],[\"是标准的链地址的解决方式\",{\"1\":{\"399\":1}}],[\"是不是整体的效率变高速率变快了\",{\"1\":{\"446\":1}}],[\"是不是特殊的节点呢\",{\"1\":{\"399\":1}}],[\"是不是刚好是\",{\"1\":{\"398\":1}}],[\"是不是在多的一方添加外键\",{\"1\":{\"201\":1}}],[\"是怎么算的\",{\"1\":{\"398\":1}}],[\"是怎样实现了\",{\"1\":{\"466\":1}}],[\"是怎样实现的\",{\"1\":{\"359\":1}}],[\"是怎样将当前线程添加到等待队列中去的\",{\"1\":{\"378\":1}}],[\"是绑定在一起的\",{\"1\":{\"377\":1}}],[\"是要和\",{\"1\":{\"377\":1}}],[\"是与对象监视器配合完成线程间的等待\",{\"1\":{\"375\":1}}],[\"是靠\",{\"1\":{\"369\":1}}],[\"是将同步状态\",{\"1\":{\"366\":1}}],[\"是针对获取锁而言的\",{\"1\":{\"360\":1}}],[\"是实现\",{\"1\":{\"358\":1}}],[\"是程序本身可以处理的异常\",{\"1\":{\"297\":1}}],[\"是程序无法处理的错误\",{\"1\":{\"297\":1}}],[\"是无法捕获处理的\",{\"1\":{\"297\":1}}],[\"是指\",{\"1\":{\"277\":1}}],[\"是97\",{\"1\":{\"259\":1}}],[\"是65\",{\"1\":{\"259\":1}}],[\"是条件表达式\",{\"1\":{\"245\":1}}],[\"是每次判断\",{\"1\":{\"243\":1}}],[\"是按照从大到小\",{\"1\":{\"221\":1}}],[\"是帮助数据库高效获取数据的数据结构\",{\"1\":{\"220\":1}}],[\"是分组之后对结果进行过滤\",{\"1\":{\"196\":1}}],[\"是分组之前进行过滤\",{\"1\":{\"196\":1}}],[\"是null\",{\"1\":{\"194\":1}}],[\"是变长字符串\",{\"1\":{\"183\":1}}],[\"是定长字符串\",{\"1\":{\"183\":1}}],[\"是文件名\",{\"1\":{\"158\":1}}],[\"是第二个参数\",{\"1\":{\"158\":1}}],[\"是第一个参数\",{\"1\":{\"158\":1}}],[\"是第一个支持\",{\"1\":{\"134\":1}}],[\"是我们通过命令行与操作系统沟通的语言\",{\"1\":{\"146\":1}}],[\"是存储到\",{\"1\":{\"139\":1}}],[\"是存储\",{\"1\":{\"139\":1}}],[\"是全世界内大家都认可的标准\",{\"1\":{\"134\":1}}],[\"是在全球范围内达到共识的对象存储的协议\",{\"1\":{\"134\":1}}],[\"是\",{\"1\":{\"128\":1,\"133\":1,\"336\":1,\"377\":1,\"421\":1}}],[\"是学习者比较容易上手的一门语言\",{\"1\":{\"65\":1}}],[\"是测试所有\",{\"1\":{\"57\":1}}],[\"是通过判断该节点的\",{\"1\":{\"399\":1}}],[\"是通过\",{\"1\":{\"49\":1,\"393\":1}}],[\"是用来存放\",{\"1\":{\"48\":1}}],[\"是否是树节点\",{\"1\":{\"399\":1}}],[\"是否包含子串str\",{\"1\":{\"324\":1}}],[\"是否包含关键字\",{\"1\":{\"295\":1}}],[\"是否包含某个元素\",{\"1\":{\"294\":1}}],[\"是否为查找的节点\",{\"1\":{\"400\":1}}],[\"是否为空\",{\"1\":{\"291\":1,\"293\":1,\"294\":1,\"295\":1}}],[\"是否为交互题\",{\"1\":{\"46\":1}}],[\"是否存在默认值等信息\",{\"1\":{\"184\":1}}],[\"是否可以为null\",{\"1\":{\"184\":1}}],[\"是否正确返回了评测结果\",{\"1\":{\"49\":1}}],[\"是否需要一个自动部署文档到\",{\"1\":{\"22\":1}}],[\"是你对应文件夹的绝对路径\",{\"1\":{\"35\":1}}],[\"是一个\",{\"1\":{\"516\":1}}],[\"是一个哈希桶数组\",{\"1\":{\"399\":1}}],[\"是一个不可分割的工作单元\",{\"1\":{\"218\":1}}],[\"是一个高性能的分布式对象存储系统\",{\"1\":{\"132\":1}}],[\"是一个生成数据的脚本\",{\"1\":{\"53\":1}}],[\"是一个支持多人协作的出题平台\",{\"1\":{\"44\":1}}],[\"是一个互联工作空间\",{\"1\":{\"41\":1}}],[\"是一个基于\",{\"1\":{\"30\":1}}],[\"是一个参数\",{\"1\":{\"22\":1}}],[\"是一类能够为一种或多种应用程序合作互通\",{\"1\":{\"9\":1}}],[\"是一种乐观锁策略\",{\"1\":{\"448\":1}}],[\"是一种没有重复元素的集合\",{\"1\":{\"328\":1}}],[\"是一种通过哈希函数将键\",{\"1\":{\"226\":1}}],[\"是一种恢复丢失和损坏数据的数学算法\",{\"1\":{\"134\":1}}],[\"是一种数据存储架构\",{\"1\":{\"133\":1}}],[\"是一种应用于分布式系统的基础软件\",{\"1\":{\"9\":1}}],[\"是一种独立的系统软件或服务程序\",{\"1\":{\"9\":1}}],[\"是一种在系统软件和用户应用软件之间连接的软件\",{\"1\":{\"9\":1}}],[\"ncpu\",{\"1\":{\"401\":2}}],[\"nt\",{\"1\":{\"398\":2,\"401\":3,\"402\":3}}],[\"nid=0x6c0\",{\"1\":{\"386\":1}}],[\"nid=0x2b48\",{\"1\":{\"386\":1}}],[\"n为str长度\",{\"1\":{\"324\":2}}],[\"n−41​n=43​n\",{\"1\":{\"398\":1}}],[\"n−2\",{\"1\":{\"243\":1,\"245\":1}}],[\"n−1\",{\"1\":{\"243\":1,\"245\":1,\"359\":1,\"393\":1}}],[\"n\",{\"1\":{\"134\":2,\"221\":2,\"233\":1,\"237\":4,\"239\":14,\"243\":4,\"245\":4,\"247\":3,\"254\":21,\"261\":1,\"266\":1,\"275\":1,\"278\":6,\"304\":1,\"322\":1,\"324\":12,\"325\":2,\"327\":3,\"335\":1,\"359\":4,\"393\":4,\"397\":14,\"398\":7,\"399\":7,\"400\":3,\"401\":24,\"402\":10,\"449\":4}}],[\"nanotime\",{\"1\":{\"520\":5}}],[\"nanostimeout\",{\"1\":{\"375\":1,\"512\":2,\"520\":10}}],[\"nanos\",{\"1\":{\"375\":1,\"386\":3,\"420\":1}}],[\"native\",{\"1\":{\"386\":2,\"421\":1,\"422\":1}}],[\"nas\",{\"1\":{\"134\":1}}],[\"name3=yxc\",{\"1\":{\"151\":1}}],[\"name2=\",{\"1\":{\"151\":1}}],[\"name1=\",{\"1\":{\"151\":1}}],[\"name>\",{\"1\":{\"129\":1}}],[\"name=abc\",{\"1\":{\"153\":1}}],[\"name=yxc\",{\"1\":{\"152\":1,\"153\":1,\"154\":1,\"155\":2,\"156\":1}}],[\"name=\",{\"1\":{\"102\":1,\"104\":1,\"107\":2,\"111\":1,\"112\":1,\"115\":2,\"156\":2,\"189\":1}}],[\"name\",{\"1\":{\"23\":1,\"45\":1,\"77\":2,\"84\":1,\"86\":4,\"91\":2,\"92\":2,\"93\":7,\"96\":2,\"101\":1,\"107\":2,\"115\":2,\"141\":1,\"152\":2,\"153\":2,\"154\":1,\"155\":3,\"156\":2,\"189\":1,\"241\":10,\"260\":1,\"288\":4,\"289\":4,\"310\":5}}],[\"nullpointerexception\",{\"1\":{\"299\":1,\"300\":1,\"399\":1}}],[\"null\",{\"1\":{\"106\":2,\"107\":2,\"114\":2,\"115\":2,\"120\":2,\"121\":2,\"182\":1,\"190\":1,\"194\":1,\"195\":1,\"300\":1,\"304\":1,\"359\":1,\"367\":1,\"369\":1,\"370\":2,\"378\":4,\"379\":8,\"393\":3,\"394\":4,\"398\":2,\"399\":23,\"400\":9,\"401\":16,\"402\":9,\"408\":4,\"488\":1,\"490\":1,\"497\":3,\"508\":1,\"516\":7,\"517\":5,\"518\":7,\"519\":1,\"520\":1,\"522\":1,\"523\":1}}],[\"num\",{\"1\":{\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"101\":1,\"103\":1,\"107\":2,\"185\":2}}],[\"numberformatexception\",{\"1\":{\"300\":1}}],[\"number=0\",{\"1\":{\"77\":1}}],[\"number\",{\"1\":{\"77\":9,\"101\":3,\"107\":3,\"115\":3,\"402\":2}}],[\"number2\",{\"1\":{\"76\":5,\"77\":5}}],[\"number1\",{\"1\":{\"76\":5,\"77\":5}}],[\"negative\",{\"1\":{\"402\":1,\"518\":1}}],[\"negativearraysizeexception\",{\"1\":{\"300\":1}}],[\"needs\",{\"1\":{\"523\":1}}],[\"needing\",{\"1\":{\"518\":1}}],[\"need\",{\"1\":{\"517\":2,\"523\":1}}],[\"needed\",{\"1\":{\"394\":1}}],[\"needwait\",{\"1\":{\"318\":5}}],[\"nextoffset\",{\"1\":{\"409\":2}}],[\"next域为\",{\"1\":{\"408\":1}}],[\"nextbound\",{\"1\":{\"401\":3}}],[\"nextindex\",{\"1\":{\"401\":6}}],[\"nextint\",{\"1\":{\"236\":1,\"239\":13,\"240\":4,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"254\":5,\"276\":2,\"278\":1,\"302\":2,\"303\":1}}],[\"nextn\",{\"1\":{\"401\":2}}],[\"nexttab\",{\"1\":{\"401\":12}}],[\"nexttable\",{\"1\":{\"393\":2,\"394\":3,\"401\":7,\"402\":1}}],[\"nextwaiter\",{\"1\":{\"377\":1,\"378\":2,\"379\":4,\"513\":1}}],[\"nextc\",{\"1\":{\"359\":3,\"360\":3,\"367\":4,\"370\":3}}],[\"nextline\",{\"1\":{\"236\":1,\"260\":1,\"261\":1}}],[\"nextdouble\",{\"1\":{\"236\":1}}],[\"nextfloat\",{\"1\":{\"236\":1}}],[\"next\",{\"1\":{\"85\":3,\"86\":3,\"92\":3,\"93\":3,\"236\":1,\"261\":1,\"379\":2,\"394\":3,\"399\":4,\"400\":1,\"401\":6,\"408\":2,\"513\":1,\"516\":3,\"517\":3,\"518\":2,\"519\":1,\"520\":1,\"522\":1}}],[\"net\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"413\":1}}],[\"newstring\",{\"1\":{\"269\":2}}],[\"newcondition\",{\"1\":{\"377\":2,\"381\":1,\"505\":1,\"508\":3}}],[\"newchar\",{\"1\":{\"260\":1,\"324\":1}}],[\"newvalue\",{\"1\":{\"329\":1,\"336\":1}}],[\"newinstance\",{\"1\":{\"300\":1,\"310\":2}}],[\"newarray\",{\"1\":{\"269\":2}}],[\"newregex\",{\"1\":{\"260\":1}}],[\"newline=\",{\"1\":{\"77\":1,\"86\":1,\"93\":1}}],[\"new\",{\"1\":{\"45\":1,\"142\":4,\"236\":3,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":1,\"245\":1,\"247\":1,\"252\":4,\"253\":1,\"254\":6,\"255\":2,\"261\":1,\"262\":1,\"273\":1,\"276\":1,\"278\":1,\"284\":2,\"289\":2,\"293\":1,\"302\":2,\"303\":3,\"304\":4,\"310\":3,\"314\":9,\"316\":3,\"317\":6,\"318\":4,\"324\":4,\"325\":1,\"327\":4,\"328\":3,\"329\":4,\"330\":2,\"331\":1,\"332\":1,\"333\":4,\"349\":4,\"359\":2,\"360\":4,\"366\":1,\"367\":1,\"375\":1,\"377\":2,\"378\":3,\"379\":1,\"381\":5,\"387\":1,\"393\":1,\"397\":2,\"398\":2,\"399\":4,\"401\":8,\"408\":1,\"412\":1,\"413\":4,\"419\":2,\"420\":1,\"423\":2,\"441\":2,\"442\":1,\"461\":2,\"466\":1,\"470\":2,\"479\":1,\"487\":1,\"488\":2,\"490\":1,\"494\":2,\"497\":2,\"504\":1,\"507\":1,\"508\":5,\"516\":3,\"519\":2,\"520\":2,\"523\":1}}],[\"npx\",{\"1\":{\"23\":1}}],[\"npm\",{\"1\":{\"22\":2,\"23\":2,\"26\":1,\"34\":2,\"35\":2}}],[\"normally\",{\"1\":{\"518\":1}}],[\"non\",{\"1\":{\"369\":1,\"402\":1,\"518\":1}}],[\"nonzero\",{\"1\":{\"366\":3}}],[\"nonfairsync\",{\"1\":{\"360\":2,\"507\":3}}],[\"nonfairtryacquire\",{\"1\":{\"359\":2,\"360\":2,\"507\":1}}],[\"none\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2}}],[\"nosuchmethodexception\",{\"1\":{\"300\":1,\"310\":1}}],[\"nosuchfieldexception\",{\"1\":{\"300\":1,\"303\":4,\"310\":1}}],[\"noargsconstructor\",{\"1\":{\"198\":1}}],[\"nohup\",{\"1\":{\"126\":1}}],[\"nohub\",{\"1\":{\"126\":1}}],[\"now\",{\"1\":{\"67\":1,\"370\":1}}],[\"node0\",{\"1\":{\"408\":1}}],[\"node<e>\",{\"1\":{\"408\":5,\"409\":3}}],[\"node<\",{\"1\":{\"398\":1,\"401\":2}}],[\"node<k\",{\"1\":{\"393\":2,\"394\":7,\"395\":8,\"398\":4,\"399\":11,\"400\":2,\"401\":14,\"402\":1}}],[\"nodes\",{\"1\":{\"394\":1,\"399\":1}}],[\"nodejs\",{\"1\":{\"34\":1}}],[\"node\",{\"0\":{\"30\":1,\"408\":1,\"409\":1},\"1\":{\"30\":1,\"34\":7,\"35\":2,\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1,\"377\":8,\"378\":34,\"379\":13,\"393\":1,\"394\":3,\"395\":1,\"398\":1,\"399\":3,\"401\":1,\"403\":4,\"408\":2,\"409\":1,\"507\":1,\"513\":5,\"515\":1,\"516\":31,\"517\":15,\"518\":11,\"519\":8,\"520\":8,\"522\":8,\"523\":5},\"2\":{\"36\":1}}],[\"note\",{\"1\":{\"366\":1,\"369\":1}}],[\"notebook\",{\"1\":{\"99\":5},\"2\":{\"72\":1,\"123\":1}}],[\"notift\",{\"1\":{\"421\":1}}],[\"notifyall\",{\"1\":{\"318\":1,\"375\":4,\"417\":1,\"420\":1,\"421\":1}}],[\"notify\",{\"0\":{\"318\":1},\"1\":{\"375\":4,\"417\":1}}],[\"notion\",{\"0\":{\"41\":1},\"1\":{\"39\":1,\"41\":1},\"2\":{\"42\":1}}],[\"not\",{\"1\":{\"23\":1,\"76\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"176\":3,\"182\":1,\"194\":1,\"212\":1,\"213\":1,\"241\":1,\"369\":3,\"523\":1,\"527\":1}}],[\"no\",{\"1\":{\"22\":1,\"239\":2,\"240\":1,\"247\":1,\"370\":1,\"399\":1,\"469\":1}}],[\"设计者的角度\",{\"1\":{\"435\":1}}],[\"设计了\",{\"1\":{\"403\":1}}],[\"设计和使用哈希表时需要仔细考虑哈希函数的选择\",{\"1\":{\"228\":1}}],[\"设计模式\",{\"0\":{\"8\":1,\"538\":1},\"2\":{\"343\":1}}],[\"设置节点状态位为\",{\"1\":{\"517\":1}}],[\"设置失败则说明\",{\"1\":{\"517\":1}}],[\"设置成\",{\"1\":{\"517\":1}}],[\"设置成了\",{\"1\":{\"470\":1}}],[\"设置\",{\"1\":{\"497\":1}}],[\"设置为新容量的\",{\"1\":{\"401\":1}}],[\"设置advance为true\",{\"1\":{\"401\":1}}],[\"设置别名\",{\"1\":{\"193\":1}}],[\"设置该存储桶里面的文件的访问策略\",{\"1\":{\"141\":1}}],[\"设置热力图\",{\"1\":{\"102\":1}}],[\"设置鼠标放置旁边时\",{\"1\":{\"102\":1,\"103\":1,\"112\":1}}],[\"设置标签\",{\"1\":{\"44\":1}}],[\"设置全局模块的安装路径到\",{\"1\":{\"35\":1}}],[\"设置缓存到\",{\"1\":{\"35\":1}}],[\"设置协议\",{\"1\":{\"22\":1}}],[\"你真的了解\",{\"0\":{\"473\":1}}],[\"你现在的值都是旧的了\",{\"1\":{\"468\":1}}],[\"你妈喊你回家吃饭了\",{\"1\":{\"428\":1}}],[\"你在网上付款下单后\",{\"1\":{\"351\":1}}],[\"你在搜索公司名称时\",{\"1\":{\"89\":1}}],[\"你才能继续去收银台付款\",{\"1\":{\"351\":1}}],[\"你得等仓库人员跟你调货\",{\"1\":{\"351\":1}}],[\"你可以继续执行其他命令\",{\"1\":{\"126\":1}}],[\"你可以更改此参数来使用一个新文件夹名称\",{\"1\":{\"22\":1}}],[\"你的终端或\",{\"1\":{\"126\":1}}],[\"你的网站将会被发布到\",{\"1\":{\"27\":1}}],[\"你需要下载并安装最新的长期维护版\",{\"1\":{\"30\":1}}],[\"你想要创建什么类型的项目\",{\"1\":{\"22\":1}}],[\"你应该在页面\",{\"1\":{\"1\":1}}],[\"这句话比较抽象\",{\"1\":{\"508\":1}}],[\"这句话是比较拗口的\",{\"1\":{\"488\":1}}],[\"这三个方法\",{\"1\":{\"506\":1,\"508\":1}}],[\"这三种操作都是存在数据依赖性的\",{\"1\":{\"430\":1}}],[\"这并不是一个原子操作\",{\"1\":{\"494\":1}}],[\"这显然是错误的操作\",{\"1\":{\"487\":1}}],[\"这条语句实际上包含了三个操作\",{\"1\":{\"497\":1}}],[\"这条禁止重排序规则就是针对这些处理器而设定的\",{\"1\":{\"487\":1}}],[\"这条命令的stdout\",{\"1\":{\"159\":1}}],[\"这几个状态会随着竞争情况逐渐升级\",{\"1\":{\"452\":1}}],[\"这几次尝试中\",{\"1\":{\"403\":1}}],[\"这么优秀的语言\",{\"1\":{\"451\":1}}],[\"这么做的目的\",{\"1\":{\"432\":1}}],[\"这么做的原因是\",{\"1\":{\"432\":1}}],[\"这只是\",{\"1\":{\"432\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行的\",{\"1\":{\"430\":1}}],[\"这其中有一个问题\",{\"1\":{\"429\":1}}],[\"这其中的关系应该是多核\",{\"1\":{\"346\":1}}],[\"这也是添加\",{\"1\":{\"443\":1}}],[\"这也是面试经常被问的地方\",{\"1\":{\"421\":1}}],[\"这也是注释\",{\"1\":{\"148\":1}}],[\"这会创建一个新线程来执行\",{\"1\":{\"413\":1}}],[\"这下也正好验证了我们在最上面介绍时说的\",{\"1\":{\"399\":1}}],[\"这部分代码为\",{\"1\":{\"399\":1}}],[\"这部分代码很好理解\",{\"1\":{\"399\":1}}],[\"这部分是将标准错误输出\",{\"1\":{\"126\":1}}],[\"这部分是将标准输出\",{\"1\":{\"126\":1}}],[\"这时让\",{\"1\":{\"401\":1}}],[\"这时\",{\"1\":{\"381\":1}}],[\"这段方法跟独占式锁释放过程有点点不同\",{\"1\":{\"523\":1}}],[\"这段方法与上面的\",{\"1\":{\"378\":1}}],[\"这段源码的逻辑也很容易理解\",{\"1\":{\"522\":1}}],[\"这段代码逻辑就比较容易理解了\",{\"1\":{\"518\":1}}],[\"这段代码主要做了两件事情\",{\"1\":{\"379\":1}}],[\"这段代码调用\",{\"1\":{\"378\":1}}],[\"这段代码就很容易理解了\",{\"1\":{\"378\":1}}],[\"这段代码就不展开说了\",{\"1\":{\"369\":1}}],[\"这段代码没有任何实际意义\",{\"1\":{\"377\":1}}],[\"这段代码的逻辑请看注释\",{\"1\":{\"366\":1,\"397\":1}}],[\"这段代码的逻辑与\",{\"1\":{\"360\":1}}],[\"这段代码的逻辑也很简单\",{\"1\":{\"359\":1}}],[\"这两个操作是不能被重排序的\",{\"1\":{\"488\":1}}],[\"这两个方法的实现原理\",{\"1\":{\"378\":1}}],[\"这两段代码已经解决了前面的两个问题的答案了\",{\"1\":{\"378\":1}}],[\"这是两者主要的区别\",{\"1\":{\"449\":1}}],[\"这是两者的一个区别\",{\"1\":{\"378\":1}}],[\"这是理解下面知识的前提条件\",{\"1\":{\"446\":1}}],[\"这是为什么\",{\"1\":{\"441\":1}}],[\"这是当前线程退出\",{\"1\":{\"378\":1}}],[\"这是一种乐观策略\",{\"1\":{\"393\":1}}],[\"这是一行注释\",{\"1\":{\"148\":1}}],[\"这是一个计算圆面积的代码\",{\"1\":{\"430\":1}}],[\"这是一个静态方法\",{\"1\":{\"422\":1}}],[\"这是一个很底层的类\",{\"1\":{\"386\":1}}],[\"这是一个\",{\"1\":{\"126\":1}}],[\"这是一个档案主页的案例\",{\"1\":{\"1\":1}}],[\"这就像线程\",{\"1\":{\"445\":1}}],[\"这就像两个好基友\",{\"1\":{\"420\":1}}],[\"这就是使用\",{\"1\":{\"507\":1}}],[\"这就是锁的重入性\",{\"1\":{\"443\":1}}],[\"这就是需要禁止重排序\",{\"1\":{\"437\":1}}],[\"这就是数据可见性的问题\",{\"1\":{\"437\":1}}],[\"这就出现了\",{\"1\":{\"429\":1}}],[\"这就类似同步调用\",{\"1\":{\"351\":1}}],[\"这就意味着个人也可以基于\",{\"1\":{\"133\":1}}],[\"这些就是\",{\"1\":{\"503\":1}}],[\"这些代码在\",{\"1\":{\"503\":1}}],[\"这些优化既不会改变程序的执行结果\",{\"1\":{\"435\":1}}],[\"这些重排序会导致线程安全的问题\",{\"1\":{\"430\":1}}],[\"这些方法实际上是利用了\",{\"1\":{\"393\":1}}],[\"这些是检查型异常\",{\"1\":{\"299\":1}}],[\"这些异常一般是由程序逻辑错误引起的\",{\"1\":{\"299\":1}}],[\"这些异常是非检查型异常\",{\"1\":{\"299\":1}}],[\"这些异常发生时\",{\"1\":{\"297\":1}}],[\"这些数组的元素是含有30个整数的数组\",{\"1\":{\"255\":1}}],[\"这可能需要重新哈希和复制整个表\",{\"1\":{\"228\":1}}],[\"这可能导致空间的浪费\",{\"1\":{\"228\":1}}],[\"这种锁升级却不能降级的策略\",{\"1\":{\"452\":1}}],[\"这种优化方式同样可以引申到锁优化上\",{\"1\":{\"446\":1}}],[\"这种形式不能改变的话\",{\"1\":{\"446\":1}}],[\"这种形式拼接字符串\",{\"1\":{\"323\":1}}],[\"这种线程间的通信机制正好吻合\",{\"1\":{\"445\":1}}],[\"这种同步机制效率很低\",{\"1\":{\"441\":1}}],[\"这种操作是不安全的\",{\"1\":{\"423\":1}}],[\"这种方式肯定效率低下\",{\"1\":{\"446\":1}}],[\"这种方式就是通知机制来完成协作\",{\"1\":{\"428\":1}}],[\"这种方式要优雅和安全\",{\"1\":{\"419\":1}}],[\"这种方式代替了锁\",{\"1\":{\"403\":1}}],[\"这种方式不安全\",{\"1\":{\"169\":1}}],[\"这种方案的性能也是令人不太满意的\",{\"1\":{\"391\":1}}],[\"这种信息就类似于记录\",{\"1\":{\"386\":1}}],[\"这种情况就是阻塞\",{\"1\":{\"353\":1}}],[\"这种现象\",{\"1\":{\"346\":1}}],[\"这种现象称为冲突\",{\"1\":{\"226\":1}}],[\"这种设计模式就称为单例模式\",{\"1\":{\"342\":1}}],[\"这种异常分两大类运行时异常和非运行时异常\",{\"1\":{\"297\":1}}],[\"这种子查询称为表子查询\",{\"1\":{\"214\":1}}],[\"这种子查询称为行子查询\",{\"1\":{\"213\":1}}],[\"这种子查询称为列子查询\",{\"1\":{\"212\":1}}],[\"这种子查询称为标量子查询\",{\"1\":{\"211\":1}}],[\"这种机制使得即使部分磁盘发生故障\",{\"1\":{\"134\":1}}],[\"这个例子也是来源于\",{\"1\":{\"508\":1}}],[\"这个规则仅仅是针对处理器\",{\"1\":{\"487\":1}}],[\"这个规则的实现主要包含了两个方面\",{\"1\":{\"487\":1}}],[\"这个屏障可以禁止处理器把\",{\"1\":{\"487\":1}}],[\"这个引用的对象能够改变吗\",{\"1\":{\"479\":1}}],[\"这个写回内存的操作会使得其他\",{\"1\":{\"466\":1}}],[\"这个时机对普通变量是没有规定的\",{\"1\":{\"465\":1}}],[\"这个时候引用对象\",{\"1\":{\"490\":1}}],[\"这个时候就是最新的值\",{\"1\":{\"445\":1}}],[\"这个时候只打印了\",{\"1\":{\"423\":1}}],[\"这个时候产品\",{\"1\":{\"420\":1}}],[\"这个时候他就会在原处等一等这个基友\",{\"1\":{\"420\":1}}],[\"这个时候其他线程在\",{\"1\":{\"398\":1}}],[\"这个过程是比较耗时的\",{\"1\":{\"446\":1}}],[\"这个线程会进入等待状态\",{\"1\":{\"415\":1}}],[\"这个线程安全的队列\",{\"1\":{\"407\":1}}],[\"这个\",{\"1\":{\"402\":1}}],[\"这个也是触发并发扩容的关键点\",{\"1\":{\"401\":1}}],[\"这个操作是单线程完成的\",{\"1\":{\"401\":1}}],[\"这个方法的作用就是排队获取锁的过程\",{\"1\":{\"516\":1}}],[\"这个方法的基本思想跟\",{\"1\":{\"401\":1}}],[\"这个方法显然是\",{\"1\":{\"421\":1}}],[\"这个方法一共做了两件事\",{\"1\":{\"402\":1}}],[\"这个方法在介绍\",{\"1\":{\"378\":1}}],[\"这个类并不负责包装用户的\",{\"1\":{\"394\":1}}],[\"这个类就是一个单例类\",{\"1\":{\"342\":1}}],[\"这个set中包含map中所有的key\",{\"1\":{\"329\":1}}],[\"这个消息在throwable\",{\"1\":{\"301\":1}}],[\"这个抽象的概念\",{\"1\":{\"280\":1}}],[\"这个哈希值是一个整数\",{\"1\":{\"226\":1}}],[\"这个符号是在命令的末尾\",{\"1\":{\"126\":1}}],[\"这个页面是用来运行\",{\"1\":{\"55\":1}}],[\"这个页面是用来放解这道题的代码的\",{\"1\":{\"54\":1}}],[\"这个页面是用来对拍的\",{\"1\":{\"53\":1}}],[\"这个页面是用来管理数据的\",{\"1\":{\"52\":1}}],[\"这个页面是用来写题面和题解的\",{\"1\":{\"47\":1}}],[\"这样在\",{\"1\":{\"470\":1}}],[\"这样在多线程竞争的条件下\",{\"1\":{\"348\":1}}],[\"这样针对\",{\"1\":{\"466\":1}}],[\"这样就可以方便的实现不同类型的同步组件\",{\"1\":{\"506\":1}}],[\"这样就可能出现错误\",{\"1\":{\"487\":1}}],[\"这样就能保证每个线程所获得共享变量的值都是当前最新的值\",{\"1\":{\"461\":1}}],[\"这样就不会有任何数据安全的问题\",{\"1\":{\"441\":1}}],[\"这样它们就可以做尽可能多的优化来提高性能\",{\"1\":{\"435\":1}}],[\"这样我们就可以根据规则去推论跨线程的内存可见性问题\",{\"1\":{\"431\":1}}],[\"这样存的话我反过来这么取就好了\",{\"1\":{\"400\":1}}],[\"这样不仅能够使得\",{\"1\":{\"399\":1}}],[\"这样的异常\",{\"1\":{\"423\":1}}],[\"这样的并发性能的确不令人满意\",{\"1\":{\"391\":1}}],[\"这样的设计\",{\"1\":{\"134\":1}}],[\"这样也说明了退出\",{\"1\":{\"378\":1}}],[\"这样会造成大量的线程都处于等待状态\",{\"1\":{\"348\":1}}],[\"这样宽度就会增加从而降低树的高度\",{\"1\":{\"221\":1}}],[\"这样确实比之前的方式快了很多\",{\"1\":{\"221\":1}}],[\"这样\",{\"1\":{\"126\":1,\"461\":1}}],[\"这意味着\",{\"1\":{\"126\":1}}],[\"这里采用的\",{\"1\":{\"523\":1}}],[\"这里不仅仅值锁\",{\"1\":{\"507\":1}}],[\"这里为什么要加\",{\"1\":{\"497\":1}}],[\"这里我就只把结果说出来\",{\"1\":{\"466\":1}}],[\"这里能够计算出正确的结果是因为在做累加操作时使用了同步代码块\",{\"1\":{\"461\":1}}],[\"这里存在这样一个有意思的问题\",{\"1\":{\"451\":1}}],[\"这里存在一个问题\",{\"1\":{\"399\":1}}],[\"这里就存在三种情况\",{\"1\":{\"430\":1}}],[\"这里就不过多赘述\",{\"1\":{\"111\":1}}],[\"这里是控制并发扩容的核心\",{\"1\":{\"401\":1}}],[\"这里在\",{\"1\":{\"398\":1}}],[\"这里\",{\"1\":{\"398\":1}}],[\"这里才真正的初始化数组\",{\"1\":{\"398\":1}}],[\"这里将这些方法做一个总结\",{\"1\":{\"386\":1}}],[\"这里需要注意的是守护线程在退出的时候并不会执行\",{\"1\":{\"423\":1}}],[\"这里需要注意的是\",{\"1\":{\"367\":1}}],[\"这里有一个地方需要重点关注\",{\"1\":{\"366\":1}}],[\"这里简单做个小结\",{\"1\":{\"364\":1}}],[\"这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且\",{\"1\":{\"522\":1}}],[\"这里的2\",{\"1\":{\"467\":1}}],[\"这里的需要注意的是\",{\"1\":{\"442\":1}}],[\"这里的第三个关系是利用传递性进行推论的\",{\"1\":{\"433\":1}}],[\"这里的线程指的是并发执行的活动实体\",{\"1\":{\"428\":1}}],[\"这里的dit\",{\"1\":{\"84\":1}}],[\"这里的\",{\"1\":{\"22\":1}}],[\"这边x\",{\"1\":{\"111\":1}}],[\"这组数据就会成为样例\",{\"1\":{\"52\":1}}],[\"mutextdemo\",{\"1\":{\"508\":1}}],[\"mutexdemo\",{\"1\":{\"508\":2}}],[\"mutex\",{\"1\":{\"391\":1,\"508\":9}}],[\"must\",{\"1\":{\"371\":1,\"516\":1,\"517\":1,\"523\":1}}],[\"m为原串长度\",{\"1\":{\"324\":2}}],[\"more\",{\"1\":{\"369\":1,\"402\":1}}],[\"moved\",{\"1\":{\"394\":1,\"399\":6,\"401\":1,\"403\":1}}],[\"move\",{\"1\":{\"286\":1,\"288\":2,\"289\":2}}],[\"monitordemo\",{\"1\":{\"444\":1}}],[\"monitorexit\",{\"1\":{\"443\":2,\"494\":1}}],[\"monitorenter\",{\"1\":{\"443\":2,\"494\":1}}],[\"monitor\",{\"0\":{\"443\":1},\"1\":{\"349\":2,\"443\":3,\"446\":1,\"452\":1}}],[\"money\",{\"1\":{\"260\":3}}],[\"monday\",{\"1\":{\"241\":1}}],[\"mode\",{\"1\":{\"516\":2}}],[\"mode=\",{\"1\":{\"77\":1,\"86\":1,\"93\":1,\"129\":1}}],[\"modcount\",{\"1\":{\"403\":1}}],[\"modify\",{\"1\":{\"185\":1}}],[\"module\",{\"1\":{\"23\":1}}],[\"mm\",{\"1\":{\"183\":6}}],[\"metadata\",{\"1\":{\"306\":1}}],[\"method\",{\"1\":{\"142\":2,\"310\":5,\"386\":2,\"402\":1,\"443\":2}}],[\"mediumtext\",{\"1\":{\"183\":1}}],[\"mediumblob\",{\"1\":{\"183\":1}}],[\"mediumint\",{\"1\":{\"183\":1}}],[\"merge\",{\"1\":{\"75\":2}}],[\"mermaid\",{\"1\":{\"23\":1}}],[\"mnt\",{\"1\":{\"126\":3,\"127\":1}}],[\"make\",{\"1\":{\"517\":1}}],[\"makebucketargs\",{\"1\":{\"141\":1}}],[\"makebucket\",{\"1\":{\"141\":2}}],[\"may\",{\"1\":{\"370\":1,\"402\":2}}],[\"mask\",{\"1\":{\"366\":4}}],[\"math\",{\"0\":{\"335\":1},\"1\":{\"335\":14}}],[\"match\",{\"1\":{\"76\":2,\"77\":2}}],[\"manipulation\",{\"1\":{\"172\":1,\"187\":1}}],[\"manually\",{\"1\":{\"70\":1}}],[\"mappings\",{\"1\":{\"402\":3}}],[\"mappingcount\",{\"1\":{\"402\":4}}],[\"map<\",{\"1\":{\"397\":1}}],[\"map<character\",{\"1\":{\"329\":3}}],[\"map<characters\",{\"1\":{\"329\":1}}],[\"map<k\",{\"1\":{\"295\":1,\"391\":2}}],[\"map中的对象类型\",{\"1\":{\"295\":1}}],[\"map\",{\"0\":{\"295\":1,\"329\":1},\"1\":{\"102\":5,\"104\":2,\"105\":1,\"107\":9,\"111\":6,\"113\":1,\"115\":8,\"295\":1,\"329\":10,\"391\":2,\"394\":2}}],[\"maximum\",{\"1\":{\"359\":1,\"360\":1,\"366\":1,\"397\":4,\"402\":1}}],[\"maxheap\",{\"1\":{\"333\":1}}],[\"max\",{\"1\":{\"102\":2,\"103\":1,\"104\":1,\"107\":4,\"111\":1,\"115\":1,\"195\":2,\"276\":2,\"277\":6,\"335\":1,\"336\":1,\"338\":8,\"366\":1,\"369\":1,\"401\":1,\"402\":3}}],[\"maxnum\",{\"1\":{\"101\":1,\"102\":1,\"107\":2}}],[\"maxsalary\",{\"1\":{\"77\":4}}],[\"main\",{\"1\":{\"86\":1,\"93\":1,\"107\":1,\"115\":1,\"233\":2,\"235\":6,\"236\":4,\"237\":4,\"239\":18,\"240\":4,\"241\":2,\"243\":8,\"244\":2,\"245\":8,\"247\":2,\"248\":2,\"249\":4,\"252\":2,\"253\":2,\"254\":8,\"255\":4,\"256\":2,\"259\":4,\"261\":2,\"266\":2,\"269\":2,\"270\":2,\"272\":2,\"273\":2,\"275\":2,\"276\":2,\"277\":2,\"278\":2,\"284\":2,\"289\":2,\"302\":2,\"303\":2,\"304\":2,\"310\":2,\"314\":4,\"316\":2,\"317\":4,\"318\":2,\"349\":1,\"377\":1,\"381\":1,\"386\":4,\"387\":2,\"413\":3,\"419\":3,\"420\":2,\"423\":6,\"441\":1,\"443\":1,\"461\":1,\"470\":2,\"479\":1,\"494\":1,\"508\":1}}],[\"mark\",{\"1\":{\"452\":5,\"454\":2,\"455\":1,\"458\":3,\"459\":1}}],[\"markpointitem\",{\"1\":{\"103\":1,\"107\":1}}],[\"markpointopts\",{\"1\":{\"103\":1,\"107\":1}}],[\"markpoint\",{\"1\":{\"103\":1,\"107\":1}}],[\"markdown\",{\"1\":{\"47\":1}}],[\"markmap\",{\"1\":{\"23\":3}}],[\"m\",{\"1\":{\"26\":1,\"324\":4,\"335\":1,\"391\":2,\"397\":1,\"402\":3}}],[\"md\",{\"1\":{\"23\":1}}],[\"millis\",{\"1\":{\"420\":2,\"421\":1}}],[\"misc\",{\"1\":{\"386\":3,\"393\":3,\"402\":1,\"409\":1}}],[\"might\",{\"1\":{\"371\":1}}],[\"mirrors\",{\"1\":{\"125\":1}}],[\"minheap\",{\"1\":{\"333\":1}}],[\"minutes\",{\"1\":{\"142\":1}}],[\"minioinfo\",{\"1\":{\"139\":6}}],[\"minio密码\",{\"1\":{\"139\":1}}],[\"minio用户名\",{\"1\":{\"139\":1}}],[\"minioclient\",{\"0\":{\"140\":1},\"1\":{\"139\":8,\"141\":6,\"142\":9}}],[\"minio<\",{\"1\":{\"138\":1}}],[\"minio官网\",{\"1\":{\"132\":1}}],[\"minioadmin\",{\"1\":{\"126\":1,\"128\":1,\"139\":2}}],[\"minio\",{\"0\":{\"125\":1,\"132\":1,\"137\":1},\"1\":{\"125\":3,\"126\":24,\"127\":8,\"128\":10,\"129\":8,\"132\":2,\"133\":4,\"134\":22,\"139\":10,\"142\":3},\"2\":{\"131\":1,\"136\":1,\"144\":1}}],[\"min\",{\"0\":{\"529\":1},\"1\":{\"102\":2,\"107\":2,\"111\":1,\"115\":1,\"128\":1,\"132\":1,\"195\":2,\"335\":1,\"336\":1,\"338\":8,\"401\":2}}],[\"minnum\",{\"1\":{\"101\":1,\"102\":1,\"107\":2}}],[\"minsalary\",{\"1\":{\"77\":4}}],[\"mikemirzayanov\",{\"1\":{\"49\":1}}],[\"mit\",{\"1\":{\"22\":1,\"23\":1}}],[\"middleware\",{\"1\":{\"9\":1}}],[\"mysql中有两种方式进行事务的操作\",{\"1\":{\"217\":1}}],[\"mysql中的数据类型主要分为三类\",{\"1\":{\"183\":1}}],[\"mysql数据库为解决id问题\",{\"1\":{\"182\":1}}],[\"mysql特有\",{\"1\":{\"171\":1}}],[\"mysql服务器启动完毕后\",{\"1\":{\"169\":1}}],[\"mysql\",{\"0\":{\"167\":1},\"1\":{\"169\":3,\"171\":1,\"198\":1,\"217\":1,\"221\":3},\"2\":{\"223\":1}}],[\"myfile2\",{\"1\":{\"141\":2}}],[\"myfile目录是否存在\",{\"1\":{\"141\":1}}],[\"myfile\",{\"1\":{\"141\":1,\"142\":7}}],[\"my\",{\"0\":{\"533\":1},\"1\":{\"22\":3,\"176\":1,\"260\":3,\"310\":1}}],[\"dmin\",{\"1\":{\"338\":1}}],[\"dmax\",{\"1\":{\"338\":1}}],[\"dml英文全称是\",{\"1\":{\"187\":1}}],[\"dml\",{\"0\":{\"187\":1},\"1\":{\"172\":2}}],[\"dump\",{\"1\":{\"386\":5}}],[\"durability\",{\"1\":{\"218\":2}}],[\"duplicates\",{\"1\":{\"75\":1}}],[\"db01\",{\"1\":{\"178\":1}}],[\"dql\",{\"0\":{\"191\":1},\"1\":{\"172\":2,\"192\":1,\"193\":1}}],[\"dl\",{\"1\":{\"126\":1,\"128\":1}}],[\"daemodthread\",{\"1\":{\"423\":1}}],[\"daemonthread\",{\"1\":{\"423\":6}}],[\"daemondemo\",{\"1\":{\"423\":3}}],[\"daemon\",{\"0\":{\"423\":1},\"1\":{\"423\":1}}],[\"day\",{\"1\":{\"241\":2}}],[\"datetime\",{\"1\":{\"183\":1}}],[\"date\",{\"1\":{\"183\":1,\"375\":1}}],[\"database\",{\"1\":{\"175\":2,\"176\":3,\"178\":3}}],[\"databases\",{\"1\":{\"175\":1}}],[\"data=bar\",{\"1\":{\"104\":1,\"107\":1}}],[\"data=\",{\"1\":{\"103\":1,\"107\":1}}],[\"data\",{\"1\":{\"77\":3,\"84\":3,\"85\":4,\"86\":7,\"91\":4,\"92\":5,\"93\":9,\"96\":6,\"101\":6,\"102\":12,\"104\":6,\"107\":23,\"111\":5,\"112\":5,\"115\":15,\"126\":7,\"127\":1,\"128\":2,\"129\":1,\"139\":1,\"172\":4,\"174\":1,\"187\":1,\"198\":1,\"371\":2}}],[\"dataframe\",{\"1\":{\"75\":1}}],[\"das\",{\"1\":{\"134\":1}}],[\"dark\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1}}],[\"dcl等这些问题\",{\"1\":{\"349\":1}}],[\"dcl\",{\"1\":{\"172\":2,\"430\":1,\"437\":1}}],[\"dc\",{\"1\":{\"96\":3}}],[\"ddl\",{\"0\":{\"173\":1},\"1\":{\"172\":2,\"174\":2}}],[\"ddd\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"dd\",{\"1\":{\"95\":2,\"183\":3}}],[\"drissionpage\",{\"1\":{\"77\":1,\"86\":1,\"93\":1,\"96\":1},\"2\":{\"97\":1}}],[\"drop\",{\"1\":{\"75\":1,\"178\":2,\"185\":1,\"186\":1,\"222\":1}}],[\"differ\",{\"1\":{\"402\":1}}],[\"different\",{\"1\":{\"366\":1}}],[\"did\",{\"1\":{\"371\":1}}],[\"displaced\",{\"1\":{\"458\":1,\"459\":1}}],[\"distributing\",{\"1\":{\"402\":1}}],[\"distinct\",{\"1\":{\"193\":1}}],[\"disabled\",{\"1\":{\"85\":1}}],[\"disable\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":1}}],[\"dimension=0\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"div\",{\"1\":{\"96\":5}}],[\"divs\",{\"1\":{\"96\":2}}],[\"dit\",{\"1\":{\"84\":2,\"86\":2,\"91\":4,\"93\":4,\"96\":2}}],[\"dictwriter\",{\"1\":{\"77\":1,\"86\":1,\"93\":1}}],[\"dict\",{\"1\":{\"76\":1,\"77\":3}}],[\"dir\",{\"1\":{\"22\":3,\"35\":3}}],[\"d+\",{\"1\":{\"76\":4,\"77\":4}}],[\"df\",{\"1\":{\"75\":4,\"77\":2,\"101\":2,\"107\":2,\"115\":2,\"118\":2,\"121\":2}}],[\"df2\",{\"1\":{\"75\":2}}],[\"df1\",{\"1\":{\"75\":2}}],[\"d\",{\"1\":{\"71\":1,\"102\":3,\"107\":3,\"111\":3,\"112\":3,\"115\":6,\"128\":2,\"142\":3,\"233\":1,\"237\":1,\"239\":25,\"249\":1,\"252\":1,\"253\":1,\"254\":5,\"255\":1,\"256\":1,\"260\":2,\"266\":1,\"275\":2,\"282\":2,\"283\":2,\"324\":3}}],[\"doing\",{\"1\":{\"523\":1}}],[\"doreleaseshared\",{\"1\":{\"523\":3}}],[\"doacquireshared\",{\"1\":{\"522\":3}}],[\"doacquirenanos\",{\"1\":{\"520\":3}}],[\"doacquireinterruptibly\",{\"1\":{\"519\":3}}],[\"don\",{\"1\":{\"517\":1}}],[\"donaldervinknuth\",{\"1\":{\"346\":1}}],[\"doug\",{\"1\":{\"503\":1}}],[\"douglea\",{\"1\":{\"391\":1,\"407\":1}}],[\"double\",{\"1\":{\"183\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"252\":2,\"260\":2,\"277\":4,\"338\":2,\"430\":3,\"494\":1,\"497\":1}}],[\"dosignalall\",{\"1\":{\"379\":3}}],[\"dosignal\",{\"1\":{\"379\":5}}],[\"downgrade\",{\"1\":{\"371\":1}}],[\"download\",{\"1\":{\"68\":1,\"125\":1}}],[\"does\",{\"1\":{\"369\":1,\"508\":1,\"523\":1}}],[\"do\",{\"0\":{\"244\":1},\"1\":{\"244\":4,\"379\":2,\"517\":1}}],[\"document\",{\"1\":{\"308\":1}}],[\"docs\",{\"1\":{\"22\":4,\"23\":5,\"26\":2,\"134\":1,\"402\":1}}],[\"docker\",{\"0\":{\"11\":1,\"127\":1},\"1\":{\"127\":4}}],[\"docker等等\",{\"1\":{\"2\":1}}],[\"deserializes\",{\"1\":{\"508\":1}}],[\"desired\",{\"1\":{\"397\":1}}],[\"desc\",{\"1\":{\"184\":1,\"197\":1}}],[\"description>\",{\"1\":{\"129\":1}}],[\"description\",{\"1\":{\"23\":1}}],[\"debug\",{\"1\":{\"377\":3}}],[\"deadline\",{\"1\":{\"375\":1,\"386\":3,\"520\":5}}],[\"deadlock\",{\"1\":{\"349\":3}}],[\"deadlockdemo$1\",{\"1\":{\"349\":1}}],[\"deadlockdemo$2\",{\"1\":{\"349\":1}}],[\"deadlockdemo\",{\"1\":{\"349\":3}}],[\"demo\",{\"1\":{\"349\":1,\"377\":1,\"443\":2,\"487\":3}}],[\"deque接口\",{\"1\":{\"330\":1}}],[\"deque<e>\",{\"1\":{\"330\":1,\"332\":1}}],[\"deque\",{\"0\":{\"332\":1},\"1\":{\"330\":3,\"332\":2}}],[\"deeptostring\",{\"1\":{\"257\":1}}],[\"decimal\",{\"1\":{\"183\":1}}],[\"declare\",{\"1\":{\"153\":2,\"155\":2}}],[\"deprecated\",{\"1\":{\"307\":1}}],[\"dept\",{\"1\":{\"205\":4}}],[\"dependency>\",{\"1\":{\"138\":1}}],[\"deploy\",{\"1\":{\"26\":1}}],[\"delight\",{\"1\":{\"397\":1}}],[\"deletion\",{\"1\":{\"394\":1}}],[\"delete\",{\"0\":{\"190\":1},\"1\":{\"187\":1,\"190\":4,\"210\":1,\"220\":1}}],[\"del\",{\"1\":{\"86\":1,\"93\":1}}],[\"deduplicate\",{\"1\":{\"75\":2}}],[\"defaultreadobject\",{\"1\":{\"508\":1}}],[\"defaultvalue\",{\"1\":{\"329\":1}}],[\"default\",{\"1\":{\"182\":1,\"241\":1,\"398\":2}}],[\"definition\",{\"1\":{\"172\":1,\"174\":1}}],[\"def\",{\"1\":{\"75\":1,\"76\":3,\"77\":3,\"84\":2,\"85\":1,\"86\":5,\"91\":2,\"92\":1,\"93\":5,\"107\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":3,\"161\":2,\"162\":1,\"163\":1,\"164\":1}}],[\"developers\",{\"1\":{\"68\":1}}],[\"devdependencies\",{\"1\":{\"23\":1}}],[\"dev\",{\"1\":{\"23\":5,\"128\":2}}],[\"盘锦\",{\"1\":{\"76\":1,\"77\":1}}],[\"盘\",{\"1\":{\"22\":1}}],[\"执行情况\",{\"1\":{\"508\":1}}],[\"执行完后线程\",{\"1\":{\"488\":1}}],[\"执行临界区代码\",{\"1\":{\"445\":1}}],[\"执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法\",{\"1\":{\"443\":1}}],[\"执行静态同步方法的时候就只有一条\",{\"1\":{\"443\":1}}],[\"执行同步代码块后首先要先执行\",{\"1\":{\"443\":1}}],[\"执行结果对操作\",{\"1\":{\"467\":1}}],[\"执行结果对\",{\"1\":{\"433\":1}}],[\"执行操作\",{\"1\":{\"433\":2}}],[\"执行最终结果都是\",{\"1\":{\"430\":1}}],[\"执行了\",{\"1\":{\"420\":1}}],[\"执行死循环\",{\"1\":{\"419\":1}}],[\"执行示意图如下图\",{\"1\":{\"379\":1}}],[\"执行速度慢\",{\"1\":{\"311\":1}}],[\"执行某些语句\",{\"1\":{\"239\":1}}],[\"执行sql语句\",{\"1\":{\"217\":2}}],[\"执行时机不同\",{\"1\":{\"196\":1}}],[\"执行顺序\",{\"1\":{\"196\":1}}],[\"执行将会报错\",{\"1\":{\"186\":1}}],[\"执行过程中出现\",{\"1\":{\"23\":1}}],[\"执行以下命令之一\",{\"1\":{\"26\":1}}],[\"执行以下命令\",{\"1\":{\"22\":1,\"23\":1}}],[\"执行\",{\"1\":{\"22\":2,\"128\":1,\"129\":1,\"381\":1,\"467\":1,\"468\":1,\"487\":1,\"488\":3,\"490\":1,\"496\":1}}],[\"even\",{\"1\":{\"523\":1}}],[\"estimate\",{\"1\":{\"402\":1}}],[\"eh\",{\"1\":{\"400\":3}}],[\"ek\",{\"1\":{\"399\":8,\"400\":7}}],[\"either\",{\"1\":{\"366\":1,\"369\":1}}],[\"e2\",{\"1\":{\"333\":4}}],[\"e1\",{\"1\":{\"333\":4}}],[\"each\",{\"1\":{\"329\":2}}],[\"error\",{\"0\":{\"297\":1},\"1\":{\"297\":1,\"359\":1,\"360\":1,\"366\":1,\"393\":1}}],[\"erasure\",{\"1\":{\"134\":1}}],[\"equalsignorecase\",{\"1\":{\"324\":1}}],[\"equals\",{\"1\":{\"260\":1,\"322\":1,\"324\":1,\"337\":1,\"399\":3,\"400\":2,\"484\":2}}],[\"empty\",{\"1\":{\"292\":1,\"399\":1}}],[\"emp\",{\"1\":{\"185\":3,\"189\":2,\"205\":3}}],[\"embedded\",{\"1\":{\"23\":1}}],[\"e+308\",{\"1\":{\"183\":3}}],[\"e+38\",{\"1\":{\"183\":3}}],[\"eof\",{\"1\":{\"149\":2}}],[\"echo\",{\"1\":{\"146\":1,\"148\":1,\"152\":3,\"154\":1,\"156\":4,\"158\":5,\"162\":4,\"163\":2,\"164\":2}}],[\"echarts\",{\"1\":{\"23\":1}}],[\"effect\",{\"1\":{\"141\":1,\"370\":1}}],[\"education\",{\"1\":{\"92\":1,\"93\":1}}],[\"eligible\",{\"1\":{\"366\":1,\"369\":2}}],[\"elif\",{\"1\":{\"76\":2,\"77\":2}}],[\"elements\",{\"1\":{\"336\":2}}],[\"element\",{\"1\":{\"331\":1}}],[\"eles\",{\"1\":{\"96\":2}}],[\"ele\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":2,\"96\":3}}],[\"else连写\",{\"1\":{\"239\":1}}],[\"else\",{\"1\":{\"76\":1,\"77\":3,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"118\":1,\"121\":1,\"141\":1,\"239\":17,\"240\":3,\"247\":1,\"303\":1,\"318\":1,\"359\":1,\"360\":1,\"369\":3,\"370\":2,\"378\":2,\"398\":1,\"399\":4,\"400\":1,\"401\":11,\"402\":1,\"516\":1,\"517\":1,\"523\":1}}],[\"ex\",{\"1\":{\"401\":1}}],[\"exclusive\",{\"1\":{\"366\":4,\"507\":1,\"515\":1,\"519\":1,\"520\":1}}],[\"exclusivecount\",{\"1\":{\"366\":6,\"367\":1,\"369\":1}}],[\"exceeded\",{\"1\":{\"359\":1,\"360\":1,\"366\":1}}],[\"exception类的继承关系\",{\"0\":{\"298\":1}}],[\"exception\",{\"0\":{\"297\":1},\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"141\":4,\"142\":7,\"236\":2,\"237\":2,\"297\":1,\"298\":1,\"299\":2,\"393\":1,\"413\":1,\"423\":1}}],[\"except\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2}}],[\"extends\",{\"1\":{\"283\":1,\"287\":1,\"314\":1,\"316\":1,\"317\":1,\"318\":1,\"394\":3,\"397\":2,\"420\":1,\"508\":1}}],[\"extists\",{\"1\":{\"176\":1}}],[\"exists\",{\"1\":{\"176\":2,\"178\":3,\"186\":2}}],[\"explanation\",{\"1\":{\"402\":1}}],[\"expression\",{\"1\":{\"245\":3,\"274\":1}}],[\"export\",{\"1\":{\"155\":2}}],[\"expiry\",{\"1\":{\"142\":1}}],[\"executionexception\",{\"1\":{\"413\":1}}],[\"executorsservice\",{\"1\":{\"413\":1}}],[\"executors\",{\"1\":{\"413\":2,\"503\":1}}],[\"executorservice\",{\"1\":{\"413\":2}}],[\"execute\",{\"1\":{\"190\":1}}],[\"executable>\",{\"1\":{\"129\":1}}],[\"exe<\",{\"1\":{\"129\":1}}],[\"exe\",{\"1\":{\"67\":1,\"128\":3,\"129\":6}}],[\"example\",{\"1\":{\"52\":2,\"329\":3,\"508\":1}}],[\"ensure\",{\"1\":{\"401\":1,\"523\":2}}],[\"enq方法请看\",{\"1\":{\"379\":1}}],[\"enq\",{\"1\":{\"379\":2,\"516\":8,\"518\":2}}],[\"entry\",{\"1\":{\"394\":1}}],[\"entry对象的一个集视图\",{\"1\":{\"329\":1}}],[\"entry<k\",{\"1\":{\"295\":1,\"329\":1,\"394\":1}}],[\"entryset\",{\"1\":{\"295\":1,\"329\":1}}],[\"end\",{\"1\":{\"322\":4,\"324\":2,\"327\":1,\"336\":1}}],[\"endindex\",{\"1\":{\"260\":2}}],[\"endswith\",{\"1\":{\"260\":1}}],[\"endpoint\",{\"1\":{\"139\":3}}],[\"end=\",{\"1\":{\"77\":1}}],[\"encoding=\",{\"1\":{\"77\":1,\"86\":1,\"93\":1}}],[\"environment\",{\"1\":{\"34\":1}}],[\"engine的\",{\"1\":{\"30\":1}}],[\"enhance\",{\"1\":{\"23\":1}}],[\"e\",{\"1\":{\"22\":3,\"85\":2,\"86\":4,\"92\":2,\"93\":4,\"142\":2,\"183\":2,\"302\":4,\"303\":4,\"304\":2,\"314\":6,\"318\":2,\"327\":7,\"328\":6,\"330\":2,\"331\":4,\"332\":4,\"333\":4,\"337\":2,\"349\":2,\"377\":2,\"381\":2,\"387\":2,\"393\":2,\"399\":16,\"400\":11,\"401\":7,\"408\":1,\"409\":2,\"413\":4,\"419\":2,\"420\":2,\"423\":4,\"441\":2,\"461\":2,\"470\":2,\"494\":2,\"508\":2,\"518\":1}}],[\"窗口执行以下指令\",{\"1\":{\"35\":1}}],[\"窗口\",{\"1\":{\"22\":1}}],[\"cmp\",{\"1\":{\"409\":4}}],[\"cmpxchg\",{\"1\":{\"393\":1,\"409\":1,\"449\":1}}],[\"cmin\",{\"1\":{\"338\":1}}],[\"cmax\",{\"1\":{\"338\":1}}],[\"cmd\",{\"1\":{\"22\":1,\"35\":1,\"128\":1,\"129\":1}}],[\"cbrt\",{\"1\":{\"335\":1}}],[\"cellvalue\",{\"1\":{\"402\":1}}],[\"cells\",{\"1\":{\"402\":1}}],[\"cellsbusy\",{\"1\":{\"402\":1}}],[\"cell\",{\"1\":{\"402\":1}}],[\"ceil\",{\"1\":{\"335\":1}}],[\"ceilingentry\",{\"1\":{\"295\":1}}],[\"ceiling\",{\"1\":{\"294\":1}}],[\"center\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"center=\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"112\":1,\"115\":2}}],[\"cpu\",{\"1\":{\"220\":1,\"346\":8,\"348\":2,\"352\":2,\"391\":1,\"398\":1,\"421\":2,\"422\":4,\"429\":2,\"459\":1,\"466\":1}}],[\"creating\",{\"1\":{\"402\":1}}],[\"creationdate\",{\"1\":{\"141\":1}}],[\"createthreaddemo\",{\"1\":{\"413\":1}}],[\"create\",{\"1\":{\"176\":2,\"178\":1,\"181\":1,\"184\":1,\"200\":1,\"222\":1}}],[\"credentials\",{\"1\":{\"139\":1}}],[\"crashed\",{\"1\":{\"53\":1}}],[\"cnt\",{\"1\":{\"316\":3,\"317\":6}}],[\"cn\",{\"1\":{\"125\":1,\"126\":1,\"132\":1,\"134\":1}}],[\"cname\",{\"1\":{\"96\":1}}],[\"curthread\",{\"1\":{\"420\":3}}],[\"currentthread\",{\"1\":{\"359\":2,\"360\":1,\"366\":1,\"369\":1,\"370\":1,\"378\":1,\"381\":2,\"387\":1,\"420\":1,\"508\":1,\"516\":1}}],[\"current\",{\"1\":{\"359\":3,\"360\":3,\"366\":3,\"369\":6,\"370\":3}}],[\"cursive\",{\"1\":{\"119\":1,\"121\":1}}],[\"customize\",{\"1\":{\"67\":1}}],[\"caller\",{\"1\":{\"517\":1}}],[\"call\",{\"1\":{\"413\":1}}],[\"callable\",{\"1\":{\"413\":11}}],[\"calculator\",{\"1\":{\"310\":6}}],[\"calculable=true\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"capacity\",{\"1\":{\"397\":5,\"398\":2,\"402\":1}}],[\"cap\",{\"1\":{\"397\":3}}],[\"cancelacquire\",{\"1\":{\"516\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"cancelled\",{\"1\":{\"378\":3,\"379\":2,\"513\":1,\"517\":1,\"518\":2}}],[\"cannot\",{\"1\":{\"379\":1,\"517\":1}}],[\"can\",{\"1\":{\"366\":1,\"379\":1,\"402\":1,\"517\":1}}],[\"cas操作失败自旋尝试\",{\"1\":{\"516\":1}}],[\"cas操作\",{\"1\":{\"446\":1}}],[\"casnext\",{\"1\":{\"409\":1}}],[\"casitem\",{\"1\":{\"409\":1}}],[\"casing\",{\"1\":{\"369\":1}}],[\"castabat\",{\"1\":{\"395\":2,\"399\":2,\"401\":1}}],[\"cas\",{\"0\":{\"395\":1,\"409\":1,\"447\":1,\"448\":1,\"449\":1,\"450\":1,\"451\":1},\"1\":{\"369\":3,\"391\":1,\"393\":4,\"395\":3,\"399\":2,\"402\":1,\"403\":1,\"409\":3,\"448\":2,\"449\":7,\"450\":3,\"451\":6,\"454\":3,\"458\":1,\"459\":1,\"503\":1,\"516\":5,\"517\":1,\"518\":1,\"523\":4}}],[\"cas算法\",{\"1\":{\"348\":2}}],[\"cases\",{\"1\":{\"523\":1}}],[\"case\",{\"1\":{\"241\":9,\"369\":1,\"379\":1,\"523\":1}}],[\"catch\",{\"1\":{\"142\":1,\"302\":2,\"303\":2,\"304\":2,\"314\":3,\"318\":1,\"349\":1,\"377\":1,\"381\":1,\"387\":1,\"393\":1,\"401\":1,\"413\":2,\"419\":1,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"470\":1,\"494\":1,\"508\":1}}],[\"cachevalid\",{\"1\":{\"371\":3}}],[\"cachedholdcounter\",{\"1\":{\"369\":2,\"370\":1}}],[\"cache\",{\"1\":{\"23\":1,\"34\":1,\"35\":2}}],[\"cs\",{\"1\":{\"324\":2,\"346\":1}}],[\"csh\",{\"1\":{\"146\":1}}],[\"css\",{\"1\":{\"85\":2,\"86\":1,\"92\":3,\"93\":2,\"96\":5}}],[\"csv\",{\"1\":{\"75\":9,\"77\":8,\"85\":1,\"86\":6,\"92\":1,\"93\":6,\"101\":2,\"107\":2,\"115\":2,\"118\":2,\"121\":2},\"2\":{\"78\":1}}],[\"cityname\",{\"1\":{\"85\":1,\"86\":1}}],[\"citylist\",{\"1\":{\"84\":2,\"86\":1}}],[\"city=101200100\",{\"1\":{\"86\":1}}],[\"city=100010000\",{\"1\":{\"82\":2}}],[\"city=city\",{\"1\":{\"75\":2,\"86\":1,\"93\":1}}],[\"city可以知道是职业的地区参数\",{\"1\":{\"81\":1}}],[\"city\",{\"1\":{\"75\":5,\"76\":1,\"77\":32,\"81\":1,\"84\":7,\"86\":14,\"91\":7,\"93\":14,\"95\":1}}],[\"c++\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1,\"337\":1}}],[\"ctrl+alt+enter\",{\"1\":{\"71\":1}}],[\"ctrl\",{\"1\":{\"71\":9}}],[\"checked\",{\"1\":{\"497\":1}}],[\"checker\",{\"1\":{\"44\":1,\"47\":1,\"48\":1,\"49\":6,\"51\":1,\"55\":1,\"57\":2}}],[\"checkinterruptwhilewaiting\",{\"1\":{\"378\":2}}],[\"check\",{\"1\":{\"369\":2,\"402\":3}}],[\"checksum\",{\"1\":{\"134\":1}}],[\"chmod\",{\"1\":{\"126\":1,\"146\":1,\"158\":1}}],[\"chain\",{\"1\":{\"369\":1}}],[\"chaining\",{\"1\":{\"226\":1}}],[\"changed\",{\"1\":{\"371\":1,\"518\":1,\"523\":1}}],[\"change\",{\"1\":{\"185\":2,\"379\":1}}],[\"changes\",{\"1\":{\"57\":1}}],[\"character\",{\"1\":{\"329\":1,\"338\":2,\"484\":1}}],[\"charat\",{\"1\":{\"260\":2,\"262\":1,\"324\":1,\"325\":1}}],[\"char\",{\"1\":{\"183\":5,\"233\":1,\"237\":1,\"252\":2,\"253\":1,\"259\":3,\"260\":5,\"262\":1,\"324\":5,\"484\":1}}],[\"charts\",{\"1\":{\"107\":1,\"115\":1,\"121\":1}}],[\"chart\",{\"0\":{\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"111\":1,\"112\":1,\"113\":1},\"1\":{\"102\":1,\"103\":1,\"105\":3,\"106\":1,\"107\":8,\"111\":3,\"112\":3,\"113\":5,\"114\":1,\"115\":12}}],[\"chromiumpage区别于sessionpage\",{\"1\":{\"85\":1}}],[\"chromiumpage\",{\"1\":{\"77\":1,\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"96\":2}}],[\"chrome\",{\"1\":{\"30\":1}}],[\"cf\",{\"1\":{\"44\":2}}],[\"c\",{\"1\":{\"34\":1,\"75\":2,\"77\":2,\"91\":1,\"93\":1,\"96\":2,\"101\":2,\"102\":1,\"103\":1,\"104\":1,\"107\":5,\"111\":1,\"112\":1,\"115\":4,\"119\":1,\"121\":4,\"146\":1,\"233\":1,\"235\":2,\"237\":1,\"239\":6,\"240\":4,\"243\":2,\"245\":2,\"252\":1,\"253\":1,\"259\":4,\"260\":5,\"324\":4,\"336\":3,\"359\":6,\"360\":3,\"366\":13,\"369\":5,\"370\":3,\"395\":2,\"397\":2,\"430\":1,\"433\":4,\"435\":1,\"450\":1,\"488\":4}}],[\"cls\",{\"1\":{\"310\":5}}],[\"clear\",{\"1\":{\"291\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"518\":1}}],[\"cleaned\",{\"1\":{\"75\":2}}],[\"clean\",{\"1\":{\"23\":2,\"378\":2}}],[\"close\",{\"1\":{\"86\":1,\"93\":1}}],[\"cloneable\",{\"1\":{\"300\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"300\":1}}],[\"clone\",{\"1\":{\"49\":1,\"300\":1}}],[\"cli\",{\"1\":{\"134\":1}}],[\"click\",{\"1\":{\"85\":1,\"86\":1,\"92\":2,\"93\":2}}],[\"client\",{\"1\":{\"23\":1,\"134\":1}}],[\"class<\",{\"1\":{\"310\":1}}],[\"classnotfoundexception\",{\"1\":{\"300\":1,\"310\":1,\"508\":1}}],[\"classcastexception\",{\"1\":{\"300\":1}}],[\"class=joblist\",{\"1\":{\"96\":1}}],[\"class\",{\"1\":{\"85\":2,\"86\":2,\"92\":2,\"93\":2,\"139\":2,\"198\":1,\"233\":1,\"235\":3,\"236\":2,\"237\":2,\"239\":9,\"240\":2,\"241\":1,\"243\":4,\"244\":1,\"245\":4,\"247\":1,\"248\":1,\"249\":2,\"252\":1,\"253\":1,\"254\":4,\"255\":2,\"256\":1,\"259\":2,\"261\":1,\"266\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"288\":1,\"289\":2,\"300\":1,\"302\":1,\"303\":1,\"304\":1,\"310\":7,\"314\":5,\"316\":2,\"317\":5,\"318\":2,\"349\":1,\"381\":3,\"387\":1,\"394\":4,\"402\":1,\"408\":1,\"413\":1,\"419\":1,\"420\":2,\"423\":1,\"441\":1,\"443\":5,\"444\":1,\"461\":2,\"467\":1,\"470\":1,\"479\":2,\"481\":1,\"482\":1,\"483\":1,\"487\":1,\"488\":1,\"490\":1,\"494\":1,\"497\":2,\"505\":1,\"508\":4}}],[\"cope\",{\"1\":{\"401\":1}}],[\"copyofrange\",{\"1\":{\"322\":1}}],[\"copyof\",{\"1\":{\"322\":1}}],[\"copy\",{\"1\":{\"304\":1}}],[\"collection<e>\",{\"1\":{\"336\":5}}],[\"collection<v>\",{\"1\":{\"329\":1}}],[\"collections\",{\"0\":{\"336\":1},\"1\":{\"293\":1,\"322\":1,\"333\":1,\"391\":1,\"407\":1}}],[\"color\",{\"1\":{\"283\":8}}],[\"colorpoint\",{\"1\":{\"283\":2,\"284\":3}}],[\"color=\",{\"1\":{\"102\":2,\"106\":1,\"107\":3,\"111\":2,\"112\":1,\"114\":1,\"115\":4}}],[\"column1\",{\"1\":{\"210\":2}}],[\"cos\",{\"1\":{\"133\":1}}],[\"countdownlatch\",{\"1\":{\"507\":1}}],[\"counter++\",{\"1\":{\"494\":2}}],[\"counter\",{\"1\":{\"402\":1,\"494\":6}}],[\"countercells\",{\"1\":{\"402\":4}}],[\"countercell\",{\"1\":{\"402\":7}}],[\"counts\",{\"1\":{\"402\":1}}],[\"count++\",{\"1\":{\"369\":1,\"441\":1,\"461\":1}}],[\"count\",{\"1\":{\"118\":6,\"121\":6,\"195\":2,\"317\":15,\"359\":1,\"360\":1,\"366\":7,\"369\":5,\"370\":5,\"402\":1,\"441\":2,\"461\":2}}],[\"code\",{\"1\":{\"84\":3,\"86\":3,\"91\":4,\"93\":4,\"134\":1,\"159\":1}}],[\"codeforces\",{\"1\":{\"44\":1}}],[\"condiiton\",{\"1\":{\"377\":1}}],[\"conditionobject\",{\"1\":{\"377\":6,\"508\":1}}],[\"condition\",{\"0\":{\"374\":1,\"375\":1,\"376\":1},\"1\":{\"245\":2,\"375\":9,\"377\":14,\"378\":13,\"379\":6,\"380\":4,\"381\":6,\"385\":1,\"386\":2,\"505\":1,\"508\":3,\"513\":1}}],[\"concurrency\",{\"1\":{\"450\":1}}],[\"concurrencylevel\",{\"1\":{\"397\":1}}],[\"concurrenhashmap\",{\"1\":{\"399\":1}}],[\"concurrentlinkedqueue初始化状态\",{\"1\":{\"408\":1}}],[\"concurrentlinkedqueue\",{\"0\":{\"406\":1,\"407\":1},\"1\":{\"407\":1,\"408\":5,\"409\":1}}],[\"concurrenthashmap扩容示意图\",{\"1\":{\"401\":1}}],[\"concurrenthashmap散列桶数组结构示意图\",{\"1\":{\"399\":1}}],[\"concurrenthashmapde\",{\"1\":{\"393\":1}}],[\"concurrenthashmap\",{\"0\":{\"390\":1,\"391\":1,\"392\":1},\"1\":{\"348\":1,\"391\":4,\"392\":1,\"393\":2,\"394\":1,\"395\":2,\"397\":14,\"399\":9,\"401\":1,\"402\":5,\"403\":2}}],[\"concurrent\",{\"0\":{\"503\":1},\"1\":{\"316\":1,\"364\":1,\"385\":1,\"386\":2,\"401\":1,\"402\":1,\"417\":1,\"503\":4}}],[\"concat\",{\"1\":{\"75\":1}}],[\"constructor<\",{\"1\":{\"310\":1}}],[\"constructor\",{\"1\":{\"310\":4}}],[\"constraint\",{\"1\":{\"200\":2}}],[\"consistency\",{\"1\":{\"218\":2}}],[\"console\",{\"1\":{\"126\":3,\"127\":1,\"128\":1}}],[\"contain\",{\"1\":{\"402\":1}}],[\"containsvalue\",{\"1\":{\"329\":1}}],[\"containskey\",{\"1\":{\"295\":1,\"329\":1}}],[\"contains\",{\"1\":{\"294\":1,\"324\":1,\"328\":1}}],[\"contended\",{\"1\":{\"402\":1}}],[\"control\",{\"1\":{\"172\":1}}],[\"continues\",{\"1\":{\"523\":1}}],[\"continue\",{\"0\":{\"248\":1},\"1\":{\"77\":2,\"248\":1,\"523\":3}}],[\"configuration\",{\"1\":{\"139\":1}}],[\"configurationproperties\",{\"1\":{\"139\":1}}],[\"config\",{\"1\":{\"26\":1,\"35\":2,\"139\":1,\"141\":1},\"2\":{\"20\":1}}],[\"compareandswaplong\",{\"1\":{\"402\":2}}],[\"compareandswapint\",{\"1\":{\"398\":2,\"401\":2,\"402\":2}}],[\"compareandswapobject\",{\"1\":{\"395\":1,\"409\":2}}],[\"compareandswapxxxx\",{\"1\":{\"393\":1}}],[\"compareandsethead\",{\"1\":{\"516\":2}}],[\"compareandsettail\",{\"1\":{\"516\":6}}],[\"compareandsetwaitstatus\",{\"1\":{\"379\":2,\"517\":4,\"518\":1,\"523\":2}}],[\"compareandsetstate\",{\"1\":{\"359\":1,\"360\":1,\"366\":1,\"369\":1,\"370\":1,\"506\":1,\"507\":1,\"508\":2}}],[\"compare\",{\"1\":{\"333\":1,\"448\":1}}],[\"compareto\",{\"1\":{\"260\":1}}],[\"comparator<e>\",{\"1\":{\"333\":1}}],[\"comparator\",{\"1\":{\"329\":2,\"333\":1}}],[\"comparable\",{\"1\":{\"329\":2,\"333\":2}}],[\"companyname\",{\"1\":{\"92\":1,\"93\":1}}],[\"component\",{\"1\":{\"139\":1}}],[\"components\",{\"1\":{\"23\":1}}],[\"combined\",{\"1\":{\"75\":2}}],[\"comment\",{\"1\":{\"181\":4,\"185\":4}}],[\"command这条命令的stdout\",{\"1\":{\"159\":1}}],[\"command\",{\"1\":{\"159\":3}}],[\"commons\",{\"1\":{\"107\":1}}],[\"community\",{\"1\":{\"68\":1}}],[\"committing\",{\"1\":{\"401\":1}}],[\"commit\",{\"1\":{\"26\":1,\"57\":1,\"217\":1,\"401\":1}}],[\"com\",{\"1\":{\"26\":2,\"49\":1,\"82\":1,\"84\":1,\"86\":2,\"88\":1,\"91\":1,\"93\":2,\"95\":2,\"96\":1,\"125\":2,\"129\":1,\"134\":3}}],[\"core\",{\"1\":{\"23\":1,\"26\":1}}],[\"cd\",{\"1\":{\"22\":1}}],[\"1a\",{\"1\":{\"451\":1}}],[\"1s\",{\"1\":{\"419\":1}}],[\"1l\",{\"1\":{\"399\":1}}],[\"1~100\",{\"1\":{\"243\":1,\"245\":1,\"248\":1,\"249\":2}}],[\"1kb\",{\"1\":{\"221\":1}}],[\"133\",{\"1\":{\"432\":1}}],[\"1365\",{\"1\":{\"423\":1}}],[\"135w∗16\",{\"1\":{\"221\":1}}],[\"135w\",{\"1\":{\"221\":2}}],[\"13\",{\"1\":{\"185\":2}}],[\"130\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"19\",{\"1\":{\"183\":1,\"423\":1}}],[\"1970\",{\"1\":{\"183\":1}}],[\"1901\",{\"1\":{\"183\":1}}],[\"1byte\",{\"1\":{\"183\":1}}],[\"18\",{\"1\":{\"260\":3,\"397\":1}}],[\"183gb\",{\"1\":{\"134\":1}}],[\"18482\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"14\",{\"1\":{\"183\":1,\"430\":2}}],[\"1400\",{\"1\":{\"120\":1,\"121\":1}}],[\"14158\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"14679\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"122\",{\"1\":{\"259\":1}}],[\"128\",{\"1\":{\"183\":1,\"259\":1}}],[\"12854\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"127\",{\"1\":{\"169\":1,\"183\":1,\"259\":1}}],[\"1234567891011l\",{\"1\":{\"233\":1}}],[\"123456789\",{\"1\":{\"233\":1}}],[\"12345\",{\"1\":{\"233\":1}}],[\"123\",{\"1\":{\"142\":1,\"233\":1,\"237\":3,\"252\":1,\"260\":1}}],[\"12373\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"12\",{\"1\":{\"134\":1,\"183\":2,\"233\":1,\"398\":2}}],[\"12989\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"10min\",{\"1\":{\"520\":1}}],[\"10∗1000000=10000000\",{\"1\":{\"441\":1,\"461\":1}}],[\"10×10\",{\"1\":{\"249\":1}}],[\"1024×768\",{\"1\":{\"346\":1}}],[\"1024字节\",{\"1\":{\"221\":1}}],[\"10200\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"10988\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"10794\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"100010000\",{\"1\":{\"84\":1,\"86\":1}}],[\"100010000对应的是全国参数\",{\"1\":{\"81\":1}}],[\"1000\",{\"1\":{\"76\":1,\"77\":1,\"85\":1,\"86\":1,\"92\":1,\"93\":1,\"183\":2,\"221\":1,\"314\":3,\"318\":1,\"419\":1,\"494\":1}}],[\"1000000\",{\"1\":{\"441\":2,\"461\":2}}],[\"100000\",{\"1\":{\"316\":1,\"317\":2,\"494\":3}}],[\"10000\",{\"1\":{\"76\":1,\"77\":1,\"494\":3}}],[\"100\",{\"1\":{\"53\":1,\"119\":1,\"121\":1,\"133\":1,\"221\":1,\"239\":1,\"240\":1,\"243\":1,\"245\":1,\"248\":1,\"249\":1,\"333\":2,\"391\":1}}],[\"10\",{\"0\":{\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"310\":1,\"311\":1},\"1\":{\"53\":1,\"105\":2,\"107\":2,\"141\":1,\"233\":1,\"234\":2,\"235\":1,\"243\":1,\"245\":3,\"249\":2,\"252\":1,\"255\":2,\"256\":1,\"267\":1,\"272\":1,\"288\":1,\"289\":1,\"314\":3,\"377\":3,\"420\":2,\"422\":1,\"441\":2,\"461\":2,\"494\":5,\"508\":2}}],[\"170\",{\"1\":{\"479\":1}}],[\"175\",{\"1\":{\"386\":1}}],[\"175494351\",{\"1\":{\"183\":1}}],[\"171gb\",{\"1\":{\"134\":1}}],[\"17128\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"17\",{\"1\":{\"23\":3,\"141\":1}}],[\"110\",{\"1\":{\"233\":1}}],[\"1170∗1170=135w\",{\"1\":{\"221\":1}}],[\"1170\",{\"1\":{\"221\":3}}],[\"11348\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"11876\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"11\",{\"0\":{\"313\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1},\"1\":{\"23\":4,\"183\":1,\"185\":2,\"255\":1,\"256\":1}}],[\"15096\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"15898\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"15584\",{\"1\":{\"77\":1,\"101\":1,\"107\":1}}],[\"15\",{\"1\":{\"23\":3,\"112\":1,\"115\":1}}],[\"16384\",{\"1\":{\"221\":1}}],[\"16kb\",{\"1\":{\"221\":2}}],[\"16777215\",{\"1\":{\"183\":1}}],[\"1650px\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1}}],[\"16\",{\"1\":{\"23\":3,\"183\":2,\"221\":3,\"366\":7,\"367\":1,\"369\":1,\"397\":1,\"398\":1,\"399\":3}}],[\"1\",{\"0\":{\"22\":1,\"69\":1,\"75\":1,\"80\":1,\"100\":1,\"147\":1,\"148\":2,\"149\":1,\"151\":1,\"158\":1,\"161\":1,\"168\":1,\"169\":2,\"170\":1,\"171\":2,\"172\":1,\"174\":1,\"175\":2,\"176\":1,\"177\":1,\"178\":1,\"180\":1,\"181\":2,\"182\":1,\"183\":1,\"188\":1,\"192\":1,\"200\":1,\"204\":1,\"205\":2,\"206\":1,\"210\":1,\"216\":1,\"220\":1,\"233\":2,\"234\":1,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"243\":1,\"247\":1,\"251\":1,\"252\":2,\"253\":1,\"254\":1,\"259\":1,\"264\":1,\"265\":2,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"275\":1,\"280\":1,\"281\":2,\"282\":1,\"283\":1,\"284\":1,\"286\":1,\"291\":1,\"297\":1,\"306\":1,\"307\":2,\"308\":1,\"310\":1,\"313\":1,\"314\":2,\"315\":1,\"318\":1,\"346\":1,\"348\":1,\"351\":1,\"358\":1,\"364\":1,\"366\":1,\"369\":1,\"375\":1,\"377\":1,\"385\":1,\"391\":1,\"393\":1,\"397\":1,\"407\":1,\"408\":2,\"409\":1,\"413\":1,\"419\":1,\"427\":1,\"432\":1,\"435\":1,\"441\":1,\"443\":1,\"447\":1,\"448\":2,\"449\":1,\"450\":1,\"451\":1,\"454\":1,\"458\":1,\"465\":1,\"474\":1,\"476\":1,\"477\":2,\"478\":1,\"479\":1,\"481\":1,\"486\":1,\"487\":2,\"488\":1,\"494\":1,\"496\":1,\"503\":1,\"505\":1,\"512\":1,\"515\":1,\"516\":2,\"517\":1,\"522\":1},\"1\":{\"23\":8,\"76\":4,\"77\":9,\"95\":1,\"102\":1,\"104\":1,\"107\":2,\"111\":4,\"112\":2,\"115\":4,\"118\":2,\"121\":2,\"126\":2,\"142\":1,\"158\":2,\"161\":2,\"162\":2,\"163\":1,\"164\":1,\"169\":1,\"171\":1,\"182\":1,\"183\":7,\"189\":1,\"198\":1,\"227\":1,\"233\":5,\"235\":2,\"237\":1,\"239\":9,\"240\":1,\"241\":1,\"243\":7,\"244\":4,\"245\":7,\"247\":1,\"248\":2,\"249\":1,\"253\":2,\"254\":8,\"255\":1,\"256\":1,\"260\":1,\"262\":1,\"265\":2,\"266\":2,\"269\":1,\"270\":1,\"273\":2,\"275\":5,\"278\":2,\"284\":1,\"303\":1,\"306\":1,\"307\":1,\"308\":1,\"310\":1,\"314\":2,\"324\":5,\"325\":2,\"327\":6,\"328\":4,\"329\":10,\"330\":6,\"331\":5,\"332\":6,\"333\":1,\"335\":1,\"336\":1,\"349\":4,\"359\":3,\"366\":7,\"367\":1,\"369\":7,\"370\":2,\"377\":1,\"378\":3,\"379\":3,\"386\":3,\"391\":3,\"393\":1,\"394\":2,\"395\":1,\"397\":9,\"398\":3,\"399\":9,\"400\":2,\"401\":14,\"402\":6,\"403\":4,\"413\":2,\"420\":2,\"422\":1,\"430\":2,\"432\":1,\"433\":1,\"435\":1,\"444\":2,\"445\":3,\"446\":1,\"451\":1,\"452\":1,\"454\":1,\"455\":1,\"467\":2,\"487\":2,\"488\":5,\"490\":4,\"494\":3,\"508\":10,\"513\":3,\"516\":5,\"520\":3}}],[\"person\",{\"1\":{\"479\":9}}],[\"peeklast\",{\"1\":{\"332\":1}}],[\"peekfirst\",{\"1\":{\"332\":1}}],[\"peek\",{\"1\":{\"292\":1,\"293\":1,\"330\":1,\"331\":1,\"333\":1}}],[\"pv\",{\"1\":{\"401\":3}}],[\"pk\",{\"1\":{\"401\":3}}],[\"ph\",{\"1\":{\"401\":4}}],[\"phone\",{\"1\":{\"183\":2}}],[\"php\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1}}],[\"p端口号\",{\"1\":{\"169\":1}}],[\"p密码\",{\"1\":{\"169\":1}}],[\"p\",{\"1\":{\"127\":2,\"169\":3,\"379\":3,\"399\":8,\"400\":3,\"401\":22,\"516\":5,\"517\":1,\"519\":4,\"520\":4,\"522\":4}}],[\"putorderedobject\",{\"1\":{\"409\":1}}],[\"putobjectvolatile\",{\"1\":{\"395\":1}}],[\"putobjectargs\",{\"1\":{\"142\":1}}],[\"putobject\",{\"1\":{\"142\":2}}],[\"puttreeval\",{\"1\":{\"399\":3}}],[\"putifabsent\",{\"1\":{\"399\":1}}],[\"putval\",{\"1\":{\"399\":2}}],[\"put\",{\"0\":{\"399\":1},\"1\":{\"295\":1,\"329\":2,\"391\":3,\"399\":7,\"400\":1,\"402\":1,\"403\":3}}],[\"publicread\",{\"1\":{\"141\":1}}],[\"public\",{\"1\":{\"139\":3,\"198\":1,\"233\":2,\"235\":6,\"236\":4,\"237\":4,\"239\":18,\"240\":4,\"241\":2,\"243\":8,\"244\":2,\"245\":8,\"247\":2,\"248\":2,\"249\":4,\"252\":2,\"253\":2,\"254\":8,\"255\":4,\"256\":2,\"259\":4,\"261\":2,\"266\":2,\"269\":2,\"270\":2,\"272\":2,\"273\":2,\"275\":2,\"276\":2,\"277\":2,\"278\":2,\"281\":3,\"282\":7,\"283\":3,\"284\":2,\"286\":4,\"287\":1,\"288\":4,\"289\":6,\"301\":6,\"302\":2,\"303\":2,\"304\":2,\"310\":7,\"314\":7,\"316\":4,\"317\":10,\"318\":4,\"333\":1,\"349\":5,\"360\":2,\"377\":1,\"378\":2,\"379\":1,\"381\":4,\"387\":2,\"391\":1,\"397\":1,\"400\":1,\"402\":2,\"408\":1,\"413\":5,\"419\":4,\"420\":7,\"421\":1,\"422\":1,\"423\":3,\"441\":3,\"443\":2,\"444\":3,\"461\":3,\"467\":3,\"470\":3,\"479\":4,\"481\":2,\"482\":3,\"483\":2,\"487\":4,\"488\":5,\"490\":4,\"494\":3,\"497\":2,\"505\":1,\"507\":1,\"508\":11,\"515\":1,\"518\":1,\"519\":1,\"520\":1,\"522\":1,\"523\":1}}],[\"pull\",{\"1\":{\"127\":1}}],[\"push\",{\"1\":{\"26\":1,\"292\":1,\"330\":1}}],[\"pi\",{\"1\":{\"430\":2}}],[\"pie\",{\"1\":{\"107\":1,\"112\":5,\"113\":1,\"115\":7}}],[\"pip\",{\"1\":{\"99\":2}}],[\"pprint\",{\"1\":{\"96\":2,\"107\":2,\"115\":2}}],[\"pc\",{\"1\":{\"95\":2,\"96\":1}}],[\"p=页面\",{\"1\":{\"88\":1}}],[\"p=2\",{\"1\":{\"88\":1,\"93\":1}}],[\"p2\",{\"1\":{\"76\":3,\"77\":3}}],[\"p1\",{\"1\":{\"76\":3,\"77\":3}}],[\"pd\",{\"1\":{\"75\":3,\"77\":2,\"101\":1,\"107\":2,\"115\":2,\"118\":1,\"121\":2}}],[\"py\",{\"1\":{\"134\":1}}],[\"pyecharts\",{\"1\":{\"99\":2,\"107\":4,\"115\":3,\"121\":2},\"2\":{\"72\":1,\"123\":1}}],[\"pycharm的安装通用非常简单\",{\"1\":{\"70\":1}}],[\"pycharm针对每个平台都有professional和community两个版本\",{\"1\":{\"68\":1}}],[\"pycharm\",{\"1\":{\"68\":1,\"70\":1}}],[\"pycharm是一款非常好用的python\",{\"1\":{\"68\":1}}],[\"python安装非常简单\",{\"1\":{\"67\":1}}],[\"python作为众多编程语言之一\",{\"1\":{\"65\":1}}],[\"python\",{\"1\":{\"67\":1,\"68\":1,\"75\":1,\"77\":1,\"81\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1,\"134\":1},\"2\":{\"63\":1,\"72\":1,\"78\":1,\"97\":1,\"123\":1}}],[\"png\",{\"1\":{\"47\":1,\"298\":1}}],[\"power\",{\"1\":{\"397\":1,\"402\":1}}],[\"pow\",{\"1\":{\"335\":1}}],[\"pop\",{\"1\":{\"292\":1,\"330\":1}}],[\"point\",{\"1\":{\"282\":2,\"283\":1,\"284\":5}}],[\"point=str\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1}}],[\"policy\",{\"1\":{\"366\":1,\"369\":1}}],[\"policyjsonstring\",{\"1\":{\"141\":2}}],[\"polllast\",{\"1\":{\"332\":1}}],[\"pollfirst\",{\"1\":{\"332\":1}}],[\"poll\",{\"1\":{\"331\":1,\"333\":1}}],[\"polygon\",{\"0\":{\"43\":1},\"1\":{\"39\":1,\"43\":1,\"44\":5,\"45\":1,\"52\":1},\"2\":{\"40\":1,\"58\":1}}],[\"possibly\",{\"1\":{\"518\":1}}],[\"postponed\",{\"1\":{\"369\":1}}],[\"position=\",{\"1\":{\"104\":1,\"106\":1,\"107\":2,\"114\":1,\"115\":1}}],[\"positions\",{\"1\":{\"89\":1,\"92\":1,\"93\":1}}],[\"pos\",{\"1\":{\"102\":4,\"103\":2,\"104\":2,\"105\":8,\"106\":4,\"107\":20,\"111\":4,\"114\":4,\"115\":8,\"120\":1,\"121\":1}}],[\"portfolio\",{\"1\":{\"1\":1}}],[\"priority\",{\"1\":{\"422\":1}}],[\"priorityqueue<e>\",{\"1\":{\"333\":4}}],[\"priorityqueue<>\",{\"1\":{\"293\":2,\"333\":2}}],[\"priorityqueue\",{\"0\":{\"333\":1},\"1\":{\"333\":4}}],[\"prio=0\",{\"1\":{\"386\":2}}],[\"prio=5\",{\"1\":{\"386\":2}}],[\"primary\",{\"1\":{\"182\":1}}],[\"principal\",{\"1\":{\"141\":1}}],[\"printstacktrace\",{\"1\":{\"301\":1,\"302\":2,\"303\":2,\"349\":1,\"377\":1,\"381\":1,\"387\":1,\"413\":2,\"419\":1,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"470\":1,\"494\":1,\"508\":1}}],[\"printf\",{\"1\":{\"237\":2,\"239\":14,\"249\":1,\"254\":3,\"255\":1,\"256\":1,\"261\":1,\"266\":1,\"275\":1}}],[\"println\",{\"1\":{\"141\":3,\"142\":6,\"235\":9,\"236\":1,\"237\":2,\"239\":16,\"240\":5,\"241\":1,\"243\":4,\"244\":2,\"245\":4,\"247\":2,\"248\":1,\"249\":2,\"254\":2,\"255\":1,\"256\":1,\"259\":5,\"261\":1,\"262\":2,\"269\":2,\"270\":3,\"272\":1,\"273\":2,\"276\":1,\"277\":4,\"278\":1,\"284\":2,\"288\":3,\"289\":3,\"302\":3,\"303\":2,\"304\":2,\"310\":3,\"314\":3,\"316\":1,\"317\":2,\"318\":1,\"324\":2,\"349\":4,\"381\":2,\"387\":1,\"413\":3,\"419\":2,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"479\":1,\"494\":1}}],[\"print\",{\"1\":{\"75\":1,\"77\":3,\"84\":1,\"85\":1,\"86\":4,\"91\":1,\"92\":1,\"93\":4,\"96\":1,\"237\":2,\"260\":2}}],[\"private\",{\"1\":{\"139\":5,\"198\":2,\"265\":2,\"266\":1,\"269\":2,\"270\":4,\"272\":1,\"273\":2,\"275\":1,\"276\":1,\"277\":2,\"278\":1,\"282\":3,\"283\":1,\"288\":1,\"289\":1,\"302\":1,\"303\":1,\"316\":1,\"317\":1,\"318\":2,\"349\":2,\"377\":2,\"378\":1,\"379\":2,\"381\":3,\"397\":1,\"398\":1,\"401\":1,\"402\":4,\"408\":3,\"420\":1,\"441\":1,\"443\":1,\"444\":1,\"461\":1,\"467\":2,\"470\":1,\"479\":3,\"484\":2,\"487\":3,\"488\":1,\"490\":2,\"494\":1,\"497\":2,\"508\":4,\"516\":2,\"517\":3,\"518\":1,\"519\":1,\"520\":1,\"522\":1,\"523\":1}}],[\"pre\",{\"1\":{\"517\":1}}],[\"pred\",{\"1\":{\"399\":4,\"516\":6,\"517\":8}}],[\"predecessors\",{\"1\":{\"517\":1}}],[\"predecessor\",{\"1\":{\"379\":1,\"516\":1,\"517\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"previousthread\",{\"1\":{\"420\":3}}],[\"prev\",{\"1\":{\"394\":1,\"401\":2,\"513\":1,\"516\":2,\"517\":3,\"518\":1}}],[\"presignedobjecturl\",{\"1\":{\"142\":2}}],[\"presto\",{\"1\":{\"134\":1}}],[\"prefix\",{\"1\":{\"35\":1,\"139\":1}}],[\"progress\",{\"1\":{\"523\":1}}],[\"propagation\",{\"1\":{\"523\":1}}],[\"propagates\",{\"1\":{\"523\":1}}],[\"propagate\",{\"1\":{\"513\":1,\"517\":1,\"523\":2}}],[\"properly\",{\"1\":{\"508\":1}}],[\"provides\",{\"1\":{\"508\":1}}],[\"province\",{\"1\":{\"76\":3,\"77\":3,\"101\":4,\"102\":1,\"107\":5,\"111\":1,\"112\":1,\"115\":6}}],[\"probably\",{\"1\":{\"379\":1}}],[\"problem\",{\"1\":{\"45\":1}}],[\"processed\",{\"1\":{\"401\":1}}],[\"processcacheddata\",{\"1\":{\"371\":1}}],[\"proceeds\",{\"1\":{\"523\":1}}],[\"proceed\",{\"1\":{\"370\":1}}],[\"protected\",{\"1\":{\"282\":1,\"359\":2,\"360\":1,\"366\":1,\"367\":1,\"369\":1,\"370\":1,\"506\":1,\"507\":3,\"508\":3}}],[\"professional\",{\"1\":{\"68\":2}}],[\"pro\",{\"1\":{\"23\":1,\"76\":3,\"77\":3}}],[\"project\",{\"1\":{\"22\":1,\"23\":1},\"2\":{\"20\":1}}],[\"play\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"play=true\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"120\":1,\"121\":1}}],[\"playground\",{\"1\":{\"23\":1}}],[\"plugin\",{\"1\":{\"23\":6}}],[\"pause\",{\"1\":{\"451\":1}}],[\"padded\",{\"1\":{\"402\":1}}],[\"pair\",{\"1\":{\"337\":1}}],[\"pair<k\",{\"0\":{\"337\":1},\"1\":{\"337\":1}}],[\"pair=pie\",{\"1\":{\"112\":1,\"115\":1}}],[\"pair=map\",{\"1\":{\"111\":1,\"115\":1}}],[\"pair=\",{\"1\":{\"102\":1,\"107\":1}}],[\"password=password\",{\"1\":{\"126\":2}}],[\"parent\",{\"1\":{\"394\":1}}],[\"parkandcheckinterrupt\",{\"1\":{\"516\":1,\"517\":3,\"519\":2,\"522\":1}}],[\"parkutil\",{\"1\":{\"417\":1}}],[\"parkuntil\",{\"1\":{\"386\":2}}],[\"parking\",{\"1\":{\"386\":4,\"517\":1}}],[\"parknanos\",{\"1\":{\"386\":2,\"417\":1,\"520\":2}}],[\"park\",{\"1\":{\"378\":4,\"379\":1,\"385\":3,\"386\":13,\"387\":2,\"517\":5,\"518\":1}}],[\"parseboolean\",{\"1\":{\"324\":1}}],[\"parseint\",{\"1\":{\"324\":1}}],[\"parsedouble\",{\"1\":{\"260\":1}}],[\"params\",{\"1\":{\"102\":4,\"107\":4}}],[\"part\",{\"1\":{\"118\":7,\"121\":7}}],[\"part2\",{\"1\":{\"76\":3,\"77\":3}}],[\"part1\",{\"1\":{\"76\":3,\"77\":3}}],[\"parts\",{\"1\":{\"76\":3,\"77\":3,\"118\":2,\"121\":2}}],[\"pandas\",{\"1\":{\"77\":1,\"107\":1,\"115\":1,\"121\":1},\"2\":{\"78\":1}}],[\"path\",{\"1\":{\"89\":1,\"516\":1}}],[\"path一栏\",{\"1\":{\"82\":1}}],[\"path打上勾\",{\"1\":{\"67\":1}}],[\"pattern>\",{\"1\":{\"129\":1}}],[\"pattern\",{\"1\":{\"53\":1}}],[\"pagebean\",{\"1\":{\"198\":2}}],[\"page\",{\"1\":{\"44\":1,\"84\":4,\"85\":13,\"86\":16,\"91\":3,\"92\":15,\"93\":18,\"96\":3,\"115\":1,\"198\":1,\"221\":1}}],[\"pagesize\",{\"1\":{\"198\":1}}],[\"pages\",{\"0\":{\"27\":1},\"1\":{\"22\":1,\"27\":3,\"85\":3,\"86\":1}}],[\"package\",{\"1\":{\"23\":1,\"57\":1,\"281\":1,\"310\":2,\"318\":1,\"337\":1}}],[\"gc\",{\"1\":{\"402\":1,\"516\":1,\"517\":2,\"519\":1,\"520\":1,\"522\":1}}],[\"given\",{\"1\":{\"397\":1}}],[\"gitee\",{\"1\":{\"125\":1}}],[\"gitee镜像\",{\"1\":{\"125\":1}}],[\"github\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"22\":1,\"26\":4,\"27\":3,\"49\":1,\"125\":2,\"129\":1,\"134\":3},\"2\":{\"28\":1}}],[\"git\",{\"0\":{\"10\":1},\"1\":{\"2\":1,\"26\":10}}],[\"gbk\",{\"1\":{\"324\":2}}],[\"go\",{\"1\":{\"134\":2}}],[\"google\",{\"1\":{\"134\":1}}],[\"golang\",{\"1\":{\"75\":1,\"77\":1,\"101\":1,\"107\":1,\"115\":1,\"121\":1,\"134\":1}}],[\"g\",{\"1\":{\"106\":2,\"107\":2}}],[\"gallery\",{\"1\":{\"99\":1}}],[\"grant\",{\"1\":{\"369\":1}}],[\"grader\",{\"1\":{\"48\":1}}],[\"greet\",{\"1\":{\"286\":1,\"288\":1,\"289\":2}}],[\"gridopts\",{\"1\":{\"105\":3,\"107\":3,\"113\":2,\"115\":2}}],[\"grid\",{\"1\":{\"105\":5,\"107\":7,\"113\":6,\"114\":1,\"115\":8}}],[\"groupid>\",{\"1\":{\"138\":1}}],[\"group\",{\"1\":{\"76\":2,\"77\":2,\"192\":2,\"196\":1,\"197\":1}}],[\"geek\",{\"1\":{\"82\":1,\"86\":1}}],[\"general\",{\"1\":{\"50\":1}}],[\"generator\",{\"1\":{\"44\":1,\"48\":2,\"49\":1}}],[\"getinstance\",{\"1\":{\"497\":1}}],[\"getinteger\",{\"1\":{\"324\":1}}],[\"getter\",{\"1\":{\"484\":1}}],[\"getthreadid\",{\"1\":{\"369\":1,\"370\":1}}],[\"getunsafe\",{\"1\":{\"393\":1}}],[\"getunit\",{\"1\":{\"76\":3,\"77\":3}}],[\"getexclusiveownerthread\",{\"1\":{\"359\":2,\"360\":1,\"366\":1,\"369\":1}}],[\"getendpoint\",{\"1\":{\"139\":1}}],[\"getordefault\",{\"1\":{\"329\":2}}],[\"getobjectvolatile\",{\"1\":{\"395\":1}}],[\"getobjectargs\",{\"1\":{\"142\":1}}],[\"getobjectresponse\",{\"1\":{\"142\":3}}],[\"getobject\",{\"1\":{\"141\":1,\"142\":2}}],[\"getbytes\",{\"1\":{\"324\":4}}],[\"getname\",{\"1\":{\"314\":1,\"318\":1,\"381\":2,\"387\":1,\"420\":1}}],[\"getclass\",{\"1\":{\"481\":1}}],[\"getconstructor\",{\"1\":{\"310\":1}}],[\"getcause\",{\"1\":{\"301\":1}}],[\"getfield\",{\"1\":{\"310\":1}}],[\"getmethod\",{\"1\":{\"310\":1}}],[\"getmessage\",{\"1\":{\"301\":1,\"304\":1}}],[\"getvalue\",{\"1\":{\"295\":1,\"329\":1,\"337\":1}}],[\"getkey\",{\"1\":{\"295\":1,\"329\":1,\"337\":1}}],[\"gety\",{\"1\":{\"282\":1,\"283\":1}}],[\"getx\",{\"1\":{\"282\":1,\"283\":1}}],[\"getprobe\",{\"1\":{\"402\":1}}],[\"getprovince\",{\"1\":{\"76\":1,\"77\":2}}],[\"getpresignedobjecturlargs\",{\"1\":{\"142\":1}}],[\"getpresignedobjecturl\",{\"1\":{\"142\":2}}],[\"getstate\",{\"1\":{\"359\":2,\"360\":1,\"366\":1,\"367\":2,\"369\":1,\"370\":1,\"378\":1,\"412\":1,\"506\":1,\"507\":1,\"508\":3}}],[\"getstacktrace\",{\"1\":{\"301\":1}}],[\"getspeed\",{\"1\":{\"286\":1,\"288\":1,\"289\":1}}],[\"getsecretkey\",{\"1\":{\"139\":1}}],[\"getsalary\",{\"1\":{\"76\":1,\"77\":2}}],[\"getaccesskey\",{\"1\":{\"139\":1}}],[\"get\",{\"0\":{\"400\":1},\"1\":{\"84\":4,\"85\":2,\"86\":6,\"91\":4,\"92\":2,\"93\":6,\"96\":1,\"106\":1,\"107\":2,\"111\":1,\"112\":1,\"113\":3,\"114\":1,\"115\":6,\"142\":2,\"291\":1,\"295\":1,\"310\":1,\"327\":1,\"329\":3,\"349\":4,\"369\":1,\"370\":1,\"399\":1,\"400\":3,\"403\":1,\"413\":1},\"2\":{\"19\":1}}],[\"globle\",{\"1\":{\"34\":1}}],[\"globals\",{\"1\":{\"107\":1,\"115\":1}}],[\"global的路径\",{\"1\":{\"34\":1}}],[\"global\",{\"1\":{\"26\":1,\"34\":1,\"35\":1,\"102\":1,\"103\":1,\"104\":1,\"107\":3,\"111\":1,\"112\":1,\"115\":2,\"119\":1,\"121\":1,\"221\":1}}],[\"gh\",{\"1\":{\"27\":2}}],[\"two\",{\"1\":{\"397\":1}}],[\"typical\",{\"1\":{\"369\":1}}],[\"types\",{\"1\":{\"23\":1}}],[\"type\",{\"1\":{\"23\":1,\"85\":2,\"86\":1,\"92\":2,\"93\":1,\"103\":1,\"107\":1}}],[\"txt\",{\"1\":{\"304\":2}}],[\"tmp\",{\"1\":{\"275\":2}}],[\"t\",{\"1\":{\"254\":2,\"273\":2,\"324\":1,\"378\":6,\"401\":4,\"413\":1,\"516\":7,\"517\":1,\"518\":7}}],[\"tuesday\",{\"1\":{\"241\":1}}],[\"tutorial\",{\"1\":{\"47\":1},\"2\":{\"19\":1}}],[\"t2\",{\"1\":{\"210\":1}}],[\"t1\",{\"1\":{\"210\":1}}],[\"tb\",{\"1\":{\"185\":3,\"189\":2,\"205\":6}}],[\"than\",{\"1\":{\"402\":1}}],[\"that\",{\"1\":{\"369\":1,\"379\":1,\"517\":1,\"523\":2}}],[\"there\",{\"1\":{\"402\":1,\"523\":1}}],[\"their\",{\"1\":{\"402\":1}}],[\"then\",{\"1\":{\"366\":1}}],[\"the\",{\"1\":{\"349\":1,\"369\":1,\"370\":1,\"379\":2,\"397\":1,\"402\":5,\"484\":1,\"508\":4,\"516\":1,\"518\":2,\"523\":1}}],[\"themetype\",{\"1\":{\"107\":1,\"115\":1}}],[\"theme=themetype\",{\"1\":{\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1}}],[\"theme\",{\"1\":{\"15\":1,\"21\":1,\"22\":3,\"23\":4},\"2\":{\"24\":1}}],[\"threshold\",{\"1\":{\"399\":3,\"401\":2}}],[\"thread1\",{\"1\":{\"413\":2}}],[\"threadlocalrandom\",{\"1\":{\"402\":1}}],[\"threads\",{\"1\":{\"349\":1}}],[\"threadb\",{\"1\":{\"349\":6,\"420\":5,\"433\":4}}],[\"threada\",{\"1\":{\"349\":6,\"420\":3}}],[\"thread\",{\"1\":{\"314\":11,\"315\":1,\"316\":1,\"317\":5,\"318\":4,\"349\":15,\"359\":3,\"360\":2,\"366\":4,\"369\":5,\"370\":2,\"371\":1,\"377\":8,\"378\":3,\"379\":2,\"381\":8,\"386\":4,\"387\":13,\"394\":1,\"398\":2,\"413\":9,\"419\":6,\"420\":22,\"421\":2,\"423\":7,\"441\":5,\"461\":5,\"470\":8,\"494\":5,\"508\":8,\"513\":2,\"516\":1,\"517\":2,\"518\":3,\"519\":1,\"520\":2}}],[\"threaddeath\",{\"1\":{\"297\":1}}],[\"throwable\",{\"1\":{\"301\":5,\"401\":1}}],[\"throw\",{\"1\":{\"142\":1,\"303\":3,\"314\":3,\"318\":1,\"359\":2,\"360\":1,\"366\":1,\"367\":1,\"370\":1,\"378\":3,\"379\":1,\"393\":1,\"397\":1,\"399\":1,\"507\":1,\"508\":1,\"519\":2,\"520\":2}}],[\"throws\",{\"1\":{\"141\":4,\"142\":6,\"236\":2,\"237\":2,\"303\":2,\"310\":1,\"316\":1,\"317\":2,\"318\":1,\"375\":3,\"378\":1,\"413\":1,\"419\":1,\"420\":1,\"505\":2,\"508\":3,\"519\":2,\"520\":2}}],[\"this\",{\"1\":{\"282\":4,\"283\":3,\"310\":1,\"314\":1,\"317\":2,\"318\":3,\"366\":2,\"369\":1,\"378\":4,\"379\":1,\"394\":1,\"397\":1,\"398\":1,\"401\":2,\"402\":4,\"409\":3,\"420\":1,\"479\":2,\"490\":2,\"517\":2,\"518\":1,\"520\":1,\"523\":2}}],[\"thursday\",{\"1\":{\"241\":1}}],[\"task\",{\"1\":{\"413\":2}}],[\"tail\",{\"1\":{\"408\":4,\"516\":4,\"518\":2,\"523\":1}}],[\"tale\",{\"1\":{\"403\":1}}],[\"target\",{\"1\":{\"308\":1}}],[\"tag\",{\"1\":{\"96\":1}}],[\"tags\",{\"1\":{\"96\":2}}],[\"tabel\",{\"1\":{\"399\":1}}],[\"tab中索引为i的位置的元素为null\",{\"1\":{\"399\":1}}],[\"tabat\",{\"1\":{\"395\":2,\"399\":3,\"400\":1,\"401\":3}}],[\"table数组的代码为\",{\"1\":{\"401\":1}}],[\"tableb\",{\"1\":{\"207\":2}}],[\"tablea\",{\"1\":{\"207\":2}}],[\"tablesizefor\",{\"1\":{\"397\":3}}],[\"tables\",{\"1\":{\"184\":1}}],[\"table\",{\"1\":{\"181\":1,\"184\":1,\"185\":7,\"186\":1,\"200\":2,\"226\":1,\"393\":5,\"394\":1,\"395\":3,\"397\":5,\"398\":3,\"399\":16,\"400\":3,\"401\":5,\"402\":3}}],[\"tab\",{\"1\":{\"71\":1,\"394\":2,\"395\":6,\"398\":7,\"399\":11,\"400\":4,\"401\":7,\"402\":5}}],[\"tid=0x0069cc00\",{\"1\":{\"386\":1}}],[\"tid=0x02cdcc00\",{\"1\":{\"386\":1}}],[\"tid\",{\"1\":{\"369\":1,\"370\":1}}],[\"tinytext\",{\"1\":{\"183\":1}}],[\"tinyblob\",{\"1\":{\"183\":1}}],[\"tinyint\",{\"1\":{\"183\":1}}],[\"title=keyword+\",{\"1\":{\"119\":1,\"121\":1}}],[\"title=\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"107\":3,\"111\":1,\"115\":1}}],[\"titleopts\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"107\":3,\"111\":1,\"115\":1,\"119\":1,\"121\":1}}],[\"title\",{\"1\":{\"96\":1,\"102\":2,\"103\":1,\"104\":1,\"107\":4,\"111\":2,\"115\":2,\"119\":1,\"121\":1}}],[\"timed\",{\"1\":{\"412\":1,\"417\":3}}],[\"timeout\",{\"1\":{\"349\":1,\"375\":2,\"417\":1,\"508\":2,\"520\":1}}],[\"time=now\",{\"1\":{\"189\":1}}],[\"timestamp\",{\"1\":{\"183\":1}}],[\"timeunit\",{\"1\":{\"142\":1,\"375\":1,\"505\":1,\"508\":1,\"520\":1}}],[\"timeline\",{\"1\":{\"106\":5,\"107\":6,\"114\":5,\"115\":6,\"120\":2,\"121\":6}}],[\"time\",{\"1\":{\"93\":2,\"106\":1,\"107\":1,\"114\":1,\"115\":1,\"121\":1,\"129\":1,\"183\":1,\"189\":1,\"375\":1,\"505\":1}}],[\"tonanos\",{\"1\":{\"508\":1}}],[\"tochararray\",{\"1\":{\"260\":2,\"324\":2}}],[\"touppercase\",{\"1\":{\"260\":1,\"324\":1}}],[\"tolowercase\",{\"1\":{\"260\":1,\"324\":1}}],[\"tostring\",{\"1\":{\"257\":1,\"269\":1,\"273\":1,\"282\":1,\"283\":1,\"284\":2,\"301\":1,\"322\":1,\"325\":1,\"337\":1,\"479\":2}}],[\"top\",{\"1\":{\"102\":2,\"107\":2,\"111\":2,\"115\":2}}],[\"top=\",{\"1\":{\"102\":2,\"103\":1,\"104\":1,\"105\":2,\"106\":1,\"107\":7,\"111\":2,\"114\":1,\"115\":3}}],[\"tooltipopts\",{\"1\":{\"102\":2,\"103\":1,\"104\":1,\"107\":4,\"111\":1,\"112\":1,\"115\":2}}],[\"tooltip\",{\"1\":{\"102\":2,\"103\":1,\"104\":1,\"107\":4,\"111\":1,\"112\":1,\"115\":2}}],[\"toolbar\",{\"1\":{\"23\":1}}],[\"total\",{\"1\":{\"101\":1,\"103\":1,\"107\":2,\"198\":2}}],[\"to\",{\"1\":{\"67\":1,\"70\":1,\"75\":1,\"85\":1,\"86\":1,\"92\":2,\"93\":2,\"185\":1,\"329\":2,\"349\":4,\"369\":5,\"370\":1,\"379\":4,\"386\":2,\"394\":1,\"399\":1,\"401\":2,\"508\":3,\"516\":1,\"517\":3,\"518\":3,\"523\":6}}],[\"tle\",{\"1\":{\"57\":1}}],[\"traverse\",{\"1\":{\"518\":1}}],[\"trade\",{\"1\":{\"399\":1}}],[\"transferindex\",{\"1\":{\"401\":3,\"402\":1}}],[\"transfer方法源码为\",{\"1\":{\"401\":1}}],[\"transfer\",{\"0\":{\"401\":1},\"1\":{\"401\":3,\"402\":2}}],[\"transferforsignal\",{\"1\":{\"379\":4}}],[\"transferto\",{\"1\":{\"142\":1}}],[\"transiently\",{\"1\":{\"379\":1}}],[\"transient\",{\"1\":{\"377\":2,\"402\":4,\"408\":2}}],[\"transaction\",{\"1\":{\"217\":1}}],[\"trimtosize\",{\"1\":{\"327\":1}}],[\"trim\",{\"1\":{\"260\":1,\"324\":1}}],[\"trying\",{\"1\":{\"523\":1}}],[\"tryacquirenanos\",{\"0\":{\"520\":1},\"1\":{\"508\":1,\"512\":1,\"520\":2}}],[\"tryacquiresharednanos\",{\"0\":{\"524\":1},\"1\":{\"512\":1}}],[\"tryacquireshared\",{\"1\":{\"369\":2,\"508\":1,\"522\":4}}],[\"tryacquire\",{\"1\":{\"360\":1,\"366\":3,\"378\":1,\"507\":6,\"508\":5,\"515\":1,\"516\":2,\"519\":2,\"520\":2}}],[\"tryrelease返回\",{\"1\":{\"518\":1}}],[\"tryreleaseshared\",{\"1\":{\"369\":1,\"370\":2,\"508\":1,\"523\":2}}],[\"tryrelease\",{\"1\":{\"359\":2,\"367\":2,\"508\":2,\"518\":1}}],[\"trylock\",{\"1\":{\"349\":1,\"505\":2,\"508\":2,\"520\":1}}],[\"try\",{\"0\":{\"304\":1},\"1\":{\"85\":1,\"86\":2,\"92\":1,\"93\":2,\"142\":1,\"302\":1,\"303\":1,\"304\":4,\"314\":3,\"316\":1,\"318\":1,\"349\":1,\"369\":1,\"371\":2,\"377\":1,\"378\":1,\"379\":1,\"381\":3,\"387\":1,\"393\":1,\"398\":1,\"401\":2,\"413\":1,\"419\":1,\"420\":1,\"423\":2,\"441\":1,\"461\":1,\"470\":1,\"494\":1,\"504\":1,\"508\":1,\"516\":2,\"518\":1,\"519\":1,\"520\":1,\"522\":1}}],[\"treeifybin\",{\"1\":{\"399\":3}}],[\"treeify\",{\"1\":{\"399\":3}}],[\"treebin<k\",{\"1\":{\"394\":1,\"399\":2,\"401\":4}}],[\"treebins\",{\"1\":{\"394\":1}}],[\"treebin\",{\"1\":{\"394\":5,\"399\":6,\"401\":2}}],[\"treenode<k\",{\"1\":{\"394\":7,\"401\":4}}],[\"treenode\",{\"1\":{\"394\":5,\"399\":2}}],[\"treemap\",{\"1\":{\"329\":3}}],[\"treemap<k\",{\"1\":{\"295\":2}}],[\"treeset\",{\"1\":{\"328\":2,\"329\":1}}],[\"treeset多的函数\",{\"1\":{\"294\":1}}],[\"treeset<k>\",{\"1\":{\"294\":1}}],[\"tree\",{\"1\":{\"48\":1,\"394\":1}}],[\"true\",{\"1\":{\"1\":2,\"26\":1,\"233\":1,\"247\":1,\"249\":1,\"318\":1,\"322\":1,\"359\":5,\"360\":3,\"366\":2,\"371\":1,\"378\":2,\"379\":1,\"381\":1,\"398\":1,\"399\":1,\"401\":5,\"402\":1,\"419\":2,\"423\":3,\"467\":2,\"470\":3,\"497\":1,\"508\":8,\"516\":2,\"517\":2,\"518\":2,\"519\":2,\"520\":3,\"522\":2,\"523\":1}}],[\"temp\",{\"1\":{\"488\":1,\"490\":1}}],[\"template\",{\"1\":{\"23\":1}}],[\"terminated\",{\"1\":{\"417\":1,\"420\":11}}],[\"terminates\",{\"1\":{\"412\":1}}],[\"terminal\",{\"1\":{\"146\":2}}],[\"tensorflow\",{\"1\":{\"134\":1}}],[\"text=\",{\"1\":{\"102\":1,\"107\":1,\"111\":1,\"115\":1}}],[\"textstyleopts\",{\"1\":{\"102\":2,\"107\":2,\"111\":2,\"115\":2,\"119\":1,\"121\":1}}],[\"textstyle\",{\"1\":{\"102\":2,\"107\":2,\"111\":2,\"115\":2,\"119\":1,\"121\":1}}],[\"text2\",{\"1\":{\"76\":2,\"77\":2}}],[\"text1\",{\"1\":{\"76\":3,\"77\":3}}],[\"text\",{\"1\":{\"76\":11,\"77\":11,\"96\":2,\"183\":1,\"221\":1}}],[\"test10\",{\"1\":{\"142\":1}}],[\"test2\",{\"1\":{\"142\":1}}],[\"test09\",{\"1\":{\"142\":1}}],[\"test08\",{\"1\":{\"142\":1}}],[\"test07\",{\"1\":{\"142\":1}}],[\"test06\",{\"1\":{\"142\":1}}],[\"test05\",{\"1\":{\"142\":1}}],[\"test04\",{\"1\":{\"141\":1}}],[\"test03\",{\"1\":{\"141\":1}}],[\"test02\",{\"1\":{\"141\":1}}],[\"test01\",{\"1\":{\"141\":1}}],[\"test\",{\"1\":{\"49\":1,\"142\":5,\"146\":6,\"158\":4,\"481\":3,\"482\":2,\"483\":1}}],[\"testlib\",{\"1\":{\"49\":3}}],[\"tests\",{\"1\":{\"47\":1,\"49\":2,\"51\":2,\"53\":1,\"57\":2}}],[\"ts\",{\"1\":{\"23\":1}}],[\"此图来源于\",{\"1\":{\"417\":1}}],[\"此异常由\",{\"1\":{\"300\":1}}],[\"此类异常是程序的致命异常\",{\"1\":{\"297\":1}}],[\"此时的结果是不可预知的\",{\"1\":{\"488\":1}}],[\"此时这两个操作就存在数据依赖性\",{\"1\":{\"430\":1}}],[\"此时nexttable=null\",{\"1\":{\"402\":1}}],[\"此时将新值\",{\"1\":{\"393\":1}}],[\"此时\",{\"1\":{\"266\":1,\"272\":1,\"408\":1}}],[\"此时在数据量大的情况下\",{\"1\":{\"221\":1}}],[\"此时就会形成一个单向链表\",{\"1\":{\"221\":1}}],[\"此时只能够使用别名来指定字段\",{\"1\":{\"207\":1}}],[\"此时出于提高查询效率的考虑\",{\"1\":{\"201\":1}}],[\"此处无须显示的return语句\",{\"1\":{\"275\":1}}],[\"此处是我们要在网络中获取的数据文件\",{\"1\":{\"85\":1}}],[\"此处存放自己写和一些优秀的开源项目\",{\"1\":{\"14\":1}}],[\"此处存放自己写的一些学习笔记\",{\"1\":{\"12\":1}}],[\"此处存放刷题时的思路和笔记\",{\"1\":{\"13\":1}}],[\"此处存放一些计算机大类的笔记\",{\"1\":{\"2\":1}}],[\"此教程将指引你使用polygon平台创建\",{\"1\":{\"38\":1}}],[\"此教程将指引你创建一个\",{\"1\":{\"15\":1,\"21\":1,\"61\":1}}],[\"笔试题和面试题等\",{\"1\":{\"13\":1}}],[\"帮助创建\",{\"1\":{\"323\":1}}],[\"帮助学习\",{\"1\":{\"12\":1,\"14\":1}}],[\"帮助用户灵活\",{\"1\":{\"9\":1}}],[\"为保证能够释放\",{\"1\":{\"504\":1}}],[\"为保持\",{\"1\":{\"336\":1}}],[\"为什么\",{\"0\":{\"490\":1}}],[\"为什么要用到并发\",{\"0\":{\"346\":1}}],[\"为例的话\",{\"1\":{\"489\":1}}],[\"为此\",{\"1\":{\"469\":1}}],[\"为此做一个区分\",{\"1\":{\"85\":1,\"92\":1}}],[\"为程序员在上层提供了六条规则\",{\"1\":{\"431\":1}}],[\"为新容量的\",{\"1\":{\"401\":1}}],[\"为红黑树的树节点时的操作为\",{\"1\":{\"399\":1}}],[\"为红黑树的根节点\",{\"1\":{\"399\":1}}],[\"为当前桶的所有的节点组成的链表的头结点\",{\"1\":{\"399\":1}}],[\"为链表的头结点\",{\"1\":{\"399\":1}}],[\"为四分之三\",{\"1\":{\"398\":1}}],[\"为每一个\",{\"1\":{\"391\":1}}],[\"为0则释放写锁\",{\"1\":{\"367\":1}}],[\"为接口\",{\"1\":{\"331\":1}}],[\"为了实现\",{\"1\":{\"469\":2}}],[\"为了保证各个处理器的缓存是一致的\",{\"1\":{\"466\":1}}],[\"为了保证能够正确初始化\",{\"1\":{\"398\":1}}],[\"为了避免无用的自旋\",{\"1\":{\"459\":1}}],[\"为了让线程获得锁的代价更低而引入了偏向锁\",{\"1\":{\"453\":1}}],[\"为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制\",{\"1\":{\"435\":1}}],[\"为了平衡这种巨大的差距\",{\"1\":{\"429\":1}}],[\"为了性能优化\",{\"1\":{\"427\":1,\"469\":1,\"497\":1}}],[\"为了统计元素个数\",{\"1\":{\"402\":1}}],[\"为了方面下面的讲解这里先直接给出\",{\"1\":{\"399\":1}}],[\"为了解决线程安全的问题\",{\"1\":{\"399\":1,\"407\":1}}],[\"为了满足\",{\"1\":{\"397\":1}}],[\"为了支持重入性\",{\"1\":{\"359\":1}}],[\"为了提高处理速度\",{\"1\":{\"466\":1}}],[\"为了提高性能\",{\"1\":{\"430\":1}}],[\"为了提高范围查询效率\",{\"1\":{\"221\":1}}],[\"为了提升响应速度\",{\"1\":{\"346\":1}}],[\"为了减少冲突\",{\"1\":{\"228\":1}}],[\"为\",{\"1\":{\"185\":1,\"189\":1,\"366\":3,\"378\":1,\"398\":1,\"399\":1,\"409\":1,\"516\":1}}],[\"为脚本解释器\",{\"1\":{\"146\":1}}],[\"为分割符\",{\"1\":{\"118\":1}}],[\"为日后出\",{\"1\":{\"44\":1}}],[\"为应用软件间共享资源提供了可复用的\",{\"1\":{\"9\":1}}],[\"为上层应用软件提供开发\",{\"1\":{\"9\":1}}],[\"中需要重写的方法\",{\"1\":{\"507\":1}}],[\"中并没有多少代码\",{\"1\":{\"505\":1}}],[\"中提供的八个包装类和\",{\"1\":{\"484\":1}}],[\"中提供了\",{\"1\":{\"451\":1}}],[\"中变量\",{\"1\":{\"476\":1}}],[\"中偏向锁的标识是否设置成\",{\"1\":{\"454\":1}}],[\"中在执行完同步代码块之后紧接着再会去执行一个静态同步方法\",{\"1\":{\"443\":1}}],[\"中关键字\",{\"1\":{\"441\":1}}],[\"中给出的定义如下\",{\"1\":{\"427\":1}}],[\"中会调用方法\",{\"1\":{\"523\":1}}],[\"中会持续监测\",{\"1\":{\"419\":1}}],[\"中会大量使用\",{\"1\":{\"395\":1}}],[\"中断操作可以看做线程间一种简便的交互方式\",{\"1\":{\"419\":1}}],[\"中断好比其他线程对该线程打了一个招呼\",{\"1\":{\"419\":1}}],[\"中断可以理解为线程的一个标志位\",{\"1\":{\"419\":1}}],[\"中断或者到了某个时间\",{\"1\":{\"375\":1}}],[\"中断或者超时\",{\"1\":{\"375\":1}}],[\"中对\",{\"1\":{\"409\":1}}],[\"中定位到具体的桶\",{\"1\":{\"403\":1}}],[\"中通过\",{\"1\":{\"399\":1}}],[\"中待插入的索引\",{\"1\":{\"399\":1}}],[\"中有几个关键的属性和类\",{\"1\":{\"392\":1}}],[\"中有两个成员变量\",{\"1\":{\"377\":1}}],[\"中逻辑判断为\",{\"1\":{\"378\":1}}],[\"中新增了一个\",{\"1\":{\"337\":1}}],[\"中也可以使用\",{\"1\":{\"332\":1}}],[\"中实现堆栈数据结构\",{\"1\":{\"330\":1}}],[\"中键如果是基本数据类型\",{\"1\":{\"329\":1}}],[\"中标准的对象创建方式\",{\"1\":{\"324\":1}}],[\"中注解占据了更重要的角色\",{\"1\":{\"306\":1}}],[\"中所有偶数的和\",{\"1\":{\"248\":1}}],[\"中所有数的立方和\",{\"1\":{\"243\":1,\"245\":1}}],[\"中不同类型变量的输出格式\",{\"1\":{\"237\":1}}],[\"中间表至少包含两个外键\",{\"1\":{\"202\":1}}],[\"中间件解决了异构网络环境下软件互联和互操作等共性问题\",{\"1\":{\"9\":1}}],[\"中间件与操作系统和数据库共同构成基础软件三大支柱\",{\"1\":{\"9\":1}}],[\"中间件不仅仅实现互连\",{\"1\":{\"9\":1}}],[\"中间件是一类软件统称\",{\"1\":{\"9\":1}}],[\"中间件在客户服务器的操作系统\",{\"1\":{\"9\":1}}],[\"中间件\",{\"0\":{\"9\":1,\"530\":1},\"1\":{\"9\":1},\"2\":{\"130\":1,\"135\":1,\"143\":1}}],[\"中是\",{\"1\":{\"198\":1}}],[\"中等长度文本数据\",{\"1\":{\"183\":1}}],[\"中数据库的常见操作\",{\"1\":{\"174\":1}}],[\"中常见的\",{\"1\":{\"146\":1}}],[\"中配置\",{\"1\":{\"139\":1}}],[\"中的同步队列则是通过链式方式进行实现\",{\"1\":{\"513\":1}}],[\"中的同步队列是一种什么样的数据结构\",{\"1\":{\"512\":1}}],[\"中的模板方法\",{\"1\":{\"507\":1}}],[\"中的两个示意图帮助理解\",{\"1\":{\"469\":1}}],[\"中的任意操作\",{\"1\":{\"433\":2}}],[\"中的元素复制到\",{\"1\":{\"401\":1}}],[\"中的元素和\",{\"1\":{\"329\":1}}],[\"中的位置\",{\"1\":{\"399\":1}}],[\"中的方法\",{\"1\":{\"505\":1}}],[\"中的方法不多\",{\"1\":{\"386\":1}}],[\"中的方法实现同步组件的同步语义\",{\"1\":{\"366\":1}}],[\"中的方法在\",{\"1\":{\"332\":1}}],[\"中的子串\",{\"1\":{\"260\":1}}],[\"中的所有质数\",{\"1\":{\"249\":1}}],[\"中的条件表达式作用一样\",{\"1\":{\"245\":1}}],[\"中的语句\",{\"1\":{\"241\":1}}],[\"中的语法\",{\"1\":{\"146\":1}}],[\"中的内容为可选参数\",{\"1\":{\"181\":1}}],[\"中的命令行可以看成是一个\",{\"1\":{\"146\":1}}],[\"中的\",{\"1\":{\"139\":1,\"337\":1,\"366\":1,\"377\":1,\"378\":1,\"393\":1,\"401\":1,\"403\":1}}],[\"中的求职信息\",{\"1\":{\"79\":1}}],[\"中文文档地址\",{\"1\":{\"134\":1}}],[\"中文官网\",{\"1\":{\"132\":1}}],[\"中山\",{\"1\":{\"76\":1,\"77\":1}}],[\"中卫\",{\"1\":{\"76\":1,\"77\":1}}],[\"中\",{\"1\":{\"48\":1,\"53\":1,\"306\":1,\"308\":1,\"330\":1,\"349\":1,\"385\":1,\"394\":1,\"401\":1,\"452\":1,\"481\":1,\"507\":1}}],[\"中生成\",{\"1\":{\"47\":1}}],[\"中上传图片\",{\"1\":{\"47\":1}}],[\"中设置\",{\"1\":{\"1\":1}}],[\"档案主页\",{\"1\":{\"1\":1}}],[\"和处理器共同为编写单线程程序的程序员创建了一个幻觉\",{\"1\":{\"430\":1}}],[\"和处理器都必须遵守\",{\"1\":{\"430\":1}}],[\"和线程\",{\"1\":{\"429\":2,\"468\":1,\"487\":1,\"488\":1}}],[\"和线程b\",{\"1\":{\"380\":1}}],[\"和公平的锁获取方式\",{\"1\":{\"364\":1}}],[\"和可变字符串\",{\"1\":{\"323\":1}}],[\"和a\",{\"1\":{\"275\":1}}],[\"和字段值的长度无关\",{\"1\":{\"183\":1}}],[\"和d\",{\"1\":{\"183\":2}}],[\"和校验和\",{\"1\":{\"134\":1}}],[\"和传统对象存储相比\",{\"1\":{\"134\":1}}],[\"和city=100010000\",{\"1\":{\"81\":1}}],[\"和田地区\",{\"1\":{\"76\":1,\"77\":1}}],[\"和\",{\"0\":{\"33\":1,\"374\":1},\"1\":{\"1\":1,\"129\":1,\"134\":2,\"183\":2,\"208\":1,\"245\":1,\"330\":1,\"337\":1,\"364\":1,\"375\":2,\"377\":1,\"380\":2,\"381\":1,\"385\":1,\"399\":2,\"401\":2,\"408\":2,\"417\":1,\"419\":1,\"422\":1,\"430\":2,\"449\":2,\"456\":1,\"468\":1,\"484\":2,\"488\":2,\"490\":2,\"494\":7,\"497\":2,\"508\":4,\"516\":1,\"518\":1}}],[\"介绍过线程间等待\",{\"1\":{\"385\":1}}],[\"介绍\",{\"0\":{\"1\":1,\"205\":1,\"210\":1,\"216\":1,\"220\":1,\"427\":1},\"1\":{\"30\":1,\"369\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
